{"version":3,"sources":["../../src/partial-evaluators/CallExpression.js"],"names":["ast","strictCode","env","realm","setNextExecutionContextLocation","loc","ref","calleeAst","calleeIO","partiallyEvaluateCompletion","callee","completion","value","func","GetValue","io","partialArgs","argVals","arg","arguments","argValue","argAst","argIO","partiallyEvaluateCompletionDeref","concat","push","stopEffectCaptureJoinApplyAndReturnCompletion","resultAst","t","callExpression","composeNormalCompletions","callResult","EvaluateCall","callCompletion","unbundleNormalCompletion","undefined","captureEffects","callBothFunctionsAndJoinTheirEffects","funcs","cond","func1","func2","getType","isTypeCompatibleWith","e1","evaluateForEffects","e2","joinedEffects","joinEffects","result","generator","modifiedBindings","modifiedProperties","createdObjects","joinedCompletion","composeWithSavedCompletion","applyEffects","argList","kind","args","createFromType","throwIfNotConcrete","IsPropertyReference","GetReferencedName","intrinsics","eval","length","evalText","strictCaller","evalRealm","PerformEval","thisValue","refEnv","GetBase","WithBaseObject","thisCall","tailCall","currentLocation","err"],"mappings":"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","file":"CallExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelNodeCallExpression, BabelNodeExpression, BabelNodeStatement } from \"babel-types\";\nimport type { Realm } from \"../realm.js\";\nimport { Effects } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\n\nimport { AbruptCompletion, Completion, PossiblyNormalCompletion } from \"../completions.js\";\nimport { EnvironmentRecord, Reference } from \"../environment.js\";\nimport { EvaluateDirectCallWithArgList, GetThisValue, IsInTailPosition, SameValue } from \"../methods/index.js\";\nimport { Environment, Functions, Join } from \"../singletons.js\";\nimport { AbstractValue, BooleanValue, FunctionValue, Value } from \"../values/index.js\";\n\nimport * as t from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\n// ECMA262 12.3.4.1\nexport default function(\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): [Completion | Value, BabelNodeExpression, Array<BabelNodeStatement>] {\n  realm.setNextExecutionContextLocation(ast.loc);\n\n  // 1. Let ref be the result of evaluating MemberExpression.\n  let [ref, calleeAst, calleeIO] = env.partiallyEvaluateCompletion(ast.callee, strictCode);\n  if (ref instanceof AbruptCompletion) return [ref, (calleeAst: any), calleeIO];\n  let completion;\n  if (ref instanceof PossiblyNormalCompletion) {\n    completion = ref;\n    ref = completion.value;\n  }\n  invariant(ref instanceof Value || ref instanceof Reference);\n\n  // 2. Let func be ? GetValue(ref).\n  let func = Environment.GetValue(realm, ref);\n\n  let io = calleeIO;\n  let partialArgs = [];\n  let argVals = [];\n  for (let arg of ast.arguments) {\n    let [argValue, argAst, argIO] = env.partiallyEvaluateCompletionDeref(arg, strictCode);\n    io = io.concat(argIO);\n    partialArgs.push((argAst: any));\n    if (argValue instanceof AbruptCompletion) {\n      if (completion instanceof PossiblyNormalCompletion)\n        completion = Join.stopEffectCaptureJoinApplyAndReturnCompletion(completion, argValue, realm);\n      else completion = argValue;\n      let resultAst = t.callExpression((calleeAst: any), partialArgs);\n      return [completion, resultAst, io];\n    }\n    if (argValue instanceof PossiblyNormalCompletion) {\n      argVals.push(argValue.value);\n      if (completion instanceof PossiblyNormalCompletion)\n        completion = Join.composeNormalCompletions(completion, argValue, argValue.value, realm);\n      else completion = argValue;\n    } else {\n      invariant(argValue instanceof Value);\n      argVals.push(argValue);\n    }\n  }\n\n  let callResult = EvaluateCall(ref, func, ast, argVals, strictCode, env, realm);\n  if (callResult instanceof AbruptCompletion) {\n    if (completion instanceof PossiblyNormalCompletion)\n      completion = Join.stopEffectCaptureJoinApplyAndReturnCompletion(completion, callResult, realm);\n    else completion = callResult;\n    let resultAst = t.callExpression((calleeAst: any), partialArgs);\n    return [completion, resultAst, io];\n  }\n  let callCompletion;\n  [callCompletion, callResult] = Join.unbundleNormalCompletion(callResult);\n  invariant(callResult instanceof Value);\n  invariant(completion === undefined || completion instanceof PossiblyNormalCompletion);\n  completion = Join.composeNormalCompletions(completion, callCompletion, callResult, realm);\n  if (completion instanceof PossiblyNormalCompletion) {\n    realm.captureEffects(completion);\n  }\n  return [completion, t.callExpression((calleeAst: any), partialArgs), io];\n}\n\nfunction callBothFunctionsAndJoinTheirEffects(\n  funcs: Array<Value>,\n  ast: BabelNodeCallExpression,\n  argVals: Array<Value>,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): AbruptCompletion | Value {\n  let [cond, func1, func2] = funcs;\n  invariant(cond instanceof AbstractValue && cond.getType() === BooleanValue);\n  invariant(Value.isTypeCompatibleWith(func1.getType(), FunctionValue));\n  invariant(Value.isTypeCompatibleWith(func2.getType(), FunctionValue));\n\n  const e1 = realm.evaluateForEffects(\n    () => EvaluateCall(func1, func1, ast, argVals, strictCode, env, realm),\n    undefined,\n    \"callBothFunctionsAndJoinTheirEffects/1\"\n  );\n\n  const e2 = realm.evaluateForEffects(\n    () => EvaluateCall(func2, func2, ast, argVals, strictCode, env, realm),\n    undefined,\n    \"callBothFunctionsAndJoinTheirEffects/2\"\n  );\n\n  let joinedEffects = Join.joinEffects(\n    realm,\n    cond,\n    new Effects(e1.result, e1.generator, e1.modifiedBindings, e1.modifiedProperties, e1.createdObjects),\n    new Effects(e2.result, e2.generator, e2.modifiedBindings, e2.modifiedProperties, e2.createdObjects)\n  );\n  let joinedCompletion = joinedEffects.result;\n  if (joinedCompletion instanceof PossiblyNormalCompletion) {\n    // in this case one of the branches may complete abruptly, which means that\n    // not all control flow branches join into one flow at this point.\n    // Consequently we have to continue tracking changes until the point where\n    // all the branches come together into one.\n    joinedCompletion = realm.composeWithSavedCompletion(joinedCompletion);\n  }\n\n  // Note that the effects of (non joining) abrupt branches are not included\n  // in joinedEffects, but are tracked separately inside joinedCompletion.\n  realm.applyEffects(joinedEffects);\n\n  // return or throw completion\n  invariant(joinedCompletion instanceof AbruptCompletion || joinedCompletion instanceof Value);\n  return joinedCompletion;\n}\n\nfunction EvaluateCall(\n  ref: Value | Reference,\n  func: Value,\n  ast: BabelNodeCallExpression,\n  argList: Array<Value>,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): AbruptCompletion | Value {\n  if (func instanceof AbstractValue && Value.isTypeCompatibleWith(func.getType(), FunctionValue)) {\n    if (func.kind === \"conditional\")\n      return callBothFunctionsAndJoinTheirEffects(func.args, ast, argList, strictCode, env, realm);\n\n    // The called function comes from the environmental model and we require that\n    // such functions have no visible side-effects. Hence we can carry on\n    // by returning a call node with the arguments updated with their partial counterparts.\n    // TODO: obtain the type of the return value from the abstract function.\n    return AbstractValue.createFromType(realm, Value);\n  }\n  // If func is abstract and not known to be a safe function, we can't safely continue.\n  func = func.throwIfNotConcrete();\n\n  // 3. If Type(ref) is Reference and IsPropertyReference(ref) is false and GetReferencedName(ref) is \"eval\", then\n  if (\n    ref instanceof Reference &&\n    !Environment.IsPropertyReference(realm, ref) &&\n    Environment.GetReferencedName(realm, ref) === \"eval\"\n  ) {\n    // a. If SameValue(func, %eval%) is true, then\n    if (SameValue(realm, func, realm.intrinsics.eval)) {\n      // i. Let argList be ? ArgumentListEvaluation(Arguments).\n\n      // ii. If argList has no elements, return undefined.\n      if (argList.length === 0) return realm.intrinsics.undefined;\n\n      // iii. Let evalText be the first element of argList.\n      let evalText = argList[0];\n\n      // iv. If the source code matching this CallExpression is strict code, let strictCaller be true. Otherwise let strictCaller be false.\n      let strictCaller = strictCode;\n\n      // v. Let evalRealm be the current Realm Record.\n      let evalRealm = realm;\n\n      // vi. Return ? PerformEval(evalText, evalRealm, strictCaller, true).\n      return Functions.PerformEval(realm, evalText, evalRealm, strictCaller, true);\n    }\n  }\n\n  let thisValue;\n\n  // 4. If Type(ref) is Reference, then\n  if (ref instanceof Reference) {\n    // a. If IsPropertyReference(ref) is true, then\n    if (Environment.IsPropertyReference(realm, ref)) {\n      // i. Let thisValue be GetThisValue(ref).\n      thisValue = GetThisValue(realm, ref);\n    } else {\n      // b. Else, the base of ref is an Environment Record\n      // i. Let refEnv be GetBase(ref).\n      let refEnv = Environment.GetBase(realm, ref);\n      invariant(refEnv instanceof EnvironmentRecord);\n\n      // ii. Let thisValue be refEnv.WithBaseObject().\n      thisValue = refEnv.WithBaseObject();\n    }\n  } else {\n    // 5. Else Type(ref) is not Reference,\n    // a. Let thisValue be undefined.\n    thisValue = realm.intrinsics.undefined;\n  }\n\n  // 6. Let thisCall be this CallExpression.\n  let thisCall = ast;\n\n  // 7. Let tailCall be IsInTailPosition(thisCall). (See 14.6.1)\n  let tailCall = IsInTailPosition(realm, thisCall);\n\n  // 8. Return ? EvaluateDirectCall(func, thisValue, Arguments, tailCall).\n\n  try {\n    realm.currentLocation = ast.loc; // this helps us to detect recursive calls\n    return EvaluateDirectCallWithArgList(realm, strictCode, env, ref, func, thisValue, argList, tailCall);\n  } catch (err) {\n    if (err instanceof Completion) return err;\n    throw err;\n  }\n}\n"]}