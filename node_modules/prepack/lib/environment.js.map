{"version":3,"sources":["../src/environment.js"],"names":["havocBinding","mightBecomeAnObject","t","sourceMap","require","deriveGetBinding","realm","binding","types","topVal","values","generator","undefined","deriveAbstract","_","context","serializeBinding","environment","value","hasLeaked","isFinalObject","recordModifiedBinding","realmGenerator","emitBindingAssignment","intrinsics","EnvironmentRecord","constructor","isReadOnly","id","nextId","HasBinding","N","CreateMutableBinding","D","isGlobal","CreateImmutableBinding","S","skipRecord","InitializeBinding","V","SetMutableBinding","GetBindingValue","DeleteBinding","HasThisBinding","GetThisBinding","HasSuperBinding","WithBaseObject","BindThisValue","DeclarativeEnvironmentRecord","bindings","Object","create","frozen","envRec","initialized","mutable","deletable","name","strict","empty","createErrorThrowCompletion","ReferenceError","TypeError","ObjectEnvironmentRecord","obj","object","foundBinding","withEnvironment","unscopables","SymbolUnscopables","blocked","ToBooleanPartial","throwIfNotConcrete","configValue","DefinePropertyOrThrow","writable","enumerable","configurable","Set","$Delete","FunctionEnvironmentRecord","$ThisBindingStatus","$ThisValue","$HomeObject","GetSuperBase","home","$GetPrototypeOf","GlobalEnvironmentRecord","DclRec","$DeclarativeRecord","ObjRec","$ObjectRecord","globalObject","existingProp","status","varNames","$VarNames","indexOf","splice","$GlobalThisValue","HasVarDeclaration","varDeclaredNames","HasLexicalDeclaration","HasRestrictedGlobalProperty","$GetOwnProperty","ThrowIfMightHaveBeenDeleted","CanDeclareGlobalVar","hasProperty","CanDeclareGlobalFunction","CreateGlobalVarBinding","extensible","push","CreateGlobalFunctionBinding","desc","uid","LexicalEnvironment","destroyed","_uid","destroy","environmentRecord","assignToGlobal","globalAst","rvalue","globalValue","evaluate","PutValue","partiallyEvaluateCompletionDeref","ast","strictCode","metadata","result","partial_ast","partial_io","partiallyEvaluateCompletion","Reference","GetValue","partiallyEvaluate","err","Error","evaluateCompletionDeref","evaluateCompletion","containsBreakOrContinue","reportIntrospectionError","joinCondition","evaluateAbstractCompletion","evaluateAbstract","concatenateAndParse","sources","sourceType","asts","code","directives","source","node","statistics","parsing","measure","fileContents","filePath","sourceMapContents","length","fixupSourceLocations","fixup_source_locations","fixupFilenames","fixup_filenames","concat","program","body","e","error","message","_SafeGetDataPropertyValue","location","start","line","column","end","diagnostic","handleError","file","executeSources","onParse","lexicalEnvironment","variableEnvironment","pushContext","res","evaluation","popContext","onDestroyScope","activeLexicalEnvironments","size","executePartialEvaluator","options","partialAST","type","fileAst","prog","sourceMaps","execute","filename","map","smc","SourceMapConsumer","loc","fixup","fixup_comments","leadingComments","innerComments","trailingComments","new_loc","new_pos","old_pos","originalPositionFor","comments","c","cloc","debuggerInstance","checkForActions","currentLocation","testTimeout","evaluator","evaluators","evaluatedNodes","evaluateDeref","partialEvaluator","partialEvaluators","base","getType","refName","thisValue","referencedName","mightNotBeString","mightNotBeNumber","isSimpleObject","$Realm","isInPureScope"],"mappings":"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","file":"environment.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type {\n  BabelNode,\n  BabelNodeComment,\n  BabelNodeFile,\n  BabelNodeLVal,\n  BabelNodePosition,\n  BabelNodeStatement,\n  BabelNodeSourceLocation,\n} from \"babel-types\";\nimport type { Realm } from \"./realm.js\";\nimport type { SourceFile, SourceMap, SourceType } from \"./types.js\";\n\nimport {\n  AbruptCompletion,\n  Completion,\n  JoinedAbruptCompletions,\n  PossiblyNormalCompletion,\n  ThrowCompletion,\n} from \"./completions.js\";\nimport { CompilerDiagnostic, FatalError } from \"./errors.js\";\nimport { defaultOptions } from \"./options\";\nimport type { PartialEvaluatorOptions } from \"./options\";\nimport { ExecutionContext } from \"./realm.js\";\nimport {\n  AbstractValue,\n  NullValue,\n  SymbolValue,\n  BooleanValue,\n  FunctionValue,\n  NumberValue,\n  IntegralValue,\n  ObjectValue,\n  AbstractObjectValue,\n  StringValue,\n  UndefinedValue,\n  Value,\n} from \"./values/index.js\";\nimport generate from \"babel-generator\";\nimport parse from \"./utils/parse.js\";\nimport invariant from \"./invariant.js\";\nimport traverseFast from \"./utils/traverse-fast.js\";\nimport { HasProperty, Get, IsExtensible, HasOwnProperty, IsDataDescriptor } from \"./methods/index.js\";\nimport { Environment, Havoc, Properties, To } from \"./singletons.js\";\nimport * as t from \"babel-types\";\nimport { TypesDomain, ValuesDomain } from \"./domains/index.js\";\nimport PrimitiveValue from \"./values/PrimitiveValue\";\n\nconst sourceMap = require(\"source-map\");\n\nfunction deriveGetBinding(realm: Realm, binding: Binding) {\n  let types = TypesDomain.topVal;\n  let values = ValuesDomain.topVal;\n  invariant(realm.generator !== undefined);\n  return realm.generator.deriveAbstract(types, values, [], (_, context) => context.serializeBinding(binding));\n}\n\nexport function havocBinding(binding: Binding) {\n  let realm = binding.environment.realm;\n  let value = binding.value;\n  if (!binding.hasLeaked && !(value instanceof ObjectValue && value.isFinalObject())) {\n    realm.recordModifiedBinding(binding).hasLeaked = true;\n    if (value !== undefined) {\n      let realmGenerator = realm.generator;\n      if (realmGenerator !== undefined) realmGenerator.emitBindingAssignment(binding, value);\n      binding.value = realm.intrinsics.undefined;\n    }\n  }\n}\n\n// ECMA262 8.1.1\nexport class EnvironmentRecord {\n  realm: Realm;\n  isReadOnly: boolean;\n  $NewTarget: void | ObjectValue;\n  id: number;\n\n  static nextId: number = 0;\n\n  constructor(realm: Realm) {\n    invariant(realm, \"expected realm\");\n    this.realm = realm;\n    this.isReadOnly = false;\n    this.id = EnvironmentRecord.nextId++;\n  }\n\n  HasBinding(N: string): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  CreateMutableBinding(N: string, D: boolean, isGlobal?: boolean): Value {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  CreateImmutableBinding(N: string, S: boolean, isGlobal?: boolean, skipRecord?: boolean): Value {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  InitializeBinding(N: string, V: Value, skipRecord?: boolean): Value {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  SetMutableBinding(N: string, V: Value, S: boolean): Value {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  GetBindingValue(N: string, S: boolean): Value {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  DeleteBinding(N: string): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  HasThisBinding(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  GetThisBinding(): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  HasSuperBinding(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  WithBaseObject(): Value {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  BindThisValue(\n    V: NullValue | ObjectValue | AbstractObjectValue | UndefinedValue\n  ): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    invariant(false, \"abstract method; please override\");\n  }\n}\n\nexport type Binding = {\n  value?: Value,\n  initialized?: boolean,\n  mutable?: boolean,\n  deletable?: boolean,\n  strict?: boolean,\n  // back-references to the environment containing the binding and the key\n  // used to access this binding\n  environment: EnvironmentRecord,\n  name: string,\n  isGlobal: boolean,\n  // bindings that are assigned to inside loops with abstract termination conditions need temporal locations\n  phiNode?: AbstractValue,\n  hasLeaked: boolean,\n};\n\n// ECMA262 8.1.1.1\nexport class DeclarativeEnvironmentRecord extends EnvironmentRecord {\n  constructor(realm: Realm) {\n    super(realm);\n    this.bindings = (Object.create(null): any);\n    this.frozen = false;\n  }\n\n  bindings: { [name: string]: Binding };\n  // Frozen Records cannot have bindings created or deleted but can have bindings updated\n  frozen: boolean;\n\n  // ECMA262 8.1.1.1.1\n  HasBinding(N: string): boolean {\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If envRec has a binding for the name that is the value of N, return true.\n    if (envRec.bindings[N]) return true;\n\n    // 3. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.1.2\n  CreateMutableBinding(N: string, D: boolean, isGlobal: boolean = false): Value {\n    invariant(!this.frozen);\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec does not already have a binding for N.\n    invariant(!envRec.bindings[N], `shouldn't have the binding ${N}`);\n\n    // 3. Create a mutable binding in envRec for N and record that it is uninitialized. If D is true, record that the newly created binding may be deleted by a subsequent DeleteBinding call.\n    this.bindings[N] = realm.recordModifiedBinding({\n      initialized: false,\n      mutable: true,\n      deletable: D,\n      environment: envRec,\n      name: N,\n      isGlobal: isGlobal,\n      hasLeaked: false,\n    });\n\n    // 4. Return NormalCompletion(empty).\n    return realm.intrinsics.undefined;\n  }\n\n  // ECMA262 8.1.1.1.3\n  CreateImmutableBinding(N: string, S: boolean, isGlobal: boolean = false, skipRecord: boolean = false): Value {\n    invariant(!this.frozen);\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec does not already have a binding for N.\n    invariant(!envRec.bindings[N], `shouldn't have the binding ${N}`);\n\n    // 3. Create an immutable binding in envRec for N and record that it is uninitialized. If S is true, record that the newly created binding is a strict binding.\n    let binding = {\n      initialized: false,\n      strict: S,\n      deletable: false,\n      environment: envRec,\n      name: N,\n      isGlobal: isGlobal,\n      hasLeaked: false,\n    };\n    this.bindings[N] = skipRecord ? binding : realm.recordModifiedBinding(binding);\n\n    // 4. Return NormalCompletion(empty).\n    return realm.intrinsics.undefined;\n  }\n\n  // ECMA262 8.1.1.1.4\n  InitializeBinding(N: string, V: Value, skipRecord: boolean = false): Value {\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    let binding = envRec.bindings[N];\n\n    // 2. Assert: envRec must have an uninitialized binding for N.\n    invariant(binding && !binding.initialized, `shouldn't have the binding ${N}`);\n\n    // 3. Set the bound value for N in envRec to V.\n    if (!skipRecord) this.realm.recordModifiedBinding(binding, V).value = V;\n    else binding.value = V;\n\n    // 4. Record that the binding for N in envRec has been initialized.\n    binding.initialized = true;\n\n    // 5. Return NormalCompletion(empty).\n    return this.realm.intrinsics.empty;\n  }\n\n  // ECMA262 8.1.1.1.5\n  SetMutableBinding(N: string, V: Value, S: boolean): Value {\n    // We can mutate frozen bindings because of captured bindings.\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    let binding = envRec.bindings[N];\n\n    // 2. If envRec does not have a binding for N, then\n    if (!binding) {\n      // a. If S is true, throw a ReferenceError exception.\n      if (S) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError, `${N} not found`);\n      }\n\n      // b. Perform envRec.CreateMutableBinding(N, true).\n      envRec.CreateMutableBinding(N, true);\n\n      // c. Perform envRec.InitializeBinding(N, V).\n      envRec.InitializeBinding(N, V);\n\n      // d. Return NormalCompletion(empty).\n      return this.realm.intrinsics.empty;\n    }\n\n    // 3. If the binding for N in envRec is a strict binding, let S be true.\n    if (binding.strict) S = true;\n\n    // 4. If the binding for N in envRec has not yet been initialized, throw a ReferenceError exception.\n    if (!binding.initialized) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError, `${N} has not yet been initialized`);\n    } else if (binding.mutable) {\n      // 5. Else if the binding for N in envRec is a mutable binding, change its bound value to V.\n      if (binding.hasLeaked) {\n        Havoc.value(realm, V);\n        invariant(realm.generator);\n        realm.generator.emitBindingAssignment(binding, V);\n      } else {\n        realm.recordModifiedBinding(binding, V).value = V;\n      }\n    } else {\n      // 6. Else,\n      // a. Assert: This is an attempt to change the value of an immutable binding.\n\n      // b. If S is true, throw a TypeError exception.\n      if (S) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"attempt to change immutable binding\");\n      }\n    }\n\n    // 7. Return NormalCompletion(empty).\n    return this.realm.intrinsics.empty;\n  }\n\n  // ECMA262 8.1.1.1.6\n  GetBindingValue(N: string, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    let binding = envRec.bindings[N];\n\n    // 2. Assert: envRec has a binding for N.\n    invariant(binding, \"expected binding\");\n\n    // 3. If the binding for N in envRec is an uninitialized binding, throw a ReferenceError exception.\n    if (!binding.initialized) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n    }\n\n    // 4. Return the value currently bound to N in envRec.\n    if (binding.hasLeaked) {\n      return deriveGetBinding(realm, binding);\n    }\n    invariant(binding.value);\n    return binding.value;\n  }\n\n  // ECMA262 8.1.1.1.7\n  DeleteBinding(N: string): boolean {\n    invariant(!this.frozen);\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec has a binding for the name that is the value of N.\n    invariant(envRec.bindings[N], \"expected binding to exist\");\n\n    // 3. If the binding for N in envRec cannot be deleted, return false.\n    if (!envRec.bindings[N].deletable) return false;\n\n    // 4. Remove the binding for N from envRec.\n    this.realm.recordModifiedBinding(envRec.bindings[N]).value = undefined;\n    delete envRec.bindings[N];\n\n    // 5. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.1.8\n  HasThisBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.1.9\n  HasSuperBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.1.10\n  WithBaseObject(): Value {\n    // 1. Return undefined.\n    return this.realm.intrinsics.undefined;\n  }\n}\n\n// ECMA262 8.1.1.2\nexport class ObjectEnvironmentRecord extends EnvironmentRecord {\n  object: ObjectValue | AbstractObjectValue;\n  withEnvironment: boolean;\n\n  constructor(realm: Realm, obj: ObjectValue | AbstractObjectValue) {\n    super(realm);\n    this.object = obj;\n  }\n\n  // ECMA262 8.1.1.2.1\n  HasBinding(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = this.object;\n\n    // 3. Let foundBinding be ? HasProperty(bindings, N).\n    let foundBinding = HasProperty(realm, bindings, N);\n\n    // 4. If foundBinding is false, return false.\n    if (!foundBinding) return false;\n\n    // 5. If the withEnvironment flag of envRec is false, return true.\n    if (!envRec.withEnvironment) return true;\n\n    // 6. Let unscopables be ? Get(bindings, @@unscopables).\n    let unscopables = Get(realm, bindings, realm.intrinsics.SymbolUnscopables);\n\n    // 7. If Type(unscopables) is Object, then\n    if (unscopables instanceof ObjectValue || unscopables instanceof AbstractObjectValue) {\n      // a. Let blocked be ToBoolean(? Get(unscopables, N)).\n      let blocked = To.ToBooleanPartial(realm, Get(realm, unscopables, N));\n\n      // b. If blocked is true, return false.\n      if (blocked) return false;\n    }\n    unscopables.throwIfNotConcrete();\n\n    // 8. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.2.2\n  CreateMutableBinding(N: string, D: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. If D is true, let configValue be true; otherwise let configValue be false.\n    let configValue = D ? true : false;\n\n    // 4. Return ? DefinePropertyOrThrow(bindings, N, PropertyDescriptor{[[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: configValue}).\n    return new BooleanValue(\n      realm,\n      Properties.DefinePropertyOrThrow(realm, bindings, N, {\n        value: realm.intrinsics.undefined,\n        writable: true,\n        enumerable: true,\n        configurable: configValue,\n      })\n    );\n  }\n\n  // ECMA262 8.1.1.2.3\n  CreateImmutableBinding(N: string, S: boolean): Value {\n    // The concrete Environment Record method CreateImmutableBinding is never used within this specification in association with object Environment Records.\n    invariant(false);\n  }\n\n  // ECMA262 8.1.1.2.4\n  InitializeBinding(N: string, V: Value): Value {\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec must have an uninitialized binding for N.\n    // 3. Record that the binding for N in envRec has been initialized.\n\n    // 4. Return ? envRec.SetMutableBinding(N, V, false).\n    return envRec.SetMutableBinding(N, V, false);\n  }\n\n  // ECMA262 8.1.1.2.5\n  SetMutableBinding(N: string, V: Value, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. Return ? Set(bindings, N, V, S).\n    return new BooleanValue(realm, Properties.Set(realm, bindings, N, V, S));\n  }\n\n  // ECMA262 8.1.1.2.6\n  GetBindingValue(N: string, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. Let value be ? HasProperty(bindings, N).\n    let value = HasProperty(realm, bindings, N);\n\n    // 4. If value is false, then\n    if (!value) {\n      // a. If S is false, return the value undefined; otherwise throw a ReferenceError exception.\n      if (!S) {\n        return realm.intrinsics.undefined;\n      } else {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n      }\n    }\n\n    // 5. Return ? Get(bindings, N).\n    return Get(realm, bindings, N);\n  }\n\n  // ECMA262 8.1.1.2.7\n  DeleteBinding(N: string): boolean {\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. Return ? bindings.[[Delete]](N).\n    return bindings.$Delete(N);\n  }\n\n  // ECMA262 8.1.1.2.8\n  HasThisBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.2.9\n  HasSuperBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.2.10\n  WithBaseObject(): Value {\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If the withEnvironment flag of envRec is true, return the binding object for envRec.\n    if (envRec.withEnvironment) return envRec.object;\n\n    // 3. Otherwise, return undefined.\n    return this.realm.intrinsics.undefined;\n  }\n}\n\n// ECMA262 8.1.1.3\nexport class FunctionEnvironmentRecord extends DeclarativeEnvironmentRecord {\n  $ThisBindingStatus: \"lexical\" | \"initialized\" | \"uninitialized\";\n  $ThisValue: UndefinedValue | NullValue | ObjectValue | AbstractObjectValue;\n  $HomeObject: void | ObjectValue;\n  $FunctionObject: FunctionValue;\n\n  // ECMA262 8.1.1.3.1\n  BindThisValue(\n    V: NullValue | ObjectValue | AbstractObjectValue | UndefinedValue\n  ): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    let realm = this.realm;\n\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec.[[ThisBindingStatus]] is not \"lexical\".\n    invariant(envRec.$ThisBindingStatus !== \"lexical\", \"this binding status shouldn't be lexical\");\n\n    // 3. If envRec.[[ThisBindingStatus]] is \"initialized\", throw a ReferenceError exception.\n    if (envRec.$ThisBindingStatus === \"initialized\") {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n    }\n\n    // 4. Set envRec.[[ThisValue]] to V.\n    envRec.$ThisValue = V;\n\n    // 5. Set envRec.[[ThisBindingStatus]] to \"initialized\".\n    envRec.$ThisBindingStatus = \"initialized\";\n\n    // 6. Return V.\n    return V;\n  }\n\n  // ECMA262 8.1.1.3.2\n  HasThisBinding(): boolean {\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If envRec.[[ThisBindingStatus]] is \"lexical\", return false; otherwise, return true.\n    return envRec.$ThisBindingStatus === \"lexical\" ? false : true;\n  }\n\n  // ECMA262 8.1.1.3.3\n  HasSuperBinding(): boolean {\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If envRec.[[ThisBindingStatus]] is \"lexical\", return false.\n    if (envRec.$ThisBindingStatus === \"lexical\") return false;\n\n    // 3. If envRec.[[HomeObject]] has the value undefined, return false; otherwise, return true.\n    if (envRec.$HomeObject === undefined) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  // ECMA262 8.1.1.3.4\n  GetThisBinding(): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    let realm = this.realm;\n\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec.[[ThisBindingStatus]] is not \"lexical\".\n    invariant(envRec.$ThisBindingStatus !== \"lexical\", \"this binding status shouldn't be lexical\");\n\n    // 3. If envRec.[[ThisBindingStatus]] is \"uninitialized\", throw a ReferenceError exception.\n    if (envRec.$ThisBindingStatus === \"uninitialized\") {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n    }\n\n    // 4. Return envRec.[[ThisValue]].\n    return envRec.$ThisValue;\n  }\n\n  // ECMA262 8.1.1.3.5\n  GetSuperBase(): ObjectValue | AbstractObjectValue | NullValue | UndefinedValue {\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let home be the value of envRec.[[HomeObject]].\n    let home = envRec.$HomeObject;\n\n    // 3. If home has the value undefined, return undefined.\n    if (home === undefined) return this.realm.intrinsics.undefined;\n\n    // 4. Assert: Type(home) is Object.\n    invariant(home instanceof ObjectValue, \"expected object value\");\n\n    // 5. Return ? home.[[GetPrototypeOf]]().\n    return home.$GetPrototypeOf();\n  }\n}\n\n// ECMA262 8.1.1.4\nexport class GlobalEnvironmentRecord extends EnvironmentRecord {\n  $DeclarativeRecord: EnvironmentRecord;\n  $ObjectRecord: ObjectEnvironmentRecord;\n  $VarNames: Array<string>;\n  $GlobalThisValue: ObjectValue;\n\n  // ECMA262 8.1.1.4.1\n  HasBinding(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, return true.\n    if (DclRec.HasBinding(N)) return true;\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Return ? ObjRec.HasBinding(N).\n    return ObjRec.HasBinding(N);\n  }\n\n  // ECMA262 8.1.1.4.2\n  CreateMutableBinding(N: string, D: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, throw a TypeError exception.\n    if (DclRec.HasBinding(N)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Return DclRec.CreateMutableBinding(N, D).\n    return DclRec.CreateMutableBinding(N, D, true);\n  }\n\n  // ECMA262 8.1.1.4.3\n  CreateImmutableBinding(N: string, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, throw a TypeError exception.\n    if (DclRec.HasBinding(N)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Return DclRec.CreateImmutableBinding(N, S).\n    return DclRec.CreateImmutableBinding(N, S, true);\n  }\n\n  // ECMA262 8.1.1.4.4\n  InitializeBinding(N: string, V: Value): Value {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.InitializeBinding(N, V).\n      return DclRec.InitializeBinding(N, V);\n    }\n\n    // 4. Assert: If the binding exists, it must be in the object Environment Record.\n\n    // 5. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 6. Return ? ObjRec.InitializeBinding(N, V).\n    return ObjRec.InitializeBinding(N, V);\n  }\n\n  // ECMA262 8.1.1.4.5\n  SetMutableBinding(N: string, V: Value, S: boolean): Value {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.SetMutableBinding(N, V, S).\n      return DclRec.SetMutableBinding(N, V, S);\n    }\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Return ? ObjRec.SetMutableBinding(N, V, S).\n    return ObjRec.SetMutableBinding(N, V, S);\n  }\n\n  // ECMA262 8.1.1.4.6\n  GetBindingValue(N: string, S: boolean): Value {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.GetBindingValue(N, S).\n      return DclRec.GetBindingValue(N, S);\n    }\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Return ? ObjRec.GetBindingValue(N, S).\n    return ObjRec.GetBindingValue(N, S);\n  }\n\n  // ECMA262 8.1.1.4.7\n  DeleteBinding(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.DeleteBinding(N).\n      return DclRec.DeleteBinding(N);\n    }\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 6. Let existingProp be ? HasOwnProperty(globalObject, N).\n    let existingProp = HasOwnProperty(realm, globalObject, N);\n\n    // 7. If existingProp is true, then\n    if (existingProp) {\n      // a. Let status be ? ObjRec.DeleteBinding(N).\n      let status = ObjRec.DeleteBinding(N);\n\n      // b. If status is true, then\n      if (status) {\n        // i. Let varNames be envRec.[[VarNames]].\n        let varNames = envRec.$VarNames;\n\n        // ii. If N is an element of varNames, remove that element from the varNames.\n        if (varNames.indexOf(N) >= 0) {\n          varNames.splice(varNames.indexOf(N), 1);\n        }\n      }\n\n      // c. Return status.\n      return status;\n    }\n\n    // 8. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.8\n  HasThisBinding(): boolean {\n    // 1. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.9\n  HasSuperBinding(): boolean {\n    // 1. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.10\n  WithBaseObject(): Value {\n    // 1. Return undefined.\n    return this.realm.intrinsics.undefined;\n  }\n\n  // ECMA262 8.1.1.4.11\n  GetThisBinding(): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    invariant(envRec.$GlobalThisValue);\n    // 2. Return envRec.[[GlobalThisValue]].\n    return envRec.$GlobalThisValue;\n  }\n\n  // ECMA262 8.1.1.4.12\n  HasVarDeclaration(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let varDeclaredNames be envRec.[[VarNames]].\n    let varDeclaredNames = envRec.$VarNames;\n\n    // 3. If varDeclaredNames contains the value of N, return true.\n    if (varDeclaredNames.indexOf(N) >= 0) return true;\n\n    // 4. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.4.13\n  HasLexicalDeclaration(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. Return DclRec.HasBinding(N).\n    return DclRec.HasBinding(N);\n  }\n\n  // ECMA262 8.1.1.4.14\n  HasRestrictedGlobalProperty(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).\n    let existingProp = globalObject.$GetOwnProperty(N);\n\n    // 5. If existingProp is undefined, return false.\n    if (!existingProp) return false;\n    Properties.ThrowIfMightHaveBeenDeleted(existingProp.value);\n\n    // 6. If existingProp.[[Configurable]] is true, return false.\n    if (existingProp.configurable) return false;\n\n    // 7. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.15\n  CanDeclareGlobalVar(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let hasProperty be ? HasOwnProperty(globalObject, N).\n    let hasProperty = HasOwnProperty(realm, globalObject, N);\n\n    // 5. If hasProperty is true, return true.\n    if (hasProperty) return true;\n\n    // 6. Return ? IsExtensible(globalObject).\n    return IsExtensible(realm, globalObject);\n  }\n\n  // ECMA262 8.1.1.4.16\n  CanDeclareGlobalFunction(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).\n    let existingProp = globalObject.$GetOwnProperty(N);\n\n    // 5. If existingProp is undefined, return ? IsExtensible(globalObject).\n    if (!existingProp) return IsExtensible(realm, globalObject);\n    Properties.ThrowIfMightHaveBeenDeleted(existingProp.value);\n\n    // 6. If existingProp.[[Configurable]] is true, return true.\n    if (existingProp.configurable) return true;\n\n    // 7. If IsDataDescriptor(existingProp) is true and existingProp has attribute values {[[Writable]]: true, [[Enumerable]]: true}, return true.\n    if (IsDataDescriptor(realm, existingProp) && existingProp.writable && existingProp.enumerable) {\n      return true;\n    }\n\n    // 8. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.4.17\n  CreateGlobalVarBinding(N: string, D: boolean) {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let hasProperty be ? HasOwnProperty(globalObject, N).\n    let hasProperty = HasOwnProperty(realm, globalObject, N);\n\n    // 5. Let extensible be ? IsExtensible(globalObject).\n    let extensible = IsExtensible(realm, globalObject);\n\n    // 6. If hasProperty is false and extensible is true, then\n    if (!hasProperty && extensible) {\n      // a. Perform ? ObjRec.CreateMutableBinding(N, D).\n      ObjRec.CreateMutableBinding(N, D);\n\n      // b. Perform ? ObjRec.InitializeBinding(N, undefined).\n      ObjRec.InitializeBinding(N, this.realm.intrinsics.undefined);\n    }\n\n    // 7. Let varDeclaredNames be envRec.[[VarNames]].\n    let varDeclaredNames = envRec.$VarNames;\n\n    // 8. If varDeclaredNames does not contain the value of N, then\n    if (varDeclaredNames.indexOf(N) < 0) {\n      // a. Append N to varDeclaredNames.\n      varDeclaredNames.push(N);\n    }\n\n    // 9. Return NormalCompletion(empty).\n  }\n\n  // ECMA262 8.1.1.4.18\n  CreateGlobalFunctionBinding(N: string, V: Value, D: boolean) {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).\n    let existingProp = globalObject.$GetOwnProperty(N);\n\n    // 5. If existingProp is undefined or existingProp.[[Configurable]] is true, then\n    let desc;\n    if (!existingProp || existingProp.configurable) {\n      // a. Let desc be the PropertyDescriptor{[[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: D}.\n      desc = { value: V, writable: true, enumerable: true, configurable: D };\n    } else {\n      // 6. Else,\n      Properties.ThrowIfMightHaveBeenDeleted(existingProp.value);\n      // a. Let desc be the PropertyDescriptor{[[Value]]: V }.\n      desc = { value: V };\n    }\n\n    // 7. Perform ? DefinePropertyOrThrow(globalObject, N, desc).\n    Properties.DefinePropertyOrThrow(this.realm, globalObject, N, desc);\n\n    // 8. Record that the binding for N in ObjRec has been initialized.\n\n    // 9. Perform ? Set(globalObject, N, V, false).\n    Properties.Set(this.realm, globalObject, N, V, false);\n\n    // 10. Let varDeclaredNames be envRec.[[VarNames]].\n    let varDeclaredNames = envRec.$VarNames;\n\n    // 11. If varDeclaredNames does not contain the value of N, then\n    if (varDeclaredNames.indexOf(N) < 0) {\n      // a. Append N to varDeclaredNames.\n      varDeclaredNames.push(N);\n    }\n\n    // 12. Return NormalCompletion(empty).\n  }\n}\n\n// ECMA262 8.1\nlet uid = 0;\nexport class LexicalEnvironment {\n  constructor(realm: Realm) {\n    invariant(realm, \"expected realm\");\n    this.realm = realm;\n    this.destroyed = false;\n    this._uid = uid++;\n  }\n\n  // For debugging it is convenient to have an ID for each of these.\n  _uid: number;\n  destroyed: boolean;\n  environmentRecord: EnvironmentRecord;\n  parent: null | LexicalEnvironment;\n  realm: Realm;\n\n  destroy() {\n    this.destroyed = true;\n    // Once the containing environment is destroyed, we can no longer add or remove entries from the environmentRecord\n    // (but we can update existing values).\n    if (this.environmentRecord instanceof DeclarativeEnvironmentRecord) {\n      this.environmentRecord.frozen = true;\n    }\n  }\n\n  assignToGlobal(globalAst: BabelNodeLVal, rvalue: Value) {\n    let globalValue = this.evaluate(globalAst, false);\n    Properties.PutValue(this.realm, globalValue, rvalue);\n  }\n\n  partiallyEvaluateCompletionDeref(\n    ast: BabelNode,\n    strictCode: boolean,\n    metadata?: any\n  ): [Completion | Value, BabelNode, Array<BabelNodeStatement>] {\n    let [result, partial_ast, partial_io] = this.partiallyEvaluateCompletion(ast, strictCode, metadata);\n    if (result instanceof Reference) {\n      result = Environment.GetValue(this.realm, result);\n    }\n    return [result, partial_ast, partial_io];\n  }\n\n  partiallyEvaluateCompletion(\n    ast: BabelNode,\n    strictCode: boolean,\n    metadata?: any\n  ): [Completion | Reference | Value, BabelNode, Array<BabelNodeStatement>] {\n    try {\n      return this.partiallyEvaluate(ast, strictCode, metadata);\n    } catch (err) {\n      if (err instanceof Completion) return [err, ast, []];\n      if (err instanceof Error)\n        // rethrowing Error should preserve stack trace\n        throw err;\n      // let's wrap into a proper Error to create stack trace\n      throw new FatalError(err);\n    }\n  }\n\n  evaluateCompletionDeref(ast: BabelNode, strictCode: boolean, metadata?: any): AbruptCompletion | Value {\n    let result = this.evaluateCompletion(ast, strictCode, metadata);\n    if (result instanceof Reference) result = Environment.GetValue(this.realm, result);\n    return result;\n  }\n\n  evaluateCompletion(ast: BabelNode, strictCode: boolean, metadata?: any): AbruptCompletion | Value | Reference {\n    try {\n      return this.evaluate(ast, strictCode, metadata);\n    } catch (err) {\n      if (\n        (err instanceof JoinedAbruptCompletions || err instanceof PossiblyNormalCompletion) &&\n        err.containsBreakOrContinue()\n      ) {\n        AbstractValue.reportIntrospectionError(err.joinCondition);\n        throw new FatalError();\n      }\n      if (err instanceof AbruptCompletion) return err;\n      if (err instanceof Error)\n        // rethrowing Error should preserve stack trace\n        throw err;\n      // let's wrap into a proper Error to create stack trace\n      throw new FatalError(err);\n    }\n  }\n\n  evaluateAbstractCompletion(ast: BabelNode, strictCode: boolean, metadata?: any): Completion | Value | Reference {\n    try {\n      return this.evaluateAbstract(ast, strictCode, metadata);\n    } catch (err) {\n      if (err instanceof Completion) return err;\n      if (err instanceof Error)\n        // rethrowing Error should preserve stack trace\n        throw err;\n      // let's wrap into a proper Error to create stack trace\n      if (err instanceof Object) throw new FatalError(err.constructor.name + \": \" + err);\n      throw new FatalError(err);\n    }\n  }\n\n  concatenateAndParse(\n    sources: Array<SourceFile>,\n    sourceType: SourceType = \"script\"\n  ): [BabelNodeFile, { [string]: string }] {\n    let asts = [];\n    let code = {};\n    let directives = [];\n    for (let source of sources) {\n      try {\n        let node = this.realm.statistics.parsing.measure(() =>\n          parse(this.realm, source.fileContents, source.filePath, sourceType)\n        );\n\n        let sourceMapContents = source.sourceMapContents;\n        if (sourceMapContents && sourceMapContents.length > 0) {\n          this.realm.statistics.fixupSourceLocations.measure(() =>\n            this.fixup_source_locations(node, sourceMapContents)\n          );\n        }\n\n        this.realm.statistics.fixupFilenames.measure(() => this.fixup_filenames(node));\n\n        asts = asts.concat(node.program.body);\n        code[source.filePath] = source.fileContents;\n        directives = directives.concat(node.program.directives);\n      } catch (e) {\n        if (e instanceof ThrowCompletion) {\n          let error = e.value;\n          if (error instanceof ObjectValue) {\n            let message = error._SafeGetDataPropertyValue(\"message\");\n            if (message instanceof StringValue) {\n              message.value = `Syntax error: ${message.value}`;\n              e.location.source = source.filePath;\n              // the position was not located properly on the\n              // syntax errors happen on one given position, so start position = end position\n              e.location.start = { line: e.location.line, column: e.location.column };\n              e.location.end = { line: e.location.line, column: e.location.column };\n              let diagnostic = new CompilerDiagnostic(message.value, e.location, \"PP1004\", \"FatalError\");\n              this.realm.handleError(diagnostic);\n              throw new FatalError(message.value);\n            }\n          }\n        }\n        throw e;\n      }\n    }\n    return [t.file(t.program(asts, directives)), code];\n  }\n\n  executeSources(\n    sources: Array<SourceFile>,\n    sourceType: SourceType = \"script\",\n    onParse: void | (BabelNodeFile => void) = undefined\n  ): [AbruptCompletion | Value, { [string]: string }] {\n    let context = new ExecutionContext();\n    context.lexicalEnvironment = this;\n    context.variableEnvironment = this;\n    context.realm = this.realm;\n    this.realm.pushContext(context);\n    let res, code;\n    try {\n      let ast;\n      [ast, code] = this.concatenateAndParse(sources, sourceType);\n      if (onParse) onParse(ast);\n      res = this.realm.statistics.evaluation.measure(() => this.evaluateCompletion(ast, false));\n    } finally {\n      this.realm.popContext(context);\n      this.realm.onDestroyScope(context.lexicalEnvironment);\n      if (!this.destroyed) this.realm.onDestroyScope(this);\n      invariant(\n        this.realm.activeLexicalEnvironments.size === 0,\n        `expected 0 active lexical environments, got ${this.realm.activeLexicalEnvironments.size}`\n      );\n    }\n    if (res instanceof AbruptCompletion) return [res, code];\n\n    return [Environment.GetValue(this.realm, res), code];\n  }\n\n  executePartialEvaluator(\n    sources: Array<SourceFile>,\n    options: PartialEvaluatorOptions = defaultOptions,\n    sourceType: SourceType = \"script\"\n  ): AbruptCompletion | { code: string, map?: SourceMap } {\n    let [ast, code] = this.concatenateAndParse(sources, sourceType);\n    let context = new ExecutionContext();\n    context.lexicalEnvironment = this;\n    context.variableEnvironment = this;\n    context.realm = this.realm;\n    this.realm.pushContext(context);\n    let partialAST;\n    try {\n      [, partialAST] = this.partiallyEvaluateCompletionDeref(ast, false);\n    } finally {\n      this.realm.popContext(context);\n      this.realm.onDestroyScope(context.lexicalEnvironment);\n      if (!this.destroyed) this.realm.onDestroyScope(this);\n      invariant(\n        this.realm.activeLexicalEnvironments.size === 0,\n        `expected 0 active lexical environments, got ${this.realm.activeLexicalEnvironments.size}`\n      );\n    }\n    invariant(partialAST.type === \"File\");\n    let fileAst = ((partialAST: any): BabelNodeFile);\n    let prog = t.program(fileAst.program.body, ast.program.directives);\n    this.fixup_filenames(prog);\n    // The type signature for generate is not complete, hence the any\n    return generate(prog, { sourceMaps: options.sourceMaps }, (code: any));\n  }\n\n  execute(\n    code: string,\n    filename: string,\n    map: string = \"\",\n    sourceType: SourceType = \"script\",\n    onParse: void | (BabelNodeFile => void) = undefined\n  ): AbruptCompletion | Value {\n    let context = new ExecutionContext();\n    context.lexicalEnvironment = this;\n    context.variableEnvironment = this;\n    context.realm = this.realm;\n\n    this.realm.pushContext(context);\n\n    let ast, res;\n    try {\n      try {\n        ast = parse(this.realm, code, filename, sourceType);\n      } catch (e) {\n        if (e instanceof ThrowCompletion) return e;\n        throw e;\n      }\n      if (onParse) onParse(ast);\n      if (map.length > 0) this.fixup_source_locations(ast, map);\n      this.fixup_filenames(ast);\n      res = this.evaluateCompletion(ast, false);\n    } finally {\n      this.realm.popContext(context);\n      // Avoid destroying \"this\" scope as execute may be called many times.\n      if (context.lexicalEnvironment !== this) this.realm.onDestroyScope(context.lexicalEnvironment);\n      invariant(\n        this.realm.activeLexicalEnvironments.size === 1,\n        `expected 1 active lexical environment, got ${this.realm.activeLexicalEnvironments.size}`\n      );\n    }\n    if (res instanceof AbruptCompletion) return res;\n\n    return Environment.GetValue(this.realm, res);\n  }\n\n  fixup_source_locations(ast: BabelNode, map: string) {\n    const smc = new sourceMap.SourceMapConsumer(map);\n    traverseFast(ast, node => {\n      let loc = node.loc;\n      if (!loc) return false;\n      fixup(loc, loc.start);\n      fixup(loc, loc.end);\n      fixup_comments(node.leadingComments);\n      fixup_comments(node.innerComments);\n      fixup_comments(node.trailingComments);\n      return false;\n\n      function fixup(new_loc: BabelNodeSourceLocation, new_pos: BabelNodePosition) {\n        let old_pos = smc.originalPositionFor({ line: new_pos.line, column: new_pos.column });\n        if (old_pos.source === null) return;\n        new_pos.line = old_pos.line;\n        new_pos.column = old_pos.column;\n        new_loc.source = old_pos.source;\n      }\n\n      function fixup_comments(comments: ?Array<BabelNodeComment>) {\n        if (!comments) return;\n        for (let c of comments) {\n          let cloc = c.loc;\n          if (!cloc) continue;\n          fixup(cloc, cloc.start);\n          fixup(cloc, cloc.end);\n        }\n      }\n    });\n  }\n\n  fixup_filenames(ast: BabelNode) {\n    traverseFast(ast, node => {\n      let loc = node.loc;\n      if (!loc || !loc.source) {\n        node.leadingComments = null;\n        node.innerComments = null;\n        node.trailingComments = null;\n        node.loc = null;\n      } else {\n        let filename = loc.source;\n        (loc: any).filename = filename;\n        fixup_comments(node.leadingComments, filename);\n        fixup_comments(node.innerComments, filename);\n        fixup_comments(node.trailingComments, filename);\n      }\n      return false;\n\n      function fixup_comments(comments: ?Array<BabelNodeComment>, filename: string) {\n        if (!comments) return;\n        for (let c of comments) {\n          if (c.loc) {\n            (c.loc: any).filename = filename;\n            c.loc.source = filename;\n          }\n        }\n      }\n    });\n  }\n\n  evaluate(ast: BabelNode, strictCode: boolean, metadata?: any): Value | Reference {\n    if (this.realm.debuggerInstance) {\n      this.realm.debuggerInstance.checkForActions(ast);\n    }\n    let res = this.evaluateAbstract(ast, strictCode, metadata);\n    invariant(res instanceof Value || res instanceof Reference, ast.type);\n    return res;\n  }\n\n  evaluateAbstract(ast: BabelNode, strictCode: boolean, metadata?: any): Value | Reference {\n    this.realm.currentLocation = ast.loc;\n    this.realm.testTimeout();\n\n    let evaluator = this.realm.evaluators[(ast.type: string)];\n    if (evaluator) {\n      this.realm.statistics.evaluatedNodes++;\n      let result = evaluator(ast, strictCode, this, this.realm, metadata);\n      return result;\n    }\n\n    throw new TypeError(`Unsupported node type ${ast.type}`);\n  }\n\n  evaluateDeref(ast: BabelNode, strictCode: boolean, metadata?: any): Value {\n    let result = this.evaluate(ast, strictCode, metadata);\n    if (result instanceof Reference) result = Environment.GetValue(this.realm, result);\n    return result;\n  }\n\n  partiallyEvaluate(\n    ast: BabelNode,\n    strictCode: boolean,\n    metadata?: any\n  ): [Completion | Reference | Value, BabelNode, Array<BabelNodeStatement>] {\n    let partialEvaluator = this.realm.partialEvaluators[(ast.type: string)];\n    if (partialEvaluator) {\n      return partialEvaluator(ast, strictCode, this, this.realm, metadata);\n    }\n\n    let err = new TypeError(`Unsupported node type ${ast.type}`);\n    throw err;\n  }\n}\n\n// ECMA262 6.2.3\n// A Reference is a resolved name or property binding. A Reference consists of three components, the base value,\n// the referenced name and the Boolean valued strict reference flag. The base value is either undefined, an Object,\n// a Boolean, a String, a Symbol, a Number, or an Environment Record. A base value of undefined indicates that the\n// Reference could not be resolved to a binding. The referenced name is a String or Symbol value.\nexport type BaseValue =\n  | void\n  | ObjectValue\n  | BooleanValue\n  | StringValue\n  | SymbolValue\n  | NumberValue\n  | IntegralValue\n  | EnvironmentRecord;\nexport type ReferenceName = string | SymbolValue;\n\nexport function mightBecomeAnObject(base: Value): boolean {\n  let type = base.getType();\n  // The top Value type might be able to become an object. We let it\n  // pass and error later if it can't.\n  return (\n    type === Value ||\n    type === PrimitiveValue ||\n    type === BooleanValue ||\n    type === StringValue ||\n    type === SymbolValue ||\n    type === NumberValue ||\n    type === IntegralValue\n  );\n}\n\nexport class Reference {\n  base: BaseValue | AbstractValue;\n  referencedName: ReferenceName | AbstractValue;\n  strict: boolean;\n  thisValue: void | Value;\n\n  constructor(\n    base: BaseValue | AbstractValue,\n    refName: ReferenceName | AbstractValue,\n    strict: boolean,\n    thisValue?: void | Value\n  ) {\n    invariant(\n      base instanceof AbstractObjectValue ||\n        base === undefined ||\n        base instanceof ObjectValue ||\n        base instanceof EnvironmentRecord ||\n        mightBecomeAnObject(base)\n    );\n    this.base = base;\n    this.referencedName = refName;\n    invariant(\n      !(refName instanceof AbstractValue) ||\n        !(refName.mightNotBeString() && refName.mightNotBeNumber() && !refName.isSimpleObject()) ||\n        refName.$Realm.isInPureScope()\n    );\n    this.strict = strict;\n    this.thisValue = thisValue;\n    invariant(thisValue === undefined || !(base instanceof EnvironmentRecord));\n  }\n}\n"]}