{"version":3,"sources":["../../src/evaluators/SwitchStatement.js"],"names":["ast","strictCode","env","realm","labelSet","expression","discriminant","exprRef","evaluate","switchValue","GetValue","values","isTop","elems","getElements","n","size","joinedEffects","concreteSwitchValue","condition","createFromBinaryOp","effects","evaluateForEffects","withCondition","evaluationHelper","undefined","joinEffects","applyEffects","result","composeWithSavedCompletion","CaseSelectorEvaluation","AbstractCaseBlockEvaluation","cases","defaultCaseIndex","input","useAbstractInterpretation","DefiniteCaseEvaluation","caseIndex","intrinsics","length","c","i","consequent","node","r","evaluateCompletion","diagnostic","location","handleError","value","AbstractCaseEvaluation","empty","test","selector","selectionResult","implies","impliesNot","trueEffects","e","falseEffects","withInverseCondition","completion","CaseBlockEvaluation","EvaluateCase","res","EvaluateCaseClauses","A","V","found","C","clauseSelector","R","val","default_case_num","findIndex","clause","slice","foundInB","B","oldEnv","getRunningContext","lexicalEnvironment","blockEnv","NewDeclarativeEnvironment","CaseBlock","map","reduce","stmts","case_blk","concat","BlockDeclarationInstantiation","target","onDestroyScope"],"mappings":"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","file":"SwitchStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { CompilerDiagnostic, InfeasiblePathError } from \"../errors.js\";\nimport { Reference } from \"../environment.js\";\nimport { computeBinary } from \"./BinaryExpression.js\";\nimport { AbruptCompletion, BreakCompletion, PossiblyNormalCompletion, Completion } from \"../completions.js\";\nimport { InternalGetResultValue } from \"./ForOfStatement.js\";\nimport { EmptyValue, AbstractValue, Value } from \"../values/index.js\";\nimport { StrictEqualityComparisonPartial, UpdateEmpty } from \"../methods/index.js\";\nimport { Environment, Path, Join } from \"../singletons.js\";\nimport { FatalError } from \"../errors.js\";\nimport type { BabelNodeSwitchStatement, BabelNodeSwitchCase, BabelNodeExpression } from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\n// 13.12.10 Runtime Semantics: CaseSelectorEvaluation\nfunction CaseSelectorEvaluation(\n  expression: BabelNodeExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  // 1. Let exprRef be the result of evaluating Expression.\n  let exprRef = env.evaluate(expression, strictCode);\n\n  // 2. Return ? GetValue(exprRef).\n  return Environment.GetValue(realm, exprRef);\n}\n\nfunction AbstractCaseBlockEvaluation(\n  cases: Array<BabelNodeSwitchCase>,\n  defaultCaseIndex: number,\n  input: Value,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  invariant(realm.useAbstractInterpretation);\n\n  let DefiniteCaseEvaluation = (caseIndex: number): Value => {\n    let result = realm.intrinsics.undefined;\n    // we start at the case we've been asked to evaluate, and process statements\n    // until there is either a break statement or exception thrown (this means we\n    // implicitly fall through correctly in the absence of a break statement).\n    while (caseIndex < cases.length) {\n      let c = cases[caseIndex];\n      for (let i = 0; i < c.consequent.length; i += 1) {\n        let node = c.consequent[i];\n        let r = env.evaluateCompletion(node, strictCode);\n        invariant(!(r instanceof Reference));\n\n        if (r instanceof PossiblyNormalCompletion) {\n          // TODO correct handling of PossiblyNormal and AbruptCompletion\n          let diagnostic = new CompilerDiagnostic(\n            \"case block containing a throw, return or continue is not yet supported\",\n            r.location,\n            \"PP0027\",\n            \"FatalError\"\n          );\n          realm.handleError(diagnostic);\n          throw new FatalError();\n        }\n\n        result = UpdateEmpty(realm, r, result);\n        if (result instanceof Completion) break;\n      }\n\n      if (result instanceof Completion) break;\n      caseIndex++;\n    }\n\n    if (result instanceof BreakCompletion) {\n      return result.value;\n    } else if (result instanceof AbruptCompletion) {\n      // TODO correct handling of PossiblyNormal and AbruptCompletion\n      let diagnostic = new CompilerDiagnostic(\n        \"case block containing a throw, return or continue is not yet supported\",\n        result.location,\n        \"PP0027\",\n        \"FatalError\"\n      );\n      realm.handleError(diagnostic);\n      throw new FatalError();\n    } else {\n      invariant(result instanceof Value);\n      return result;\n    }\n  };\n\n  let AbstractCaseEvaluation = (caseIndex: number): Value => {\n    if (caseIndex === defaultCaseIndex) {\n      // skip the default case until we've exhausted all other options\n      return AbstractCaseEvaluation(caseIndex + 1);\n    } else if (caseIndex >= cases.length) {\n      // this is the stop condition for our recursive search for a matching case.\n      // we tried every available case index and since nothing matches we return\n      // the default (and if none exists....just empty)\n      if (defaultCaseIndex !== -1) {\n        return DefiniteCaseEvaluation(defaultCaseIndex);\n      } else {\n        return realm.intrinsics.empty;\n      }\n    }\n    // else we have a normal in-range case index\n\n    let c = cases[caseIndex];\n    let test = c.test;\n    invariant(test);\n\n    let selector = CaseSelectorEvaluation(test, strictCode, env, realm);\n    let selectionResult = computeBinary(realm, \"===\", input, selector);\n\n    if (Path.implies(selectionResult)) {\n      //  we have a winning result for the switch case, bubble it back up!\n      return DefiniteCaseEvaluation(caseIndex);\n    } else if (Path.impliesNot(selectionResult)) {\n      // we have a case that is definitely *not* taken\n      // so we go and look at the next one in the hope of finding a match\n      return AbstractCaseEvaluation(caseIndex + 1);\n    } else {\n      // we can't be sure whether the case selector evaluates true or not\n      // so we evaluate the case in the abstract as an if-else with the else\n      // leading to the next case statement\n      let trueEffects;\n      try {\n        trueEffects = Path.withCondition(selectionResult, () => {\n          return realm.evaluateForEffects(\n            () => {\n              return DefiniteCaseEvaluation(caseIndex);\n            },\n            undefined,\n            \"AbstractCaseEvaluation/1\"\n          );\n        });\n      } catch (e) {\n        if (e instanceof InfeasiblePathError) {\n          // selectionResult cannot be true in this path, after all.\n          return AbstractCaseEvaluation(caseIndex + 1);\n        }\n        throw e;\n      }\n\n      let falseEffects;\n      try {\n        falseEffects = Path.withInverseCondition(selectionResult, () => {\n          return realm.evaluateForEffects(\n            () => {\n              return AbstractCaseEvaluation(caseIndex + 1);\n            },\n            undefined,\n            \"AbstractCaseEvaluation/2\"\n          );\n        });\n      } catch (e) {\n        if (e instanceof InfeasiblePathError) {\n          // selectionResult cannot be false in this path, after all.\n          return DefiniteCaseEvaluation(caseIndex);\n        }\n        throw e;\n      }\n\n      invariant(trueEffects !== undefined);\n      invariant(falseEffects !== undefined);\n      let joinedEffects = Join.joinEffects(realm, selectionResult, trueEffects, falseEffects);\n      let completion = joinedEffects.result;\n      if (completion instanceof PossiblyNormalCompletion) {\n        // in this case one of the branches may complete abruptly, which means that\n        // not all control flow branches join into one flow at this point.\n        // Consequently we have to continue tracking changes until the point where\n        // all the branches come together into one.\n        completion = realm.composeWithSavedCompletion(completion);\n      }\n      // Note that the effects of (non joining) abrupt branches are not included\n      // in joinedEffects, but are tracked separately inside completion.\n      realm.applyEffects(joinedEffects);\n\n      // return or throw completion\n      if (completion instanceof AbruptCompletion) throw completion;\n      invariant(completion instanceof Value);\n      return completion;\n    }\n  };\n\n  // let the recursive search for a matching case begin!\n  return AbstractCaseEvaluation(0);\n}\n\nfunction CaseBlockEvaluation(\n  cases: Array<BabelNodeSwitchCase>,\n  input: Value,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  let EvaluateCase = (c: BabelNodeSwitchCase): Value | AbruptCompletion => {\n    let r = realm.intrinsics.empty;\n    for (let node of c.consequent) {\n      let res = env.evaluateCompletion(node, strictCode);\n      if (res instanceof AbruptCompletion) return (UpdateEmpty(realm, res, r): any);\n      if (!(res instanceof EmptyValue)) r = res;\n    }\n    return r;\n  };\n\n  let EvaluateCaseClauses = (A: Array<BabelNodeSwitchCase>, V: Value): [boolean, Value] => {\n    // 2. Let A be the List of CaseClause items in CaseClauses, in source text order.\n    // A is passed in\n\n    // 3. Let found be false.\n    let found = false;\n\n    // 4. Repeat for each CaseClause C in A,\n    for (let C of A) {\n      // a. If found is false, then\n      if (!found) {\n        // i. Let clauseSelector be the result of CaseSelectorEvaluation of C.\n        let test = C.test;\n        invariant(test);\n        let clauseSelector = CaseSelectorEvaluation(test, strictCode, env, realm);\n\n        // ii. ReturnIfAbrupt(clauseSelector).\n        // above will throw a Completion which will return\n\n        // iii. Let found be the result of performing Strict Equality Comparison input === clauseSelector.[[Value]].\n        found = StrictEqualityComparisonPartial(realm, input, clauseSelector);\n      }\n      if (found) {\n        // b. If found is true, then\n        // i. Let R be the result of evaluating C.\n        let R = EvaluateCase(C);\n\n        // ii. If R.[[Value]] is not empty, let V be R.[[Value]].\n        let val = InternalGetResultValue(realm, R);\n        if (!(val instanceof EmptyValue)) V = val;\n\n        // iii. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).\n        if (R instanceof AbruptCompletion) {\n          throw UpdateEmpty(realm, R, V);\n        }\n      }\n    }\n    return [found, V];\n  };\n\n  // CaseBlock:{}\n  // 1. Return NormalCompletion(undefined).\n  if (cases.length === 0) return realm.intrinsics.undefined;\n\n  // CaseBlock:{CaseClauses DefaultClause CaseClauses}\n  let default_case_num = cases.findIndex(clause => {\n    return clause.test === null;\n  });\n\n  // Abstract interpretation of case blocks is a significantly different process\n  // from regular interpretation, so we fork off early to keep things tidily separated.\n  if (input instanceof AbstractValue) {\n    return AbstractCaseBlockEvaluation(cases, default_case_num, input, strictCode, env, realm);\n  }\n\n  if (default_case_num !== -1) {\n    // 2. Let A be the List of CaseClause items in the first CaseClauses, in source text order. If the first CaseClauses is not present, A is « ».\n    let A = cases.slice(0, default_case_num);\n\n    let V = realm.intrinsics.undefined;\n\n    // 4. Repeat for each CaseClause C in A\n    [, V] = EvaluateCaseClauses(A, V);\n\n    // 5. Let foundInB be false.\n    let foundInB = false;\n\n    // 6. Let B be the List containing the CaseClause items in the second CaseClauses, in source text order. If the second CaseClauses is not present, B is « ».\n    let B = cases.slice(default_case_num + 1);\n\n    [foundInB, V] = EvaluateCaseClauses(B, V);\n\n    // 8. If foundInB is true, return NormalCompletion(V).\n    if (foundInB) return V;\n\n    // 9. Let R be the result of evaluating DefaultClause.\n    let R = EvaluateCase(cases[default_case_num]);\n\n    // 10. If R.[[Value]] is not empty, let V be R.[[Value]].\n    let val = InternalGetResultValue(realm, R);\n    if (!(val instanceof EmptyValue)) V = val;\n\n    // 11. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).\n    if (R instanceof AbruptCompletion) {\n      throw UpdateEmpty(realm, R, V);\n    }\n\n    // 12: Repeat for each CaseClause C in B (NOTE this is another complete iteration of the second CaseClauses)\n    for (let C of B) {\n      // a. Let R be the result of evaluating CaseClause C.\n      R = EvaluateCase(C);\n\n      // b. If R.[[Value]] is not empty, let V be R.[[Value]].\n      let value = InternalGetResultValue(realm, R);\n      if (!(value instanceof EmptyValue)) V = value;\n\n      // c. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).\n      if (R instanceof AbruptCompletion) {\n        throw UpdateEmpty(realm, R, V);\n      }\n    }\n\n    // 13. Return NormalCompletion(V).\n    return V;\n  } else {\n    // CaseBlock:{CaseClauses}\n    let V;\n    [, V] = EvaluateCaseClauses(cases, realm.intrinsics.undefined);\n    return V;\n  }\n}\n\n// 13.12.11\nexport default function(\n  ast: BabelNodeSwitchStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  labelSet: Array<string>\n): Value {\n  let expression = ast.discriminant;\n\n  // 1. Let exprRef be the result of evaluating Expression.\n  let exprRef = env.evaluate(expression, strictCode);\n\n  // 2. Let switchValue be ? GetValue(exprRef).\n  let switchValue = Environment.GetValue(realm, exprRef);\n  if (switchValue instanceof AbstractValue && !switchValue.values.isTop()) {\n    let elems = switchValue.values.getElements();\n    let n = elems.size;\n    if (n > 1 && n < 10) {\n      let joinedEffects;\n      for (let concreteSwitchValue of elems) {\n        let condition = AbstractValue.createFromBinaryOp(realm, \"===\", switchValue, concreteSwitchValue);\n        let effects = realm.evaluateForEffects(\n          () => {\n            return Path.withCondition(condition, () => {\n              return evaluationHelper(ast, concreteSwitchValue, strictCode, env, realm, labelSet);\n            });\n          },\n          undefined,\n          \"specialized switch\"\n        );\n        joinedEffects =\n          joinedEffects === undefined ? effects : Join.joinEffects(realm, condition, effects, joinedEffects);\n      }\n      invariant(joinedEffects !== undefined);\n      realm.applyEffects(joinedEffects, \"joined specialized switch\");\n      let { result } = joinedEffects;\n      if (result instanceof AbruptCompletion) throw result;\n      if (result instanceof PossiblyNormalCompletion) {\n        // in this case one of the branches may complete abruptly, which means that\n        // not all control flow branches join into one flow at this point.\n        // Consequently we have to continue tracking changes until the point where\n        // all the branches come together into one.\n        result = realm.composeWithSavedCompletion(result);\n      }\n      invariant(result instanceof Value); // since evaluationHelper returns a value in non abrupt cases\n      return result;\n    }\n  }\n\n  return evaluationHelper(ast, switchValue, strictCode, env, realm, labelSet);\n}\n\nfunction evaluationHelper(\n  ast: BabelNodeSwitchStatement,\n  switchValue: Value,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  labelSet: Array<string>\n): Value {\n  let cases: Array<BabelNodeSwitchCase> = ast.cases;\n\n  // 3. Let oldEnv be the running execution context's LexicalEnvironment.\n  let oldEnv = realm.getRunningContext().lexicalEnvironment;\n\n  // 4. Let blockEnv be NewDeclarativeEnvironment(oldEnv).\n  let blockEnv = Environment.NewDeclarativeEnvironment(realm, oldEnv);\n\n  // 5. Perform BlockDeclarationInstantiation(CaseBlock, blockEnv).\n  let CaseBlock = cases.map(c => c.consequent).reduce((stmts, case_blk) => stmts.concat(case_blk), []);\n  Environment.BlockDeclarationInstantiation(realm, strictCode, CaseBlock, blockEnv);\n\n  // 6. Set the running execution context's LexicalEnvironment to blockEnv.\n  realm.getRunningContext().lexicalEnvironment = blockEnv;\n\n  let R;\n  try {\n    // 7. Let R be the result of performing CaseBlockEvaluation of CaseBlock with argument switchValue.\n    R = CaseBlockEvaluation(cases, switchValue, strictCode, blockEnv, realm);\n\n    // 9. Return R.\n    return R;\n  } catch (e) {\n    if (e instanceof BreakCompletion) {\n      if (!e.target) return (UpdateEmpty(realm, e, realm.intrinsics.undefined): any).value;\n    }\n    throw e;\n  } finally {\n    // 8. Set the running execution context's LexicalEnvironment to oldEnv.\n    realm.getRunningContext().lexicalEnvironment = oldEnv;\n    realm.onDestroyScope(blockEnv);\n  }\n}\n"]}