{"version":3,"sources":["../../src/evaluators/NewExpression.js"],"names":["ast","strictCode","env","realm","setNextExecutionContextLocation","loc","constructProduction","callee","args","arguments","ref","evaluate","constructor","GetValue","argsList","length","isInPureScope","tryToEvaluateConstructOrLeaveAsAbstract","createConstruct","t","effects","evaluateForEffects","undefined","error","value","arg","abstractValue","evaluateWithPossibleThrowCompletion","createTemporalFromBuildFunction","constructorNode","argListNodes","newExpression","topVal","applyEffects","completion","result","composeWithSavedCompletion","createErrorThrowCompletion","intrinsics","TypeError"],"mappings":"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","file":"NewExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { AbruptCompletion, PossiblyNormalCompletion } from \"../completions.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport { ObjectValue, Value, AbstractObjectValue, AbstractValue } from \"../values/index.js\";\nimport { Environment, Havoc } from \"../singletons.js\";\nimport { IsConstructor, ArgumentListEvaluation } from \"../methods/index.js\";\nimport { Construct } from \"../methods/index.js\";\nimport invariant from \"../invariant.js\";\nimport { FatalError } from \"../errors.js\";\nimport * as t from \"babel-types\";\nimport { BabelNodeNewExpression, type BabelNodeExpression } from \"babel-types\";\n\nexport default function(\n  ast: BabelNodeNewExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): ObjectValue | AbstractObjectValue {\n  realm.setNextExecutionContextLocation(ast.loc);\n\n  // ECMA262 12.3.3.1 We just implement this method inline since it's only called here.\n  // 1. Return ? EvaluateNew(NewExpression, empty).\n\n  // ECMA262 2.3.3.1.1\n\n  let constructProduction = ast.callee;\n  let args = ast.arguments;\n\n  // These steps not necessary due to our AST representation.\n  // 1. Assert: constructProduction is either a NewExpression or a MemberExpression.\n  // 2. Assert: arguments is either empty or an Arguments production.\n\n  // 3. Let ref be the result of evaluating constructProduction.\n  let ref = env.evaluate(constructProduction, strictCode);\n\n  // 4. Let constructor be ? GetValue(ref).\n  let constructor = Environment.GetValue(realm, ref);\n\n  let argsList;\n\n  // 5. If arguments is empty, let argList be a new empty List.\n  if (!args.length) {\n    argsList = [];\n  } else {\n    // 6. Else,\n    // a. Let argList be ArgumentListEvaluation of arguments.\n    argsList = ArgumentListEvaluation(realm, strictCode, env, (args: any)); // BabelNodeNewExpression needs updating\n\n    // This step not necessary since we propagate completions with exceptions.\n    // b. ReturnIfAbrupt(argList).\n  }\n\n  // If we are in pure scope, attempt to recover from creating the construct if\n  // it fails by creating a temporal abstract\n  if (realm.isInPureScope()) {\n    return tryToEvaluateConstructOrLeaveAsAbstract(constructor, argsList, strictCode, realm);\n  } else {\n    return createConstruct(constructor, argsList, realm);\n  }\n}\n\nfunction tryToEvaluateConstructOrLeaveAsAbstract(\n  constructor: Value,\n  argsList: Array<Value>,\n  strictCode: boolean,\n  realm: Realm\n): ObjectValue | AbstractObjectValue {\n  let effects;\n  try {\n    effects = realm.evaluateForEffects(\n      () => createConstruct(constructor, argsList, realm),\n      undefined,\n      \"tryToEvaluateConstructOrLeaveAsAbstract\"\n    );\n  } catch (error) {\n    // if a FatalError occurs when constructing the constructor\n    // then try and recover and create an abstract for this construct\n    if (error instanceof FatalError) {\n      // we need to havoc all the arguments and the constructor\n      Havoc.value(realm, constructor);\n      for (let arg of argsList) {\n        Havoc.value(realm, arg);\n      }\n      let abstractValue = realm.evaluateWithPossibleThrowCompletion(\n        () =>\n          AbstractValue.createTemporalFromBuildFunction(\n            realm,\n            ObjectValue,\n            [constructor, ...argsList],\n            ([constructorNode, ...argListNodes]: Array<BabelNodeExpression>) =>\n              t.newExpression(constructorNode, argListNodes)\n          ),\n        TypesDomain.topVal,\n        ValuesDomain.topVal\n      );\n      invariant(abstractValue instanceof AbstractObjectValue);\n      return abstractValue;\n    } else {\n      throw error;\n    }\n  }\n  // Note that the effects of (non joining) abrupt branches are not included\n  // in joinedEffects, but are tracked separately inside completion.\n  realm.applyEffects(effects);\n  let completion = effects.result;\n  if (completion instanceof PossiblyNormalCompletion) {\n    // in this case one of the branches may complete abruptly, which means that\n    // not all control flow branches join into one flow at this point.\n    // Consequently we have to continue tracking changes until the point where\n    // all the branches come together into one.\n    completion = realm.composeWithSavedCompletion(completion);\n  }\n\n  // return or throw completion\n  if (completion instanceof AbruptCompletion) throw completion;\n  invariant(completion instanceof ObjectValue || completion instanceof AbstractObjectValue);\n  return completion;\n}\n\nfunction createConstruct(constructor: Value, argsList: Array<Value>, realm: Realm): ObjectValue {\n  // 7. If IsConstructor(constructor) is false, throw a TypeError exception.\n  if (IsConstructor(realm, constructor) === false) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n  }\n  invariant(constructor instanceof ObjectValue);\n\n  // 8. Return ? Construct(constructor, argList).\n  return Construct(realm, constructor, argsList);\n}\n"]}