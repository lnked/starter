{"version":3,"sources":["../../src/evaluators/ForStatement.js"],"names":["CreatePerIterationEnvironment","ast","strictCode","env","realm","labelSet","init","test","update","body","type","kind","varDcl","evaluate","ForBodyEvaluation","oldEnv","loopEnv","NewDeclarativeEnvironment","loopEnvRec","environmentRecord","isConst","boundNames","BoundNames","dn","CreateImmutableBinding","CreateMutableBinding","getRunningContext","lexicalEnvironment","forDcl","evaluateCompletion","currentEnv","onDestroyScope","destroyed","perIterationLets","bodyResult","exprRef","GetValue","perIterationBindings","length","lastIterationEnv","lastIterationEnvRec","outer","parent","thisIterationEnv","thisIterationEnvRec","bn","lastValue","GetBindingValue","InitializeBinding","intrinsics","undefined","increment","stmt","V","testRef","testValue","ToBooleanPartial","useAbstractInterpretation","joinAllLoopExits","result","target","value","containsContinueCompletion","savedCompletion","joinAllLoopContinues","resultValue","incRef","failIfContainsBreakOrContinueCompletionWithNonLocalTarget","c","indexOf","diagnostic","location","handleError","consequent","alternate","valueOrCompletionAtLoopContinuePoint","abruptCompletion","incorporateSavedCompletion","joinedContinueEffects","extractAndJoinCompletionsOfType","applyEffects","remainingCompletions","transferChildrenToPossiblyNormalCompletion","stillAbrupt","containsCompletion","captureEffects","valueOrCompletionAtUnconditionalExit","joinedBreakEffects"],"mappings":"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","file":"ForStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Realm } from \"../realm.js\";\nimport { Value, EmptyValue } from \"../values/index.js\";\nimport {\n  AbruptCompletion,\n  BreakCompletion,\n  Completion,\n  ContinueCompletion,\n  JoinedAbruptCompletions,\n  PossiblyNormalCompletion,\n  ReturnCompletion,\n  ThrowCompletion,\n} from \"../completions.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { UpdateEmpty } from \"../methods/index.js\";\nimport { LoopContinues, InternalGetResultValue } from \"./ForOfStatement.js\";\nimport { Environment, Functions, Join, To } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNodeForStatement } from \"babel-types\";\n\n// ECMA262 13.7.4.9\nexport function CreatePerIterationEnvironment(realm: Realm, perIterationBindings: Array<string>) {\n  // 1. If perIterationBindings has any elements, then\n  if (perIterationBindings.length > 0) {\n    // a. Let lastIterationEnv be the running execution context's LexicalEnvironment.\n    let lastIterationEnv = realm.getRunningContext().lexicalEnvironment;\n    // b. Let lastIterationEnvRec be lastIterationEnv's EnvironmentRecord.\n    let lastIterationEnvRec = lastIterationEnv.environmentRecord;\n    // c. Let outer be lastIterationEnv's outer environment reference.\n    let outer = lastIterationEnv.parent;\n    // d. Assert: outer is not null.\n    invariant(outer !== null);\n    // e. Let thisIterationEnv be NewDeclarativeEnvironment(outer).\n    let thisIterationEnv = Environment.NewDeclarativeEnvironment(realm, outer);\n    // f. Let thisIterationEnvRec be thisIterationEnv's EnvironmentRecord.\n    realm.onDestroyScope(lastIterationEnv);\n    let thisIterationEnvRec = thisIterationEnv.environmentRecord;\n    // g. For each element bn of perIterationBindings do,\n    for (let bn of perIterationBindings) {\n      // i. Perform ! thisIterationEnvRec.CreateMutableBinding(bn, false).\n      thisIterationEnvRec.CreateMutableBinding(bn, false);\n      // ii. Let lastValue be ? lastIterationEnvRec.GetBindingValue(bn, true).\n      let lastValue = lastIterationEnvRec.GetBindingValue(bn, true);\n      // iii.Perform thisIterationEnvRec.InitializeBinding(bn, lastValue).\n      thisIterationEnvRec.InitializeBinding(bn, lastValue);\n    }\n    // h. Set the running execution context's LexicalEnvironment to thisIterationEnv.\n    realm.getRunningContext().lexicalEnvironment = thisIterationEnv;\n  }\n  // 2. Return undefined.\n  return realm.intrinsics.undefined;\n}\n\n// ECMA262 13.7.4.8\nfunction ForBodyEvaluation(\n  realm: Realm,\n  test,\n  increment,\n  stmt,\n  perIterationBindings: Array<string>,\n  labelSet: ?Array<string>,\n  strictCode: boolean\n): Value {\n  // 1. Let V be undefined.\n  let V: Value = realm.intrinsics.undefined;\n\n  // 2. Perform ? CreatePerIterationEnvironment(perIterationBindings).\n  CreatePerIterationEnvironment(realm, perIterationBindings);\n  let env = realm.getRunningContext().lexicalEnvironment;\n\n  // 3. Repeat\n  while (true) {\n    // a. If test is not [empty], then\n    if (test) {\n      // i. Let testRef be the result of evaluating test.\n      let testRef = env.evaluate(test, strictCode);\n\n      // ii. Let testValue be ? GetValue(testRef).\n      let testValue = Environment.GetValue(realm, testRef);\n\n      // iii. If ToBoolean(testValue) is false, return NormalCompletion(V).\n      if (!To.ToBooleanPartial(realm, testValue)) {\n        // joinAllLoopExits does not handle labeled break/continue, so only use it when doing AI\n        if (realm.useAbstractInterpretation) return joinAllLoopExits(V);\n        return V;\n      }\n    }\n\n    // b. Let result be the result of evaluating stmt.\n    let result = env.evaluateCompletion(stmt, strictCode);\n    invariant(result instanceof Value || result instanceof AbruptCompletion);\n\n    // c. If LoopContinues(result, labelSet) is false, return Completion(UpdateEmpty(result, V)).\n    if (!LoopContinues(realm, result, labelSet)) {\n      invariant(result instanceof AbruptCompletion);\n      // joinAllLoopExits does not handle labeled break/continue, so only use it when doing AI\n      if (realm.useAbstractInterpretation) {\n        result = UpdateEmpty(realm, result, V);\n        invariant(result instanceof AbruptCompletion);\n        return joinAllLoopExits(result);\n      }\n      // ECMA262 13.1.7\n      if (result instanceof BreakCompletion) {\n        if (!result.target) return (UpdateEmpty(realm, result, V): any).value;\n      }\n      throw UpdateEmpty(realm, result, V);\n    } else if (realm.useAbstractInterpretation) {\n      // This is a join point for conditional continue completions lurking in realm.savedCompletion\n      if (containsContinueCompletion(realm.savedCompletion)) {\n        result = joinAllLoopContinues(result);\n      }\n    }\n\n    // d. If result.[[Value]] is not empty, let V be result.[[Value]].\n    let resultValue = InternalGetResultValue(realm, result);\n    if (!(resultValue instanceof EmptyValue)) V = resultValue;\n\n    // e. Perform ? CreatePerIterationEnvironment(perIterationBindings).\n    CreatePerIterationEnvironment(realm, perIterationBindings);\n    env = realm.getRunningContext().lexicalEnvironment;\n\n    // f. If increment is not [empty], then\n    if (increment) {\n      // i. Let incRef be the result of evaluating increment.\n      let incRef = env.evaluate(increment, strictCode);\n\n      // ii. Perform ? GetValue(incRef).\n      Environment.GetValue(realm, incRef);\n    }\n  }\n  invariant(false);\n\n  function failIfContainsBreakOrContinueCompletionWithNonLocalTarget(c: void | Completion | Value) {\n    if (c === undefined) return;\n    if (c instanceof ContinueCompletion || c instanceof BreakCompletion) {\n      if (!c.target) return;\n      if (labelSet && labelSet.indexOf(c.target) >= 0) {\n        c.target = null;\n        return;\n      }\n      let diagnostic = new CompilerDiagnostic(\n        \"break or continue with target cannot be guarded by abstract condition\",\n        c.location,\n        \"PP0034\",\n        \"FatalError\"\n      );\n      realm.handleError(diagnostic);\n      throw new FatalError();\n    }\n    if (c instanceof PossiblyNormalCompletion || c instanceof JoinedAbruptCompletions) {\n      failIfContainsBreakOrContinueCompletionWithNonLocalTarget(c.consequent);\n      failIfContainsBreakOrContinueCompletionWithNonLocalTarget(c.alternate);\n    }\n  }\n\n  function containsContinueCompletion(c: void | Completion | Value) {\n    if (c === undefined) return false;\n    if (c instanceof ContinueCompletion) {\n      if (!c.target) return true;\n      if (labelSet && labelSet.indexOf(c.target) >= 0) {\n        c.target = null;\n        return true;\n      }\n      return false;\n    }\n    if (c instanceof PossiblyNormalCompletion || c instanceof JoinedAbruptCompletions)\n      return containsContinueCompletion(c.consequent) || containsContinueCompletion(c.alternate);\n    return false;\n  }\n\n  function joinAllLoopContinues(\n    valueOrCompletionAtLoopContinuePoint: Value | AbruptCompletion\n  ): Value | AbruptCompletion {\n    // We are about start the next loop iteration and this presents a join point where all non loop breaking abrupt\n    // control flows converge into a single flow using their joined effects as the new state.\n    failIfContainsBreakOrContinueCompletionWithNonLocalTarget(realm.savedCompletion);\n\n    // Incorporate the savedCompletion (we should only get called if there is one).\n    invariant(realm.savedCompletion !== undefined);\n    if (valueOrCompletionAtLoopContinuePoint instanceof Value)\n      valueOrCompletionAtLoopContinuePoint = new ContinueCompletion(valueOrCompletionAtLoopContinuePoint);\n    let abruptCompletion = Functions.incorporateSavedCompletion(realm, valueOrCompletionAtLoopContinuePoint);\n    invariant(abruptCompletion instanceof AbruptCompletion);\n\n    // If there is now a single completion, we don't need to join\n    if (!(abruptCompletion instanceof JoinedAbruptCompletions)) return abruptCompletion;\n    invariant(containsContinueCompletion(abruptCompletion));\n\n    // Apply the joined effects of continue completions to the current state since these now join the normal path\n    let joinedContinueEffects = Join.extractAndJoinCompletionsOfType(ContinueCompletion, realm, abruptCompletion);\n    realm.applyEffects(joinedContinueEffects);\n    let c = joinedContinueEffects.result;\n    invariant(c instanceof ContinueCompletion);\n\n    // We now make a PossiblyNormalCompletion out of abruptCompletion.\n    // extractAndJoinCompletionsOfType helped with this by cheating and turning all of its nested completions\n    // that contain continue completions into PossiblyNormalCompletions.\n    let remainingCompletions = abruptCompletion.transferChildrenToPossiblyNormalCompletion();\n\n    // At this stage there can still be other kinds of abrupt completions left inside abruptCompletion. If not just return.\n    let stillAbrupt =\n      remainingCompletions.containsCompletion(BreakCompletion) ||\n      remainingCompletions.containsCompletion(ReturnCompletion) ||\n      remainingCompletions.containsCompletion(ThrowCompletion);\n    if (!stillAbrupt) return c;\n\n    // Stash the remaining completions in the realm start tracking the effects that need to be appended\n    // to the normal branch at the next join point.\n    realm.savedCompletion = remainingCompletions;\n    realm.captureEffects(remainingCompletions); // so that we can join the normal path wtih them later on\n    return c;\n  }\n\n  function joinAllLoopExits(valueOrCompletionAtUnconditionalExit: Value | AbruptCompletion): Value {\n    // We are about the leave this loop and this presents a join point where all loop breaking control flows\n    // converge into a single flow using their joined effects as the new state.\n    failIfContainsBreakOrContinueCompletionWithNonLocalTarget(realm.savedCompletion);\n\n    // Incorporate the savedCompletion if there is one.\n    if (valueOrCompletionAtUnconditionalExit instanceof Value)\n      valueOrCompletionAtUnconditionalExit = new BreakCompletion(valueOrCompletionAtUnconditionalExit);\n    let abruptCompletion = Functions.incorporateSavedCompletion(realm, valueOrCompletionAtUnconditionalExit);\n    invariant(abruptCompletion instanceof AbruptCompletion);\n\n    // If there is now a single completion, we don't need to join\n    if (abruptCompletion instanceof BreakCompletion) return (UpdateEmpty(realm, abruptCompletion, V): any).value;\n    if (!(abruptCompletion instanceof JoinedAbruptCompletions)) throw abruptCompletion;\n\n    // If there are no breaks, we don't need to join\n    if (!abruptCompletion.containsCompletion(BreakCompletion)) throw abruptCompletion;\n\n    // Apply the joined effects of break completions to the current state since these now join the normal path\n    let joinedBreakEffects = Join.extractAndJoinCompletionsOfType(BreakCompletion, realm, abruptCompletion);\n    realm.applyEffects(joinedBreakEffects);\n    let c = joinedBreakEffects.result;\n    invariant(c instanceof BreakCompletion);\n\n    // We now make a PossiblyNormalCompletion out of abruptCompletion.\n    // extractAndJoinCompletionsOfType helped with this by cheating and turning all of its nested completions\n    // that contain continue completions into PossiblyNormalCompletions.\n    let remainingCompletions = abruptCompletion.transferChildrenToPossiblyNormalCompletion();\n\n    // At this stage there can still be other kinds of abrupt completions left inside abruptCompletion. If not just return.\n    let stillAbrupt =\n      remainingCompletions.containsCompletion(ReturnCompletion) ||\n      remainingCompletions.containsCompletion(ThrowCompletion);\n    if (!stillAbrupt) return (UpdateEmpty(realm, c, V): any).value;\n\n    // Stash the remaining completions in the realm start tracking the effects that need to be appended\n    // to the normal branch at the next join point.\n    realm.savedCompletion = remainingCompletions;\n    realm.captureEffects(remainingCompletions); // so that we can join the normal path wtih them later on\n\n    // ECMA262 13.1.7\n    return (UpdateEmpty(realm, c, V): any).value;\n  }\n}\n\n// ECMA262 13.7.4.7\nexport default function(\n  ast: BabelNodeForStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  labelSet: ?Array<string>\n): Value {\n  let { init, test, update, body } = ast;\n\n  if (init && init.type === \"VariableDeclaration\") {\n    if (init.kind === \"var\") {\n      // for (var VariableDeclarationList; Expression; Expression) Statement\n      // 1. Let varDcl be the result of evaluating VariableDeclarationList.\n      let varDcl = env.evaluate(init, strictCode);\n\n      // 2. ReturnIfAbrupt(varDcl).\n      varDcl;\n\n      // 3. Return ? ForBodyEvaluation(the first Expression, the second Expression, Statement, « », labelSet).\n      return ForBodyEvaluation(realm, test, update, body, [], labelSet, strictCode);\n    } else {\n      // for (LexicalDeclaration Expression; Expression) Statement\n      // 1. Let oldEnv be the running execution context's LexicalEnvironment.\n      let oldEnv = env;\n\n      // 2. Let loopEnv be NewDeclarativeEnvironment(oldEnv).\n      let loopEnv = Environment.NewDeclarativeEnvironment(realm, oldEnv);\n\n      // 3. Let loopEnvRec be loopEnv's EnvironmentRecord.\n      let loopEnvRec = loopEnv.environmentRecord;\n\n      // 4. Let isConst be the result of performing IsConstantDeclaration of LexicalDeclaration.\n      let isConst = init.kind === \"const\";\n\n      // 5. Let boundNames be the BoundNames of LexicalDeclaration.\n      let boundNames = Environment.BoundNames(realm, init);\n\n      // 6. For each element dn of boundNames do\n      for (let dn of boundNames) {\n        // a. If isConst is true, then\n        if (isConst) {\n          // i. Perform ! loopEnvRec.CreateImmutableBinding(dn, true).\n          loopEnvRec.CreateImmutableBinding(dn, true);\n        } else {\n          // b. Else,\n          // i. Perform ! loopEnvRec.CreateMutableBinding(dn, false).\n          loopEnvRec.CreateMutableBinding(dn, false);\n        }\n      }\n\n      // 7. Set the running execution context's LexicalEnvironment to loopEnv.\n      realm.getRunningContext().lexicalEnvironment = loopEnv;\n\n      // 8. Let forDcl be the result of evaluating LexicalDeclaration.\n      let forDcl = loopEnv.evaluateCompletion(init, strictCode);\n\n      // 9. If forDcl is an abrupt completion, then\n      if (forDcl instanceof AbruptCompletion) {\n        // a. Set the running execution context's LexicalEnvironment to oldEnv.\n        let currentEnv = realm.getRunningContext().lexicalEnvironment;\n        realm.onDestroyScope(currentEnv);\n        if (currentEnv !== loopEnv) invariant(loopEnv.destroyed);\n        realm.getRunningContext().lexicalEnvironment = oldEnv;\n\n        // b. Return Completion(forDcl).\n        throw forDcl;\n      }\n\n      // 10. If isConst is false, let perIterationLets be boundNames; otherwise let perIterationLets be « ».\n      let perIterationLets = !isConst ? boundNames : [];\n\n      let bodyResult;\n      try {\n        // 11. Let bodyResult be ForBodyEvaluation(the first Expression, the second Expression, Statement, perIterationLets, labelSet).\n        bodyResult = ForBodyEvaluation(realm, test, update, body, perIterationLets, labelSet, strictCode);\n      } finally {\n        // 12. Set the running execution context's LexicalEnvironment to oldEnv.\n        let currentEnv = realm.getRunningContext().lexicalEnvironment;\n        realm.onDestroyScope(currentEnv);\n        if (currentEnv !== loopEnv) invariant(loopEnv.destroyed);\n        realm.getRunningContext().lexicalEnvironment = oldEnv;\n      }\n      // 13. Return Completion(bodyResult).\n      return bodyResult;\n    }\n  } else {\n    // for (Expression; Expression; Expression) Statement\n    // 1. If the first Expression is present, then\n    if (init) {\n      // a. Let exprRef be the result of evaluating the first Expression.\n      let exprRef = env.evaluate(init, strictCode);\n\n      // b. Perform ? GetValue(exprRef).\n      Environment.GetValue(realm, exprRef);\n    }\n\n    // 2. Return ? ForBodyEvaluation(the second Expression, the third Expression, Statement, « », labelSet).\n    return ForBodyEvaluation(realm, test, update, body, [], labelSet, strictCode);\n  }\n}\n"]}