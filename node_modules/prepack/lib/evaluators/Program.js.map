{"version":3,"sources":["../../src/evaluators/Program.js"],"names":["GlobalDeclarationInstantiation","ast","strictCode","env","realm","val","node","body","type","res","evaluateCompletionDeref","useAbstractInterpretation","generator","undefined","incorporateSavedCompletion","containsCompletion","joinedEffects","joinNestedEffects","applyEffects","result","emitThrow","value","intrinsics","directives","length","directive","evaluate","e","getCapturedEffects","normalPathGenerator","stopEffectCaptureAndUndoEffects","effectsTree","joinPossiblyNormalCompletionWithAbruptCompletion","appendGenerator","emitConditionalThrow","joinCondition","consequent","alternate","empty","getRunningContext","isStrict","envRec","environmentRecord","lexNames","varNames","kind","concat","BoundNames","name","HasVarDeclaration","createErrorThrowCompletion","SyntaxError","HasLexicalDeclaration","hasRestrictedGlobal","HasRestrictedGlobalProperty","varDeclarations","FindVarScopedDeclarations","functionsToInitialize","declaredFunctionNames","d","reverse","fn","indexOf","fnDefinable","CanDeclareGlobalFunction","TypeError","push","unshift","declaredVarNames","vn","vnDefinable","CanDeclareGlobalVar","lexDeclarations","s","dn","CreateImmutableBinding","CreateMutableBinding","f","fo","CreateGlobalFunctionBinding","CreateGlobalVarBinding"],"mappings":"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","file":"Program.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport {\n  AbruptCompletion,\n  JoinedAbruptCompletions,\n  PossiblyNormalCompletion,\n  ReturnCompletion,\n  ThrowCompletion,\n} from \"../completions.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { Value, EmptyValue } from \"../values/index.js\";\nimport { GlobalEnvironmentRecord } from \"../environment.js\";\nimport { Environment, Functions, Join } from \"../singletons.js\";\nimport IsStrict from \"../utils/strict.js\";\nimport invariant from \"../invariant.js\";\nimport traverseFast from \"../utils/traverse-fast.js\";\nimport type { BabelNodeProgram, BabelNodeVariableDeclaration } from \"babel-types\";\n\n// ECMA262 15.1.11\nexport function GlobalDeclarationInstantiation(\n  realm: Realm,\n  ast: BabelNodeProgram,\n  env: LexicalEnvironment,\n  strictCode: boolean\n) {\n  realm.getRunningContext().isStrict = realm.isStrict = strictCode;\n\n  // 1. Let envRec be env's EnvironmentRecord.\n  let envRec = env.environmentRecord;\n\n  // 2. Assert: envRec is a global Environment Record.\n  invariant(envRec instanceof GlobalEnvironmentRecord, \"expected global environment record\");\n\n  // 3. Let lexNames be the LexicallyDeclaredNames of script.\n  let lexNames = [];\n\n  // 4. Let varNames be the VarDeclaredNames of script.\n  let varNames = [];\n\n  traverseFast(ast, node => {\n    if (node.type === \"VariableDeclaration\") {\n      if (((node: any): BabelNodeVariableDeclaration).kind === \"var\") {\n        varNames = varNames.concat(Environment.BoundNames(realm, node));\n      } else {\n        lexNames = lexNames.concat(Environment.BoundNames(realm, node));\n      }\n    } else if (node.type === \"FunctionExpression\" || node.type === \"FunctionDeclaration\") {\n      return true;\n    }\n    return false;\n  });\n\n  // 5. For each name in lexNames, do\n  for (let name of lexNames) {\n    // a. If envRec.HasVarDeclaration(name) is true, throw a SyntaxError exception.\n    if (envRec.HasVarDeclaration(name)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, name + \" already declared with var\");\n    }\n\n    // b. If envRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.\n    if (envRec.HasLexicalDeclaration(name)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.SyntaxError,\n        name + \" already declared with let or const\"\n      );\n    }\n\n    // c. Let hasRestrictedGlobal be ? envRec.HasRestrictedGlobalProperty(name).\n    let hasRestrictedGlobal = envRec.HasRestrictedGlobalProperty(name);\n\n    // d. If hasRestrictedGlobal is true, throw a SyntaxError exception.\n    if (hasRestrictedGlobal) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, name + \" global object is restricted\");\n    }\n  }\n\n  // 6. For each name in varNames, do\n  for (let name of varNames) {\n    // a. If envRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.\n    if (envRec.HasLexicalDeclaration(name)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.SyntaxError,\n        name + \" already declared with let or const\"\n      );\n    }\n  }\n\n  // 7. Let varDeclarations be the VarScopedDeclarations of script.\n  let varDeclarations = Functions.FindVarScopedDeclarations(ast);\n\n  // 8. Let functionsToInitialize be a new empty List.\n  let functionsToInitialize = [];\n\n  // 9. Let declaredFunctionNames be a new empty List.\n  let declaredFunctionNames = [];\n\n  // 10. For each d in varDeclarations, in reverse list order do\n  for (let d of varDeclarations.reverse()) {\n    // a. If d is neither a VariableDeclaration or a ForBinding, then\n    if (d.type !== \"VariableDeclaration\") {\n      // i. Assert: d is either a FunctionDeclaration or a GeneratorDeclaration.\n      invariant(d.type === \"FunctionDeclaration\", \"expected function\");\n\n      // ii. NOTE If there are multiple FunctionDeclarations for the same name, the last declaration is used.\n\n      // iii. Let fn be the sole element of the BoundNames of d.\n      let fn = Environment.BoundNames(realm, d)[0];\n\n      // iv. If fn is not an element of declaredFunctionNames, then\n      if (declaredFunctionNames.indexOf(fn) < 0) {\n        // 1. Let fnDefinable be ? envRec.CanDeclareGlobalFunction(fn).\n        let fnDefinable = envRec.CanDeclareGlobalFunction(fn);\n\n        // 2. If fnDefinable is false, throw a TypeError exception.\n        if (!fnDefinable) {\n          throw realm.createErrorThrowCompletion(\n            realm.intrinsics.TypeError,\n            fn + \": global function declarations are not allowed\"\n          );\n        }\n\n        // 3. Append fn to declaredFunctionNames.\n        declaredFunctionNames.push(fn);\n\n        // 4. Insert d as the first element of functionsToInitialize.\n        functionsToInitialize.unshift(d);\n      }\n    }\n  }\n\n  // 11. Let declaredVarNames be a new empty List.\n  let declaredVarNames = [];\n\n  // 12. For each d in varDeclarations, do\n  for (let d of varDeclarations) {\n    // a. If d is a VariableDeclaration or a ForBinding, then\n    if (d.type === \"VariableDeclaration\") {\n      // i. For each String vn in the BoundNames of d, do\n      for (let vn of Environment.BoundNames(realm, d)) {\n        // ii. If vn is not an element of declaredFunctionNames, then\n        if (declaredFunctionNames.indexOf(vn) < 0) {\n          // 1. Let vnDefinable be ? envRec.CanDeclareGlobalVar(vn).\n          let vnDefinable = envRec.CanDeclareGlobalVar(vn);\n\n          // 2. If vnDefinable is false, throw a TypeError exception.\n          if (!vnDefinable) {\n            throw realm.createErrorThrowCompletion(\n              realm.intrinsics.TypeError,\n              vn + \": global variable declarations are not allowed\"\n            );\n          }\n\n          // 3. If vn is not an element of declaredVarNames, then\n          if (declaredVarNames.indexOf(vn) < 0) {\n            // a. Append vn to declaredVarNames.\n            declaredVarNames.push(vn);\n          }\n        }\n      }\n    }\n  }\n\n  // 13. NOTE: No abnormal terminations occur after this algorithm step if the global object is an ordinary object. However, if the global object is a Proxy exotic object it may exhibit behaviours that cause abnormal terminations in some of the following steps.\n\n  // 14. NOTE: Annex B.3.3.2 adds additional steps at this point.\n\n  // 15. Let lexDeclarations be the LexicallyScopedDeclarations of script.\n  let lexDeclarations = [];\n  for (let s of ast.body) {\n    if (s.type === \"VariableDeclaration\" && s.kind !== \"var\") {\n      lexDeclarations.push(s);\n    }\n  }\n\n  // 16. For each element d in lexDeclarations do\n  for (let d of lexDeclarations) {\n    // a. NOTE Lexically declared names are only instantiated here but not initialized.\n\n    // b. For each element dn of the BoundNames of d do\n    for (let dn of Environment.BoundNames(realm, d)) {\n      // i. If IsConstantDeclaration of d is true, then\n      if (d.kind === \"const\") {\n        // 1. Perform ? envRec.CreateImmutableBinding(dn, true).\n        envRec.CreateImmutableBinding(dn, true);\n      } else {\n        // ii. Else,\n        // 1. Perform ? envRec.CreateMutableBinding(dn, false).\n        envRec.CreateMutableBinding(dn, false);\n      }\n    }\n  }\n\n  // 17. For each production f in functionsToInitialize, do\n  for (let f of functionsToInitialize) {\n    // a. Let fn be the sole element of the BoundNames of f.\n    let fn = Environment.BoundNames(realm, f)[0];\n\n    // b. Let fo be the result of performing InstantiateFunctionObject for f with argument env.\n    let fo = env.evaluate(f, strictCode);\n    invariant(fo instanceof Value);\n\n    // c. Perform ? envRec.CreateGlobalFunctionBinding(fn, fo, false).\n    envRec.CreateGlobalFunctionBinding(fn, fo, false);\n  }\n\n  // 18. For each String vn in declaredVarNames, in list order do\n  for (let vn of declaredVarNames) {\n    // a. Perform ? envRec.CreateGlobalVarBinding(vn, false).\n    envRec.CreateGlobalVarBinding(vn, false);\n  }\n\n  // 19. Return NormalCompletion(empty).\n  return realm.intrinsics.empty;\n}\n\nexport default function(ast: BabelNodeProgram, strictCode: boolean, env: LexicalEnvironment, realm: Realm): Value {\n  strictCode = IsStrict(ast);\n\n  GlobalDeclarationInstantiation(realm, ast, env, strictCode);\n\n  let val;\n\n  for (let node of ast.body) {\n    if (node.type !== \"FunctionDeclaration\") {\n      let res = env.evaluateCompletionDeref(node, strictCode);\n      if (res instanceof AbruptCompletion) {\n        if (!realm.useAbstractInterpretation) throw res;\n        let generator = realm.generator;\n        invariant(generator !== undefined);\n        // We are about the leave this program and this presents a join point where all control flows\n        // converge into a single flow using the joined effects as the new state.\n        res = Functions.incorporateSavedCompletion(realm, res);\n        if (res instanceof JoinedAbruptCompletions && res.containsCompletion(ThrowCompletion)) {\n          // The global state is now at the point where the first fork occurred.\n          let joinedEffects = Join.joinNestedEffects(realm, res);\n          realm.applyEffects(joinedEffects);\n          res = joinedEffects.result;\n        } else if (res instanceof ThrowCompletion) {\n          generator.emitThrow(res.value);\n          res = realm.intrinsics.undefined;\n        } else {\n          invariant(false); // other kinds of abrupt completions should not get this far\n        }\n        break;\n      }\n      if (!(res instanceof EmptyValue)) {\n        val = res;\n      }\n    }\n  }\n  let directives = ast.directives;\n  if (!val && directives && directives.length) {\n    let directive = directives[directives.length - 1];\n    val = env.evaluate(directive, strictCode);\n    invariant(val instanceof Value);\n  }\n\n  // We are about to leave this program and this presents a join point where all control flows\n  // converge into a single flow and the joined effects become the final state.\n  if (val instanceof Value) {\n    let res = Functions.incorporateSavedCompletion(realm, val);\n    if (res instanceof PossiblyNormalCompletion) {\n      // There are still some conditional throws to emit and state still has to be joined in.\n      // Get state to be joined in\n      let e = realm.getCapturedEffects(res);\n      invariant(e !== undefined);\n      let normalPathGenerator = e.generator;\n      realm.stopEffectCaptureAndUndoEffects(res);\n      let effectsTree = Join.joinPossiblyNormalCompletionWithAbruptCompletion(\n        realm,\n        res,\n        new ReturnCompletion(realm.intrinsics.undefined),\n        e\n      );\n      realm.applyEffects(effectsTree, \"\", false);\n      // The global state is now at the point where the first fork occurred.\n      res = effectsTree.result;\n      invariant(res instanceof JoinedAbruptCompletions);\n      let generator = realm.generator;\n      invariant(generator !== undefined);\n      if (res.containsCompletion(ThrowCompletion)) {\n        generator.appendGenerator(effectsTree.generator, \"\");\n        generator.emitConditionalThrow(res.joinCondition, res.consequent, res.alternate);\n      }\n      generator.appendGenerator(normalPathGenerator, \"non exceptional post fork entries\");\n    }\n  } else {\n    // program was empty. Nothing to do.\n  }\n\n  invariant(val === undefined || val instanceof Value);\n  return val || realm.intrinsics.empty;\n}\n"]}