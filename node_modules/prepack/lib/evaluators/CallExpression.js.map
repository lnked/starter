{"version":3,"sources":["../../src/evaluators/CallExpression.js"],"names":["ast","strictCode","env","realm","callee","type","arguments","setNextExecutionContextLocation","loc","ref","evaluate","base","mightNotBeObject","isInPureScope","dummy","evaluateWithPossibleThrowCompletion","generateRuntimeCall","topVal","func","GetValue","EvaluateCall","t","callBothFunctionsAndJoinTheirEffects","args","cond","func1","func2","getType","isTypeCompatibleWith","e1","evaluateForEffects","undefined","e2","joinedEffects","joinEffects","result","generator","modifiedBindings","modifiedProperties","createdObjects","completion","composeWithSavedCompletion","applyEffects","thisArg","propName","referencedName","push","concat","arg","value","resultType","functionResultType","createTemporalFromBuildFunction","nodes","callFunc","argStart","isValidIdentifier","memberExpression","identifier","stringLiteral","fun_args","slice","callExpression","tryToEvaluateCallOrLeaveAsAbstract","thisValue","tailCall","effects","savedSuppressDiagnostics","suppressDiagnostics","error","property","handleError","kind","IsPropertyReference","GetReferencedName","intrinsics","eval","argList","length","evalText","strictCaller","evalRealm","PerformEval","refEnv","GetBase","WithBaseObject","thisCall"],"mappings":"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","file":"CallExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { AbruptCompletion, PossiblyNormalCompletion } from \"../completions.js\";\nimport type { Realm } from \"../realm.js\";\nimport { Effects } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { EnvironmentRecord } from \"../environment.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport { Value } from \"../values/index.js\";\nimport { AbstractValue, AbstractObjectValue, BooleanValue, ConcreteValue, FunctionValue } from \"../values/index.js\";\nimport { Reference } from \"../environment.js\";\nimport { Environment, Functions, Havoc, Join } from \"../singletons.js\";\nimport {\n  ArgumentListEvaluation,\n  EvaluateDirectCall,\n  GetThisValue,\n  IsInTailPosition,\n  SameValue,\n} from \"../methods/index.js\";\nimport type { BabelNodeCallExpression, BabelNodeExpression, BabelNodeSpreadElement } from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport * as t from \"babel-types\";\nimport SuperCall from \"./SuperCall\";\n\nexport default function(\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  if (ast.callee.type === \"Super\") {\n    return SuperCall(ast.arguments, strictCode, env, realm);\n  }\n\n  // ECMA262 12.3.4.1\n  realm.setNextExecutionContextLocation(ast.loc);\n\n  // 1. Let ref be the result of evaluating MemberExpression.\n  let ref = env.evaluate(ast.callee, strictCode);\n  if (\n    ref instanceof Reference &&\n    ref.base instanceof AbstractValue &&\n    ref.base.mightNotBeObject() &&\n    realm.isInPureScope()\n  ) {\n    let dummy = ref.base;\n    // avoid explicitly converting ref.base to an object because that will create a generator entry\n    // leading to two object allocations rather than one.\n    return realm.evaluateWithPossibleThrowCompletion(\n      () => generateRuntimeCall(ref, dummy, ast, strictCode, env, realm),\n      TypesDomain.topVal,\n      ValuesDomain.topVal\n    );\n  }\n\n  // 2. Let func be ? GetValue(ref).\n  let func = Environment.GetValue(realm, ref);\n\n  return EvaluateCall(ref, func, ast, strictCode, env, realm);\n}\n\nfunction callBothFunctionsAndJoinTheirEffects(\n  args: Array<Value>,\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  let [cond, func1, func2] = args;\n  invariant(cond instanceof AbstractValue && cond.getType() === BooleanValue);\n  invariant(Value.isTypeCompatibleWith(func1.getType(), FunctionValue));\n  invariant(Value.isTypeCompatibleWith(func2.getType(), FunctionValue));\n\n  const e1 = realm.evaluateForEffects(\n    () => EvaluateCall(func1, func1, ast, strictCode, env, realm),\n    undefined,\n    \"callBothFunctionsAndJoinTheirEffects/1\"\n  );\n\n  const e2 = realm.evaluateForEffects(\n    () => EvaluateCall(func2, func2, ast, strictCode, env, realm),\n    undefined,\n    \"callBothFunctionsAndJoinTheirEffects/2\"\n  );\n\n  let joinedEffects = Join.joinEffects(\n    realm,\n    cond,\n    new Effects(e1.result, e1.generator, e1.modifiedBindings, e1.modifiedProperties, e1.createdObjects),\n    new Effects(e2.result, e2.generator, e2.modifiedBindings, e2.modifiedProperties, e2.createdObjects)\n  );\n  let completion = joinedEffects.result;\n  if (completion instanceof PossiblyNormalCompletion) {\n    // in this case one of the branches may complete abruptly, which means that\n    // not all control flow branches join into one flow at this point.\n    // Consequently we have to continue tracking changes until the point where\n    // all the branches come together into one.\n    completion = realm.composeWithSavedCompletion(completion);\n  }\n\n  // Note that the effects of (non joining) abrupt branches are not included\n  // in joinedEffects, but are tracked separately inside completion.\n  realm.applyEffects(joinedEffects);\n\n  // return or throw completion\n  if (completion instanceof AbruptCompletion) throw completion;\n  invariant(completion instanceof Value);\n  return completion;\n}\n\nfunction generateRuntimeCall(\n  ref: Value | Reference,\n  func: Value,\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n) {\n  let args = [func];\n  let [thisArg, propName] = ref instanceof Reference ? [ref.base, ref.referencedName] : [];\n  if (thisArg instanceof Value) args = [thisArg];\n  if (propName !== undefined && typeof propName !== \"string\") args.push(propName);\n  args = args.concat(ArgumentListEvaluation(realm, strictCode, env, ast.arguments));\n  for (let arg of args) {\n    if (arg !== func) {\n      // Since we don't know which function we are calling, we assume that any unfrozen object\n      // passed as an argument has leaked to the environment and is henceforth in an unknown (havoced) state,\n      // as is any other object that is known to be reachable from this object.\n      // NB: Note that this is still optimistic, particularly if the environment exposes the same object\n      // to Prepack via alternative means, thus creating aliasing that is not tracked by Prepack.\n      Havoc.value(realm, arg, ast.loc);\n    }\n  }\n  let resultType = (func instanceof AbstractObjectValue ? func.functionResultType : undefined) || Value;\n  return AbstractValue.createTemporalFromBuildFunction(realm, resultType, args, nodes => {\n    let callFunc;\n    let argStart = 1;\n    if (thisArg instanceof Value) {\n      if (typeof propName === \"string\") {\n        callFunc = t.isValidIdentifier(propName)\n          ? t.memberExpression(nodes[0], t.identifier(propName), false)\n          : t.memberExpression(nodes[0], t.stringLiteral(propName), true);\n      } else {\n        callFunc = t.memberExpression(nodes[0], nodes[1], true);\n        argStart = 2;\n      }\n    } else {\n      callFunc = nodes[0];\n    }\n    let fun_args = ((nodes.slice(argStart): any): Array<BabelNodeExpression | BabelNodeSpreadElement>);\n    return t.callExpression(callFunc, fun_args);\n  });\n}\n\nfunction tryToEvaluateCallOrLeaveAsAbstract(\n  ref: Value | Reference,\n  func: Value,\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  thisValue: Value,\n  tailCall: boolean\n): Value {\n  let effects;\n  let savedSuppressDiagnostics = realm.suppressDiagnostics;\n  try {\n    realm.suppressDiagnostics = true;\n    effects = realm.evaluateForEffects(\n      () => EvaluateDirectCall(realm, strictCode, env, ref, func, thisValue, ast.arguments, tailCall),\n      undefined,\n      \"tryToEvaluateCallOrLeaveAsAbstract\"\n    );\n  } catch (error) {\n    if (error instanceof FatalError) {\n      realm.suppressDiagnostics = savedSuppressDiagnostics;\n      return realm.evaluateWithPossibleThrowCompletion(\n        () => generateRuntimeCall(ref, func, ast, strictCode, env, realm),\n        TypesDomain.topVal,\n        ValuesDomain.topVal\n      );\n    } else {\n      throw error;\n    }\n  } finally {\n    realm.suppressDiagnostics = savedSuppressDiagnostics;\n  }\n  // Note that the effects of (non joining) abrupt branches are not included\n  // in effects, but are tracked separately inside completion.\n  realm.applyEffects(effects);\n  let completion = effects.result;\n  if (completion instanceof PossiblyNormalCompletion) {\n    // in this case one of the branches may complete abruptly, which means that\n    // not all control flow branches join into one flow at this point.\n    // Consequently we have to continue tracking changes until the point where\n    // all the branches come together into one.\n    completion = realm.composeWithSavedCompletion(completion);\n  }\n  // return or throw completion\n  if (completion instanceof AbruptCompletion) throw completion;\n  invariant(completion instanceof Value);\n  return completion;\n}\n\nfunction EvaluateCall(\n  ref: Value | Reference,\n  func: Value,\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  if (func instanceof AbstractValue) {\n    let loc = ast.callee.type === \"MemberExpression\" ? ast.callee.property.loc : ast.callee.loc;\n    if (!Value.isTypeCompatibleWith(func.getType(), FunctionValue)) {\n      if (!realm.isInPureScope()) {\n        // If this is not a function, this call might throw which can change the state of the program.\n        // If this is called from a pure function we handle it using evaluateWithPossiblyAbruptCompletion.\n        let error = new CompilerDiagnostic(\"might not be a function\", loc, \"PP0005\", \"RecoverableError\");\n        if (realm.handleError(error) === \"Fail\") throw new FatalError();\n      }\n    } else if (func.kind === \"conditional\") {\n      return callBothFunctionsAndJoinTheirEffects(func.args, ast, strictCode, env, realm);\n    } else {\n      // Assume that it is a safe function. TODO #705: really?\n    }\n    if (realm.isInPureScope()) {\n      // In pure functions we allow abstract functions to throw, which this might.\n      return realm.evaluateWithPossibleThrowCompletion(\n        () => generateRuntimeCall(ref, func, ast, strictCode, env, realm),\n        TypesDomain.topVal,\n        ValuesDomain.topVal\n      );\n    }\n    return generateRuntimeCall(ref, func, ast, strictCode, env, realm);\n  }\n  invariant(func instanceof ConcreteValue);\n\n  // 3. If Type(ref) is Reference and IsPropertyReference(ref) is false and GetReferencedName(ref) is \"eval\", then\n  if (\n    ref instanceof Reference &&\n    !Environment.IsPropertyReference(realm, ref) &&\n    Environment.GetReferencedName(realm, ref) === \"eval\"\n  ) {\n    // a. If SameValue(func, %eval%) is true, then\n    if (SameValue(realm, func, realm.intrinsics.eval)) {\n      // i. Let argList be ? ArgumentListEvaluation(Arguments).\n      let argList = ArgumentListEvaluation(realm, strictCode, env, ast.arguments);\n      // ii. If argList has no elements, return undefined.\n      if (argList.length === 0) return realm.intrinsics.undefined;\n      // iii. Let evalText be the first element of argList.\n      let evalText = argList[0];\n      // iv. If the source code matching this CallExpression is strict code, let strictCaller be true. Otherwise let strictCaller be false.\n      let strictCaller = strictCode;\n      // v. Let evalRealm be the current Realm Record.\n      let evalRealm = realm;\n      // vi. Return ? PerformEval(evalText, evalRealm, strictCaller, true).\n      if (evalText instanceof AbstractValue) {\n        let loc = ast.arguments[0].loc;\n        let error = new CompilerDiagnostic(\"eval argument must be a known value\", loc, \"PP0006\", \"RecoverableError\");\n        if (realm.handleError(error) === \"Fail\") throw new FatalError();\n        // Assume that it is a safe eval with no visible heap changes or abrupt control flow.\n        return generateRuntimeCall(ref, func, ast, strictCode, env, realm);\n      }\n      return Functions.PerformEval(realm, evalText, evalRealm, strictCaller, true);\n    }\n  }\n\n  let thisValue;\n\n  // 4. If Type(ref) is Reference, then\n  if (ref instanceof Reference) {\n    // a. If IsPropertyReference(ref) is true, then\n    if (Environment.IsPropertyReference(realm, ref)) {\n      // i. Let thisValue be GetThisValue(ref).\n      thisValue = GetThisValue(realm, ref);\n    } else {\n      // b. Else, the base of ref is an Environment Record\n      // i. Let refEnv be GetBase(ref).\n      let refEnv = Environment.GetBase(realm, ref);\n      invariant(refEnv instanceof EnvironmentRecord);\n\n      // ii. Let thisValue be refEnv.WithBaseObject().\n      thisValue = refEnv.WithBaseObject();\n    }\n  } else {\n    // 5. Else Type(ref) is not Reference,\n    // a. Let thisValue be undefined.\n    thisValue = realm.intrinsics.undefined;\n  }\n\n  // 6. Let thisCall be this CallExpression.\n  let thisCall = ast;\n\n  // 7. Let tailCall be IsInTailPosition(thisCall). (See 14.6.1)\n  let tailCall = IsInTailPosition(realm, thisCall);\n\n  // 8. Return ? EvaluateDirectCall(func, thisValue, Arguments, tailCall).\n  if (realm.isInPureScope()) {\n    return tryToEvaluateCallOrLeaveAsAbstract(ref, func, ast, strictCode, env, realm, thisValue, tailCall);\n  } else {\n    return EvaluateDirectCall(realm, strictCode, env, ref, func, thisValue, ast.arguments, tailCall);\n  }\n}\n"]}