{"version":3,"sources":["../../src/utils/simplifier.js"],"names":["simplifyAndRefineAbstractValue","realm","isCondition","value","savedHandler","errorHandler","savedIsReadOnly","isReadOnly","isRootSimplification","statistics","simplificationAttempts","inSimplificationPath","diagnostic","errorCode","message","result","simplify","simplifications","e","name","includes","abstractValueImpliesCounter","getType","implies","intrinsics","true","impliesNot","false","loc","expressionLocation","op","kind","x0","args","x00","xx","negate","y0","x","y","equals","mightNotBeTrue","mightNotBeFalse","createFromLogicalOp","distributeConditional","createFromBinaryOp","undefined","simplifyEquality","c0","c","mightBeFalse","mightBeTrue","withCondition","withInverseCondition","notc","createFromUnaryOp","mightBeNumber","cs","xc","createFromConditionalOp","yc","z","pathConditions","length","abstractValue","concreteValues","remainingConcreteValues","concreteValue","push","createAbstractConcreteUnion","create","condition","arg","leftArgs","slice","rightArgs","i","equality","mightNotBeUndefined","mightNotBeNull","cond","xy","mightBeUndefined","makeBoolean","mightBeNull","ToBoolean","v","unsimplifiedNegation","computeUnary","invertedComparison","left","right","invertedLogicalOp"],"mappings":"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","file":"simplifier.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelNodeSourceLocation } from \"babel-types\";\nimport { FatalError, InfeasiblePathError } from \"../errors.js\";\nimport { ValuesDomain } from \"../domains/index.js\";\nimport invariant from \"../invariant.js\";\nimport { Realm } from \"../realm.js\";\nimport { AbstractValue, BooleanValue, ConcreteValue, Value } from \"../values/index.js\";\nimport { Path, To } from \"../singletons.js\";\n\nexport default function simplifyAndRefineAbstractValue(\n  realm: Realm,\n  isCondition: boolean, // The value is only used after converting it to a Boolean\n  value: AbstractValue\n): Value {\n  let savedHandler = realm.errorHandler;\n  let savedIsReadOnly = realm.isReadOnly;\n  realm.isReadOnly = true;\n  let isRootSimplification = false;\n  realm.statistics.simplificationAttempts++;\n\n  if (!realm.inSimplificationPath) {\n    realm.inSimplificationPath = isRootSimplification = true;\n  }\n  try {\n    realm.errorHandler = diagnostic => {\n      if (diagnostic.errorCode === \"PP0029\") {\n        throw new FatalError(`${diagnostic.errorCode}: ${diagnostic.message}`);\n      }\n      throw new FatalError();\n    };\n    let result = simplify(realm, value, isCondition);\n    if (result !== value) realm.statistics.simplifications++;\n    return result;\n  } catch (e) {\n    if (e.name === \"Invariant Violation\") throw e;\n    if (e instanceof FatalError && typeof e.message === \"string\" && e.message.includes(\"PP0029\")) {\n      if (isRootSimplification) {\n        return value;\n      }\n      throw e;\n    }\n    return value;\n  } finally {\n    if (isRootSimplification) {\n      realm.abstractValueImpliesCounter = 0;\n      realm.inSimplificationPath = false;\n    }\n    realm.errorHandler = savedHandler;\n    realm.isReadOnly = savedIsReadOnly;\n  }\n}\n\nfunction simplify(realm, value: Value, isCondition: boolean = false): Value {\n  if (value instanceof ConcreteValue) return value;\n  invariant(value instanceof AbstractValue);\n  if (isCondition || value.getType() === BooleanValue) {\n    if (Path.implies(value)) return realm.intrinsics.true;\n    if (Path.impliesNot(value)) return realm.intrinsics.false;\n  }\n  let loc = value.expressionLocation;\n  let op = value.kind;\n  switch (op) {\n    case \"!\": {\n      let [x0] = value.args;\n      invariant(x0 instanceof AbstractValue);\n      if (x0.kind === \"!\") {\n        invariant(x0 instanceof AbstractValue);\n        let [x00] = x0.args;\n        let xx = simplify(realm, x00, true);\n        if (isCondition || xx.getType() === BooleanValue) return xx;\n      }\n      return negate(realm, x0, loc, value, isCondition);\n    }\n    case \"||\":\n    case \"&&\": {\n      let [x0, y0] = value.args;\n      let x = simplify(realm, x0, isCondition);\n      let y = simplify(realm, y0, isCondition);\n      if (x instanceof AbstractValue && x.equals(y)) return x;\n      // true && y <=> y\n      // true || y <=> true\n      if (!x.mightNotBeTrue()) return op === \"&&\" ? y : x;\n      // (x == false) && y <=> x\n      // false || y <=> y\n      if (!x.mightNotBeFalse()) return op === \"||\" ? y : x;\n      if (isCondition || (x.getType() === BooleanValue && y.getType() === BooleanValue)) {\n        // (x: boolean) && true <=> x\n        // x || true <=> true\n        if (!y.mightNotBeTrue()) return op === \"&&\" ? x : realm.intrinsics.true;\n        // (x: boolean) && false <=> false\n        // (x: boolean) || false <=> x\n        if (!y.mightNotBeFalse()) return op === \"||\" ? x : realm.intrinsics.false;\n      }\n      if (\n        op === \"||\" &&\n        y instanceof AbstractValue &&\n        y.kind === \"||\" &&\n        x.equals(y.args[0]) &&\n        !y.args[1].mightNotBeTrue()\n      )\n        return y;\n      if (x.equals(x0) && y.equals(y0)) return value;\n      return AbstractValue.createFromLogicalOp(realm, (value.kind: any), x, y, loc, isCondition, true);\n    }\n    case \"<\":\n    case \"<=\":\n    case \">\":\n    case \">=\":\n      return distributeConditional(realm, value, isCondition, args =>\n        AbstractValue.createFromBinaryOp(realm, op, args[0], args[1], loc, undefined, isCondition)\n      );\n    case \"==\":\n    case \"!=\":\n    case \"===\":\n    case \"!==\":\n      return simplifyEquality(realm, value);\n    case \"conditional\": {\n      let [c0, x0, y0] = value.args;\n      let c = simplify(realm, c0, true);\n      let x, y;\n      if (c0 instanceof AbstractValue && c.mightBeFalse() && c.mightBeTrue()) {\n        try {\n          x = Path.withCondition(c0, () => simplify(realm, x0, isCondition));\n        } catch (e) {\n          if (e instanceof InfeasiblePathError) {\n            // We now know that c0 cannot be be true on this path\n            return simplify(realm, y0, isCondition);\n          }\n          throw e;\n        }\n        try {\n          y = Path.withInverseCondition(c0, () => simplify(realm, y0, isCondition));\n        } catch (e) {\n          if (e instanceof InfeasiblePathError) {\n            // We now know that c0 cannot be be false on this path\n            return x;\n          }\n          throw e;\n        }\n      }\n      if (x === undefined) x = simplify(realm, x0, isCondition);\n      if (y === undefined) y = simplify(realm, y0, isCondition);\n      if (!c.mightNotBeTrue()) return x;\n      if (!c.mightNotBeFalse()) return y;\n      invariant(c instanceof AbstractValue);\n      if (Path.implies(c)) return x;\n      let notc = AbstractValue.createFromUnaryOp(realm, \"!\", c, true, loc, isCondition, true);\n      if (!notc.mightNotBeTrue()) return y;\n      if (!notc.mightNotBeFalse()) return x;\n      invariant(notc instanceof AbstractValue);\n      if (Path.implies(notc)) return y;\n      if (!isCondition) {\n        if (Path.implies(AbstractValue.createFromBinaryOp(realm, \"===\", value, x))) return x;\n        if (!x.mightBeNumber() && Path.implies(AbstractValue.createFromBinaryOp(realm, \"!==\", value, x))) return y;\n        if (!y.mightBeNumber() && Path.implies(AbstractValue.createFromBinaryOp(realm, \"!==\", value, y))) return x;\n        if (Path.implies(AbstractValue.createFromBinaryOp(realm, \"===\", value, y))) return y;\n      }\n      // c ? x : x <=> x\n      if (x.equals(y)) return x;\n      // x ? x : y <=> x || y\n      let cs = isCondition ? c : simplify(realm, c0);\n      if (cs.equals(x)) return AbstractValue.createFromLogicalOp(realm, \"||\", x, y, loc, isCondition, true);\n      // y ? x : y <=> y && x\n      if (cs.equals(y)) return AbstractValue.createFromLogicalOp(realm, \"&&\", y, x, loc, isCondition, true);\n      // c ? (c ? xx : xy) : y <=> c ? xx : y\n      if (x instanceof AbstractValue && x.kind === \"conditional\") {\n        let [xc, xx] = x.args;\n        if (c.equals(xc))\n          return AbstractValue.createFromConditionalOp(realm, c, xx, y, value.expressionLocation, isCondition, true);\n      }\n      // c ? x : (c ? y : z) : z <=> c ? x : z\n      if (y instanceof AbstractValue && y.kind === \"conditional\") {\n        let [yc, , z] = y.args;\n        if (c.equals(yc))\n          return AbstractValue.createFromConditionalOp(realm, c, x, z, value.expressionLocation, isCondition, true);\n      }\n      if (isCondition || (x.getType() === BooleanValue && y.getType() === BooleanValue)) {\n        // c ? true : false <=> c\n        if (!x.mightNotBeTrue() && !y.mightNotBeFalse()) return c;\n        // c ? false : true <=> !c\n        if (!x.mightNotBeFalse() && !y.mightNotBeTrue())\n          return AbstractValue.createFromUnaryOp(realm, \"!\", c, true, loc, true);\n      }\n      if (c.equals(c0) && x.equals(x0) && y.equals(y0)) return value;\n      return AbstractValue.createFromConditionalOp(realm, c, x, y, value.expressionLocation, isCondition, true);\n    }\n    case \"abstractConcreteUnion\": {\n      // The union of an abstract value with one or more concrete values.\n      if (realm.pathConditions.length === 0) return value;\n      let [abstractValue, ...concreteValues] = value.args;\n      invariant(abstractValue instanceof AbstractValue);\n      let remainingConcreteValues = [];\n      for (let concreteValue of concreteValues) {\n        if (Path.implies(AbstractValue.createFromBinaryOp(realm, \"!==\", value, concreteValue))) continue;\n        if (Path.implies(AbstractValue.createFromBinaryOp(realm, \"===\", value, concreteValue))) return concreteValue;\n        remainingConcreteValues.push(concreteValue);\n      }\n      if (remainingConcreteValues.length === 0) return abstractValue;\n      if (remainingConcreteValues.length === concreteValues.length) return value;\n      return AbstractValue.createAbstractConcreteUnion(realm, abstractValue, ...remainingConcreteValues);\n    }\n    default:\n      return value;\n  }\n}\n\nfunction distributeConditional(\n  realm: Realm,\n  value: AbstractValue,\n  isCondition: boolean,\n  create: (Array<Value>) => Value\n): Value {\n  // Find a conditional argument\n  let condition;\n  let args = value.args;\n  for (let arg of args)\n    if (arg instanceof AbstractValue && arg.kind === \"conditional\") {\n      if (condition === undefined) condition = arg.args[0];\n      else if (condition !== arg.args[0]) return value; // giving up, multiple conditions involved\n    }\n\n  if (condition === undefined) return value; // no conditional found, nothing to do\n\n  // We have at least one conditional argument; if there are more than one, they all share the same condition\n  let leftArgs = args.slice(0);\n  let rightArgs = args.slice(0);\n  for (let i = 0; i < args.length; i++) {\n    let arg = args[i];\n    if (arg instanceof AbstractValue && arg.kind === \"conditional\") {\n      leftArgs[i] = arg.args[1];\n      rightArgs[i] = arg.args[2];\n    }\n  }\n\n  return AbstractValue.createFromConditionalOp(\n    realm,\n    condition,\n    create(leftArgs),\n    create(rightArgs),\n    condition.expressionLocation,\n    isCondition,\n    true\n  );\n}\n\nfunction simplifyEquality(realm: Realm, equality: AbstractValue): Value {\n  let loc = equality.expressionLocation;\n  let op = equality.kind;\n  let [x, y] = equality.args;\n  if (x instanceof ConcreteValue) [x, y] = [y, x];\n  if (x instanceof AbstractValue && x.kind === \"conditional\" && (!y.mightNotBeUndefined() || !y.mightNotBeNull())) {\n    // try to simplify \"(cond ? xx : xy) op undefined/null\" to just \"cond\" or \"!cond\"\n    let [cond, xx, xy] = x.args;\n    invariant(cond instanceof AbstractValue); // otherwise the the conditional should not have been created\n    if (op === \"===\" || op === \"!==\") {\n      // if xx === undefined && xy !== undefined then cond <=> x === undefined\n      if (!y.mightNotBeUndefined() && !xx.mightNotBeUndefined() && !xy.mightBeUndefined())\n        return op === \"===\" ? makeBoolean(realm, cond, loc) : negate(realm, cond, loc);\n      // if xx !== undefined && xy === undefined then !cond <=> x === undefined\n      if (!y.mightNotBeUndefined() && !xx.mightBeUndefined() && !xy.mightNotBeUndefined())\n        return op === \"===\" ? negate(realm, cond, loc) : makeBoolean(realm, cond, loc);\n      // if xx === null && xy !== null then cond <=> x === null\n      if (!y.mightNotBeNull() && !xx.mightNotBeNull() && !xy.mightBeNull())\n        return op === \"===\" ? makeBoolean(realm, cond, loc) : negate(realm, cond, loc);\n      // if xx !== null && xy === null then !cond <=> x === null\n      if (!y.mightNotBeNull() && !xx.mightBeNull() && !xy.mightNotBeNull())\n        return op === \"===\" ? negate(realm, cond, loc) : makeBoolean(realm, cond, loc);\n    } else {\n      invariant(op === \"==\" || op === \"!=\");\n      // if xx cannot be undefined/null and xy is undefined/null then !cond <=> x == undefined/null\n      if (!xx.mightBeUndefined() && !xx.mightBeNull() && (!xy.mightNotBeUndefined() || !xy.mightNotBeNull()))\n        return op === \"==\" ? negate(realm, cond, loc) : makeBoolean(realm, cond, loc);\n      // if xx is undefined/null and xy cannot be undefined/null then cond <=> x == undefined/null\n      if ((!xx.mightNotBeUndefined() || !xx.mightNotBeNull()) && !xy.mightBeUndefined() && !xy.mightBeNull())\n        return op === \"==\" ? makeBoolean(realm, cond, loc) : negate(realm, cond, loc);\n    }\n  }\n  return equality;\n}\n\nfunction makeBoolean(realm: Realm, value: Value, loc: ?BabelNodeSourceLocation = undefined): Value {\n  if (value.getType() === BooleanValue) return value;\n  if (value instanceof ConcreteValue) return new BooleanValue(realm, To.ToBoolean(realm, value));\n  invariant(value instanceof AbstractValue);\n  let v = AbstractValue.createFromUnaryOp(realm, \"!\", value, true, value.expressionLocation);\n  if (v instanceof ConcreteValue) return new BooleanValue(realm, !To.ToBoolean(realm, v));\n  invariant(v instanceof AbstractValue);\n  return AbstractValue.createFromUnaryOp(realm, \"!\", v, true, loc || value.expressionLocation);\n}\n\nfunction negate(\n  realm: Realm,\n  value: Value,\n  loc: ?BabelNodeSourceLocation = undefined,\n  unsimplifiedNegation: void | Value = undefined,\n  isCondition?: boolean\n): Value {\n  if (value instanceof ConcreteValue) return ValuesDomain.computeUnary(realm, \"!\", value);\n  invariant(value instanceof AbstractValue);\n  value = simplify(realm, value, true);\n  if (!value.mightNotBeTrue()) return realm.intrinsics.false;\n  if (!value.mightNotBeFalse()) return realm.intrinsics.true;\n  invariant(value instanceof AbstractValue);\n  if (value.kind === \"!\") {\n    let [x] = value.args;\n    if (isCondition || x.getType() === BooleanValue) return simplify(realm, x, true);\n    if (unsimplifiedNegation !== undefined) return unsimplifiedNegation;\n    return makeBoolean(realm, x, loc);\n  }\n  // If NaN is not an issue, invert binary ops\n  if (value.args.length === 2 && !value.args[0].mightBeNumber() && !value.args[1].mightBeNumber()) {\n    let invertedComparison;\n    switch (value.kind) {\n      case \"===\":\n        invertedComparison = \"!==\";\n        break;\n      case \"==\":\n        invertedComparison = \"!=\";\n        break;\n      case \"!==\":\n        invertedComparison = \"===\";\n        break;\n      case \"!=\":\n        invertedComparison = \"==\";\n        break;\n      case \"<\":\n        invertedComparison = \">=\";\n        break;\n      case \"<=\":\n        invertedComparison = \">\";\n        break;\n      case \">\":\n        invertedComparison = \"<=\";\n        break;\n      case \">=\":\n        invertedComparison = \"<\";\n        break;\n      default:\n        break;\n    }\n    if (invertedComparison !== undefined) {\n      let left = simplify(realm, value.args[0]);\n      let right = simplify(realm, value.args[1]);\n      return AbstractValue.createFromBinaryOp(realm, invertedComparison, left, right, loc || value.expressionLocation);\n    }\n    let invertedLogicalOp;\n    switch (value.kind) {\n      case \"&&\":\n        invertedLogicalOp = \"||\";\n        break;\n      case \"||\":\n        invertedLogicalOp = \"&&\";\n        break;\n      default:\n        break;\n    }\n    if (invertedLogicalOp !== undefined) {\n      let left = negate(realm, value.args[0]);\n      let right = negate(realm, value.args[1]);\n      return AbstractValue.createFromLogicalOp(\n        realm,\n        invertedLogicalOp,\n        left,\n        right,\n        loc || value.expressionLocation,\n        true\n      );\n    }\n  }\n  if (unsimplifiedNegation !== undefined) return unsimplifiedNegation;\n  return AbstractValue.createFromUnaryOp(realm, \"!\", value, true, loc || value.expressionLocation, true);\n}\n"]}