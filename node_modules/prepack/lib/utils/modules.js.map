{"version":3,"sources":["../../src/utils/modules.js"],"names":["t","downgradeErrorsToWarnings","realm","f","savedHandler","errorHandler","handler","e","severity","handleError","ModuleTracer","constructor","modules","logModules","evaluateForEffectsNesting","requireStack","requireSequence","uninitializedModuleIdsRequiredInEvaluateForEffects","Set","getStatistics","log","message","console","map","_","join","beginEvaluateForEffects","state","push","undefined","endEvaluateForEffects","effects","popped","pop","_callRequireAndRecord","moduleIdValue","performCall","length","moduleIds","has","value","completion","incorporateSavedCompletion","stopEffectCapture","warning","location","recordModuleInitialized","_callRequireAndAccelerate","isTopLevelRequire","acceleratedModuleIds","evaluateForEffects","result","nestedModuleId","nestedEffects","tryInitializeModule","accelerateUnsupportedRequires","isModuleInitialized","clear","acceleratedModules","_callRequireAndDelayIfNeeded","diagnostic","currentLocation","add","requireSequenceStart","previousNumDelayedModules","delayedModules","nestedModulesIds","i","createTemporalFromBuildFunction","callExpression","identifier","valueToNode","applyEffects","_tryExtractDependencies","lengthValue","dependencies","logger","elementValue","tryQuery","intrinsics","detourCall","F","thisArgument","argumentsList","newTarget","getRequire","disallowDelayingRequiresOverride","moduleId","delayUnsupportedRequires","logError","getDefine","factoryFunction","factoryFunctionDependencies","set","Modules","_require","_define","Map","initializedModules","tracers","moduleTracer","statistics","resolveInitializedModules","globalInitializedModulesMap","_getGlobalProperty","properties","keys","property","get","moduleValue","descriptor","mightHaveBeenDeleted","size","totalModules","name","active","$GlobalObject","getGetModuleIdIfNodeIsRequireFunction","formalParameters","functions","scope","node","isIdentifier","callee","arguments","argument","isNumericLiteral","isStringLiteral","isMemberExpression","innerName","updateModuleId","newModuleId","getModuleId","memberExpression","object","scopedBinding","getBinding","path","dependencyIndex","Number","isInteger","dependency","kind","doesNotMatter","reference","ResolveBinding","$Environment","IsUnresolvableReference","referencedBase","base","referencedName","binding","bindings","initialized","assignToGlobal","previousDisallowDelayingRequiresOverride","evaluateNodeForEffectsInGlobalEnv","err","initializeMoreModules","count","oldReadOnly","setReadOnly","oldDisallowDelayingRequiresOverride","generator","modifiedBindings","modifiedProperties","createdObjects","empty","escapes"],"mappings":"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","file":"modules.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { GlobalEnvironmentRecord, DeclarativeEnvironmentRecord } from \"../environment.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { Realm, Tracer } from \"../realm.js\";\nimport type { Effects } from \"../realm.js\";\nimport { Get } from \"../methods/index.js\";\nimport { AbruptCompletion, PossiblyNormalCompletion } from \"../completions.js\";\nimport { Environment, Functions } from \"../singletons.js\";\nimport {\n  AbstractValue,\n  Value,\n  FunctionValue,\n  ObjectValue,\n  NumberValue,\n  StringValue,\n  ArrayValue,\n  UndefinedValue,\n  NullValue,\n} from \"../values/index.js\";\nimport * as t from \"babel-types\";\nimport type {\n  BabelNodeIdentifier,\n  BabelNodeLVal,\n  BabelNodeCallExpression,\n  BabelNodeNumericLiteral,\n  BabelNodeStringLiteral,\n  BabelNodeMemberExpression,\n} from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport { Logger } from \"./logger.js\";\nimport { SerializerStatistics } from \"../serializer/statistics.js\";\n\nfunction downgradeErrorsToWarnings(realm: Realm, f: () => any) {\n  let savedHandler = realm.errorHandler;\n  function handler(e) {\n    e.severity = \"Warning\";\n    realm.errorHandler = savedHandler;\n    try {\n      return realm.handleError(e);\n    } finally {\n      realm.errorHandler = handler;\n    }\n  }\n  realm.errorHandler = handler;\n  try {\n    return f();\n  } finally {\n    realm.errorHandler = savedHandler;\n  }\n}\n\nexport class ModuleTracer extends Tracer {\n  constructor(modules: Modules, logModules: boolean) {\n    super();\n    this.modules = modules;\n    this.evaluateForEffectsNesting = 0;\n    this.requireStack = [];\n    this.requireSequence = [];\n    this.logModules = logModules;\n    this.uninitializedModuleIdsRequiredInEvaluateForEffects = new Set();\n  }\n\n  modules: Modules;\n  evaluateForEffectsNesting: number;\n  requireStack: Array<number | string | void>;\n  requireSequence: Array<number | string>;\n  uninitializedModuleIdsRequiredInEvaluateForEffects: Set<number | string>;\n  // We can't say that a module has been initialized if it was initialized in a\n  // evaluate for effects context until we know the effects are applied.\n  logModules: boolean;\n\n  getStatistics(): SerializerStatistics {\n    return this.modules.getStatistics();\n  }\n\n  log(message: string) {\n    if (this.logModules) console.log(`[modules] ${this.requireStack.map(_ => \"  \").join(\"\")}${message}`);\n  }\n\n  beginEvaluateForEffects(state: any) {\n    if (state !== this) {\n      this.log(\">evaluate for effects\");\n      this.evaluateForEffectsNesting++;\n      this.requireStack.push(undefined);\n    }\n  }\n\n  endEvaluateForEffects(state: any, effects: void | Effects) {\n    if (state !== this) {\n      let popped = this.requireStack.pop();\n      invariant(popped === undefined);\n      this.evaluateForEffectsNesting--;\n      this.log(\"<evaluate for effects\");\n    }\n  }\n\n  // If we don't delay unsupported requires, we simply want to record here\n  // when a module gets initialized, and then we return.\n  _callRequireAndRecord(moduleIdValue: number | string, performCall: () => Value) {\n    let realm = this.modules.realm;\n    if (\n      (this.requireStack.length === 0 || this.requireStack[this.requireStack.length - 1] !== moduleIdValue) &&\n      this.modules.moduleIds.has(moduleIdValue)\n    ) {\n      this.requireStack.push(moduleIdValue);\n      try {\n        let value = performCall();\n        // Make this into a join point by suppressing the conditional exception.\n        // TODO: delete this code and let the caller deal with the conditional exception.\n        let completion = Functions.incorporateSavedCompletion(realm, value);\n        if (completion instanceof PossiblyNormalCompletion) {\n          realm.stopEffectCapture(completion);\n          let warning = new CompilerDiagnostic(\n            \"Module import may fail with an exception\",\n            completion.location,\n            \"PP0018\",\n            \"Warning\"\n          );\n          realm.handleError(warning);\n        } else {\n          this.modules.recordModuleInitialized(moduleIdValue, value);\n        }\n        return value;\n      } finally {\n        invariant(this.requireStack.pop() === moduleIdValue);\n      }\n    }\n    return undefined;\n  }\n\n  _callRequireAndAccelerate(\n    isTopLevelRequire: boolean,\n    moduleIdValue: number | string,\n    performCall: () => Value\n  ): void | Effects {\n    let realm = this.modules.realm;\n    let acceleratedModuleIds, effects;\n    do {\n      try {\n        effects = realm.evaluateForEffects(() => performCall(), this, \"_callRequireAndAccelerate\");\n      } catch (e) {\n        e;\n      }\n\n      acceleratedModuleIds = [];\n      if (isTopLevelRequire && effects !== undefined && !(effects.result instanceof AbruptCompletion)) {\n        // We gathered all effects, but didn't apply them yet.\n        // Let's check if there was any call to `require` in a\n        // evaluate-for-effects context. If so, try to initialize\n        // that module right now. Acceleration module initialization in this\n        // way might not actually be desirable, but it works around\n        // general prepack-limitations around joined abstract values involving\n        // conditionals. Long term, Prepack needs to implement a notion of refinement\n        // of conditional abstract values under the known path condition.\n        // Example:\n        //   if (*) require(1); else require(2);\n        //   let x = require(1).X;\n        // =>\n        //   require(1);\n        //   require(2);\n        //   if (*) require(1); else require(2);\n        //   let x = require(1).X;\n\n        for (let nestedModuleId of this.uninitializedModuleIdsRequiredInEvaluateForEffects) {\n          let nestedEffects = this.modules.tryInitializeModule(\n            nestedModuleId,\n            `accelerated initialization of conditional module ${nestedModuleId} as it's required in an evaluate-for-effects context by module ${moduleIdValue}`\n          );\n          if (\n            this.modules.accelerateUnsupportedRequires &&\n            nestedEffects !== undefined &&\n            nestedEffects.result instanceof Value &&\n            this.modules.isModuleInitialized(nestedModuleId)\n          ) {\n            acceleratedModuleIds.push(nestedModuleId);\n          }\n        }\n        this.uninitializedModuleIdsRequiredInEvaluateForEffects.clear();\n        // Keep restarting for as long as we find additional modules to accelerate.\n        if (acceleratedModuleIds.length > 0) {\n          console.log(\n            `restarting require(${moduleIdValue}) after accelerating conditional require calls for ${acceleratedModuleIds.join()}`\n          );\n          this.getStatistics().acceleratedModules += acceleratedModuleIds.length;\n        }\n      }\n    } while (acceleratedModuleIds.length > 0);\n\n    return effects;\n  }\n\n  // If a require fails, recover from it and delay the factory call until runtime\n  // Also, only in this mode, consider \"accelerating\" require calls, see below.\n  _callRequireAndDelayIfNeeded(moduleIdValue: number | string, performCall: () => Value) {\n    let realm = this.modules.realm;\n    this.log(`>require(${moduleIdValue})`);\n    let isTopLevelRequire = this.requireStack.length === 0;\n    if (this.evaluateForEffectsNesting > 0) {\n      if (isTopLevelRequire) {\n        let diagnostic = new CompilerDiagnostic(\n          \"Non-deterministically conditional top-level require not currently supported\",\n          realm.currentLocation,\n          \"PP0017\",\n          \"FatalError\"\n        );\n        realm.handleError(diagnostic);\n        throw new FatalError();\n      } else if (!this.modules.isModuleInitialized(moduleIdValue))\n        // Nested require call: We record that this happened. Just so that\n        // if we discover later this this require call needs to get delayed,\n        // then we still know (some of) which modules it in turn required,\n        // and then we'll later \"accelerate\" requiring them to preserve the\n        // require ordering. See below for more details on acceleration.\n        this.uninitializedModuleIdsRequiredInEvaluateForEffects.add(moduleIdValue);\n\n      return undefined;\n    } else {\n      return downgradeErrorsToWarnings(realm, () => {\n        let result;\n        try {\n          this.requireStack.push(moduleIdValue);\n          let requireSequenceStart = this.requireSequence.length;\n          this.requireSequence.push(moduleIdValue);\n          const previousNumDelayedModules = this.getStatistics().delayedModules;\n          let effects = this._callRequireAndAccelerate(isTopLevelRequire, moduleIdValue, performCall);\n          if (effects === undefined || effects.result instanceof AbruptCompletion) {\n            console.log(`delaying require(${moduleIdValue})`);\n            this.getStatistics().delayedModules = previousNumDelayedModules + 1;\n            // So we are about to emit a delayed require(...) call.\n            // However, before we do that, let's try to require all modules that we\n            // know this delayed require call will require.\n            // This way, we ensure that those modules will be fully initialized\n            // before the require call executes.\n            // TODO #690: More needs to be done to make the delayUnsupportedRequires\n            // feature completely safe. Open issues are:\n            // 1) Side-effects on the heap of delayed factory functions are not discovered or rejected.\n            // 2) While we do process an appropriate list of transitively required modules here,\n            //    it's likely just a subset / prefix of all transivitely required modules, as\n            //    more modules would have been required if the Introspection exception had not been thrown.\n            //    To be correct, those modules would have to be prepacked here as well.\n            //    TODO #798: Watch out for an upcoming change to the __d module declaration where the statically known\n            //    list of dependencies will be announced, so we'll no longer have to guess.\n            let nestedModulesIds = new Set();\n            for (let i = requireSequenceStart; i < this.requireSequence.length; i++) {\n              let nestedModuleId = this.requireSequence[i];\n              if (nestedModulesIds.has(nestedModuleId)) continue;\n              nestedModulesIds.add(nestedModuleId);\n              this.modules.tryInitializeModule(\n                nestedModuleId,\n                `initialization of module ${nestedModuleId} as it's required by module ${moduleIdValue}`\n              );\n            }\n\n            result = AbstractValue.createTemporalFromBuildFunction(realm, Value, [], ([]) =>\n              t.callExpression(t.identifier(\"require\"), [t.valueToNode(moduleIdValue)])\n            );\n          } else {\n            result = effects.result;\n            if (result instanceof Value) {\n              realm.applyEffects(effects, `initialization of module ${moduleIdValue}`);\n              this.modules.recordModuleInitialized(moduleIdValue, result);\n            } else if (result instanceof PossiblyNormalCompletion) {\n              let warning = new CompilerDiagnostic(\n                \"Module import may fail with an exception\",\n                result.location,\n                \"PP0018\",\n                \"Warning\"\n              );\n              realm.handleError(warning);\n              result = result.value;\n              realm.applyEffects(effects, `initialization of module ${moduleIdValue}`);\n            } else {\n              invariant(false);\n            }\n          }\n        } finally {\n          let popped = this.requireStack.pop();\n          invariant(popped === moduleIdValue);\n          this.log(`<require(${moduleIdValue})`);\n        }\n        invariant(result instanceof Value);\n        return result;\n      });\n    }\n  }\n\n  _tryExtractDependencies(value: void | Value): void | Array<Value> {\n    if (value === undefined || value instanceof NullValue || value instanceof UndefinedValue) return [];\n    if (value instanceof ArrayValue) {\n      const realm = this.modules.realm;\n      const lengthValue = Get(realm, value, \"length\");\n      if (lengthValue instanceof NumberValue) {\n        const dependencies = [];\n        const logger = this.modules.logger;\n        for (let i = 0; i < lengthValue.value; i++) {\n          const elementValue = logger.tryQuery(\n            () => Get(realm, ((value: any): ArrayValue), \"\" + i),\n            realm.intrinsics.undefined\n          );\n          dependencies.push(elementValue);\n        }\n        return dependencies;\n      }\n    }\n    return undefined;\n  }\n\n  detourCall(\n    F: FunctionValue,\n    thisArgument: void | Value,\n    argumentsList: Array<Value>,\n    newTarget: void | ObjectValue,\n    performCall: () => Value\n  ): void | Value {\n    if (\n      F === this.modules.getRequire() &&\n      !this.modules.disallowDelayingRequiresOverride &&\n      argumentsList.length === 1\n    ) {\n      // Here, we handle calls of the form\n      //   require(42)\n\n      let moduleId = argumentsList[0];\n      let moduleIdValue;\n      // Do some sanity checks and request require(...) calls with bad arguments\n      if (moduleId instanceof NumberValue || moduleId instanceof StringValue) {\n        moduleIdValue = moduleId.value;\n        if (!this.modules.moduleIds.has(moduleIdValue) && this.modules.delayUnsupportedRequires) {\n          this.modules.logger.logError(moduleId, \"Module referenced by require call has not been defined.\");\n        }\n      } else {\n        if (this.modules.delayUnsupportedRequires) {\n          this.modules.logger.logError(moduleId, \"First argument to require function is not a number or string value.\");\n        }\n        return undefined;\n      }\n\n      if (this.modules.delayUnsupportedRequires) return this._callRequireAndDelayIfNeeded(moduleIdValue, performCall);\n      else return this._callRequireAndRecord(moduleIdValue, performCall);\n    } else if (F === this.modules.getDefine()) {\n      // Here, we handle calls of the form\n      //   __d(factoryFunction, moduleId, dependencyArray)\n\n      if (this.evaluateForEffectsNesting !== 0)\n        this.modules.logger.logError(F, \"Defining a module in nested partial evaluation is not supported.\");\n      let factoryFunction = argumentsList[0];\n      if (factoryFunction instanceof FunctionValue) {\n        let dependencies = this._tryExtractDependencies(argumentsList[2]);\n        if (dependencies !== undefined) this.modules.factoryFunctionDependencies.set(factoryFunction, dependencies);\n        else\n          this.modules.logger.logError(\n            argumentsList[2],\n            \"Third argument to define function is present but not a concrete array.\"\n          );\n      } else\n        this.modules.logger.logError(factoryFunction, \"First argument to define function is not a function value.\");\n      let moduleId = argumentsList[1];\n      if (moduleId instanceof NumberValue || moduleId instanceof StringValue)\n        this.modules.moduleIds.add(moduleId.value);\n      else\n        this.modules.logger.logError(moduleId, \"Second argument to define function is not a number or string value.\");\n    }\n    return undefined;\n  }\n}\n\nexport class Modules {\n  constructor(\n    realm: Realm,\n    logger: Logger,\n    logModules: boolean,\n    delayUnsupportedRequires: boolean,\n    accelerateUnsupportedRequires: boolean\n  ) {\n    this.realm = realm;\n    this.logger = logger;\n    this._require = realm.intrinsics.undefined;\n    this._define = realm.intrinsics.undefined;\n    this.factoryFunctionDependencies = new Map();\n    this.moduleIds = new Set();\n    this.initializedModules = new Map();\n    realm.tracers.push((this.moduleTracer = new ModuleTracer(this, logModules)));\n    this.delayUnsupportedRequires = delayUnsupportedRequires;\n    this.accelerateUnsupportedRequires = accelerateUnsupportedRequires;\n    this.disallowDelayingRequiresOverride = false;\n  }\n\n  realm: Realm;\n  logger: Logger;\n  _require: Value;\n  _define: Value;\n  factoryFunctionDependencies: Map<FunctionValue, Array<Value>>;\n  moduleIds: Set<number | string>;\n  initializedModules: Map<number | string, Value>;\n  active: boolean;\n  delayUnsupportedRequires: boolean;\n  accelerateUnsupportedRequires: boolean;\n  disallowDelayingRequiresOverride: boolean;\n  moduleTracer: ModuleTracer;\n\n  getStatistics(): SerializerStatistics {\n    invariant(this.realm.statistics instanceof SerializerStatistics, \"serialization requires SerializerStatistics\");\n    return this.realm.statistics;\n  }\n\n  resolveInitializedModules(): void {\n    this.initializedModules.clear();\n    let globalInitializedModulesMap = this._getGlobalProperty(\"__initializedModules\");\n    invariant(globalInitializedModulesMap instanceof ObjectValue);\n    for (let moduleId of globalInitializedModulesMap.properties.keys()) {\n      let property = globalInitializedModulesMap.properties.get(moduleId);\n      invariant(property);\n      let moduleValue = property.descriptor && property.descriptor.value;\n      if (moduleValue instanceof Value && !moduleValue.mightHaveBeenDeleted()) {\n        this.initializedModules.set(moduleId, moduleValue);\n      }\n    }\n    this.getStatistics().initializedModules = this.initializedModules.size;\n    this.getStatistics().totalModules = this.moduleIds.size;\n  }\n\n  _getGlobalProperty(name: string): Value {\n    if (this.active) return this.realm.intrinsics.undefined;\n    this.active = true;\n    try {\n      let realm = this.realm;\n      return this.logger.tryQuery(() => Get(realm, realm.$GlobalObject, name), realm.intrinsics.undefined);\n    } finally {\n      this.active = false;\n    }\n  }\n\n  getRequire(): Value {\n    if (!(this._require instanceof FunctionValue)) this._require = this._getGlobalProperty(\"require\");\n    return this._require;\n  }\n\n  getDefine(): Value {\n    if (!(this._define instanceof FunctionValue)) this._define = this._getGlobalProperty(\"__d\");\n    return this._define;\n  }\n\n  // Returns a function that checks if a call node represents a call to a\n  // known require function, and if so, what module id that call indicates.\n  // A known require function call is either of the form\n  //   ... require(42) ...\n  // where require resolves to the global require function, or\n  //   factoryFunction(, require, , , dependencies) {\n  //     ...\n  //       ... require(dependencies[3]) ...\n  // where factoryFunction and dependencies were announced as part of the\n  // global code execution via a global module declaration call such as\n  //   global.__d(factoryFunction, , [0,2,4,6,8])\n  getGetModuleIdIfNodeIsRequireFunction(\n    formalParameters: Array<BabelNodeLVal>,\n    functions: Array<FunctionValue>\n  ): (scope: any, node: BabelNodeCallExpression) => void | number | string {\n    let realm = this.realm;\n    let logger = this.logger;\n    let modules = this;\n    return (scope: any, node: BabelNodeCallExpression) => {\n      // Are we calling a function that has a single name and a single argument?\n      if (!t.isIdentifier(node.callee) || node.arguments.length !== 1) return undefined;\n      let argument = node.arguments[0];\n      if (!argument) return undefined;\n\n      if (!t.isNumericLiteral(argument) && !t.isStringLiteral(argument) && !t.isMemberExpression(argument))\n        return undefined;\n\n      invariant(node.callee);\n      let innerName = ((node.callee: any): BabelNodeIdentifier).name;\n\n      let moduleId;\n\n      // Helper function used to give up if we ever come up with different module ids for different functions\n      let updateModuleId = newModuleId => {\n        if (moduleId !== undefined && moduleId !== newModuleId) return false;\n        moduleId = newModuleId;\n        return true;\n      };\n\n      // Helper function that retrieves module id from call argument, possibly chasing dependency array indirection\n      const getModuleId = (dependencies?: Array<Value>): void | number | string => {\n        if (t.isMemberExpression(argument)) {\n          if (dependencies !== undefined) {\n            let memberExpression = ((argument: any): BabelNodeMemberExpression);\n            if (t.isIdentifier(memberExpression.object)) {\n              let scopedBinding = scope.getBinding(((memberExpression.object: any): BabelNodeIdentifier).name);\n              if (scopedBinding && formalParameters[4] === scopedBinding.path.node) {\n                if (t.isNumericLiteral(memberExpression.property)) {\n                  let dependencyIndex = memberExpression.property.value;\n                  if (\n                    Number.isInteger(dependencyIndex) &&\n                    dependencyIndex >= 0 &&\n                    dependencyIndex < dependencies.length\n                  ) {\n                    let dependency = dependencies[dependencyIndex];\n                    if (dependency instanceof NumberValue || dependency instanceof StringValue) return dependency.value;\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          return ((argument: any): BabelNodeNumericLiteral | BabelNodeStringLiteral).value;\n        }\n      };\n\n      // Let's consider each of the function instances (closures for the same code)\n      for (let f of functions) {\n        // 1. Let's check if we have a match for a factory function like\n        //      factoryFunction(, require, , , [dependencies])\n        //    which is used with the Metro bundler\n        let scopedBinding = scope.getBinding(innerName);\n        if (scopedBinding) {\n          let dependencies = modules.factoryFunctionDependencies.get(f);\n          if (dependencies !== undefined && formalParameters[1] === scopedBinding.path.node) {\n            invariant(scopedBinding.kind === \"param\");\n            let newModuleId = getModuleId(dependencies);\n            if (newModuleId !== undefined && !updateModuleId(newModuleId)) return undefined;\n            continue;\n          }\n\n          // The name binds to some local entity, but nothing we'd know what exactly it is\n          return undefined;\n        }\n\n        // 2. Let's check if we can resolve the called function just by looking at the\n        //    function instance environment.\n        //    TODO: We should not do this if the current node is in a nested function!\n\n        // We won't have a dependency map here, so this only works for literal arguments.\n        if (!t.isNumericLiteral(argument) && !t.isStringLiteral(argument)) return undefined;\n\n        let doesNotMatter = true;\n        let reference = logger.tryQuery(\n          () => Environment.ResolveBinding(realm, innerName, doesNotMatter, f.$Environment),\n          undefined\n        );\n        if (reference === undefined) {\n          // We couldn't resolve as we came across some behavior that we cannot deal with abstractly\n          return undefined;\n        }\n        if (Environment.IsUnresolvableReference(realm, reference)) return undefined;\n        let referencedBase = reference.base;\n        let referencedName: string = (reference.referencedName: any);\n        if (typeof referencedName !== \"string\") return undefined;\n        let value;\n        if (reference.base instanceof GlobalEnvironmentRecord) {\n          value = logger.tryQuery(() => Get(realm, realm.$GlobalObject, innerName), realm.intrinsics.undefined);\n        } else {\n          invariant(referencedBase instanceof DeclarativeEnvironmentRecord);\n          let binding = referencedBase.bindings[referencedName];\n          if (!binding.initialized) return undefined;\n          value = binding.value;\n        }\n        if (value !== modules.getRequire()) return undefined;\n        const newModuleId = getModuleId();\n        invariant(newModuleId !== undefined);\n        if (!updateModuleId(newModuleId)) return undefined;\n      }\n\n      return moduleId;\n    };\n  }\n\n  recordModuleInitialized(moduleId: number | string, value: Value) {\n    this.realm.assignToGlobal(\n      t.memberExpression(\n        t.memberExpression(t.identifier(\"global\"), t.identifier(\"__initializedModules\")),\n        t.identifier(\"\" + moduleId)\n      ),\n      value\n    );\n  }\n\n  tryInitializeModule(moduleId: number | string, message: string): void | Effects {\n    let realm = this.realm;\n    let previousDisallowDelayingRequiresOverride = this.disallowDelayingRequiresOverride;\n    this.disallowDelayingRequiresOverride = true;\n    return downgradeErrorsToWarnings(realm, () => {\n      try {\n        let node = t.callExpression(t.identifier(\"require\"), [t.valueToNode(moduleId)]);\n\n        let effects = realm.evaluateNodeForEffectsInGlobalEnv(node);\n        realm.applyEffects(effects, message);\n        return effects;\n      } catch (err) {\n        if (err instanceof FatalError) return undefined;\n        else throw err;\n      } finally {\n        this.disallowDelayingRequiresOverride = previousDisallowDelayingRequiresOverride;\n      }\n    });\n  }\n\n  initializeMoreModules() {\n    // partially evaluate all factory methods by calling require\n    let count = 0;\n    for (let moduleId of this.moduleIds) {\n      if (this.initializedModules.has(moduleId)) continue;\n      let effects = this.tryInitializeModule(moduleId, `Speculative initialization of module ${moduleId}`);\n      if (effects === undefined) continue;\n      let result = effects.result;\n      if (!(result instanceof Value)) continue; // module might throw\n      count++;\n      this.initializedModules.set(moduleId, result);\n    }\n    if (count > 0) console.log(`=== speculatively initialized ${count} additional modules`);\n  }\n\n  isModuleInitialized(moduleId: number | string): void | Value {\n    let realm = this.realm;\n    let oldReadOnly = realm.setReadOnly(true);\n    let oldDisallowDelayingRequiresOverride = this.disallowDelayingRequiresOverride;\n    this.disallowDelayingRequiresOverride = true;\n    try {\n      let node = t.callExpression(t.identifier(\"require\"), [t.valueToNode(moduleId)]);\n\n      let {\n        result,\n        generator,\n        modifiedBindings,\n        modifiedProperties,\n        createdObjects,\n      } = realm.evaluateNodeForEffectsInGlobalEnv(node);\n      // for lint unused\n      invariant(modifiedBindings);\n\n      if (result instanceof AbruptCompletion) return undefined;\n      invariant(result instanceof Value);\n\n      if (!generator.empty() || (result instanceof ObjectValue && createdObjects.has(result))) return undefined;\n      // Check for escaping property assignments, if none escape, we got an existing object\n      let escapes = false;\n      for (let [binding] of modifiedProperties) {\n        let object = binding.object;\n        invariant(object instanceof ObjectValue);\n        if (!createdObjects.has(object)) escapes = true;\n      }\n      if (escapes) return undefined;\n\n      return result;\n    } catch (err) {\n      if (err instanceof FatalError) return undefined;\n      throw err;\n    } finally {\n      realm.setReadOnly(oldReadOnly);\n      this.disallowDelayingRequiresOverride = oldDisallowDelayingRequiresOverride;\n    }\n  }\n}\n"]}