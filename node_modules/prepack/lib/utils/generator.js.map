{"version":3,"sources":["../../src/utils/generator.js"],"names":["t","GeneratorEntry","visit","callbacks","containingGenerator","serialize","context","getDependencies","TemporalBuildNodeEntry","constructor","args","Object","assign","isPure","declared","canSkip","recordDelayedEntry","recordDeclaration","i","n","length","visitEquivalentValue","dependencies","dependency","visitGenerator","canOmit","nodes","map","boundArg","serializeValue","buildNode","valuesToProcess","Set","node","type","block","statements","body","undefined","options","debugScopes","s","emptyStatement","leadingComments","value","intrinsicName","emit","processValues","declare","ModifiedPropertyEntry","desc","propertyBinding","descriptor","newDescriptor","emitPropertyModification","visitModifiedObjectProperty","ModifiedBindingEntry","residualFunctionBinding","referentialized","serializedValue","newValue","bindingReference","isLVal","serializedNewValue","expressionStatement","assignmentExpression","modifiedBinding","residualBinding","visitModifiedBinding","ReturnValueEntry","generator","returnValue","promoteEmptyToUndefined","result","returnStatement","IfThenElseEntry","completion","realm","condition","joinCondition","consequentGenerator","Generator","fromEffects","consequentEffects","alternateGenerator","alternateEffects","consequentBody","serializeGenerator","alternateBody","ifStatement","blockStatement","BindingAssignmentEntry","binding","serializeBinding","visitBindingAssignment","serializeBody","name","effects","useAbstractInterpretation","realmPreludeGenerator","preludeGenerator","_entries","id","nextGeneratorId","_name","effectsToApply","pathConditions","concat","_generatorOfEffects","environmentRecordIdAfterGlobalCode","modifiedBindings","modifiedProperties","createdObjects","output","appendGenerator","keys","object","has","refuseSerialization","isIntrinsic","environment","emitBindingModification","emitReturnValue","emitIfThenElse","emitThrow","withEffectsAppliedInGlobalEnv","bind","kind","c","x","y","ydesc","yprop","xdesc","key","xprop","push","getName","getAsPropertyNameExpression","canBeIdentifier","index","Number","parseInt","toString","numericLiteral","keyIsAscii","test","isValidIdentifier","identifier","stringLiteral","empty","emitGlobalDeclaration","declaredGlobals","add","emitGlobalAssignment","_addEntry","valueNode","globalReference","emitConcreteModel","emitGlobalDelete","unaryExpression","emitBindingAssignment","emitPropertyAssignment","propName","objectNode","memberExpression","isIdentifier","emitDefineProperty","isDescChanged","enumerable","configurable","writable","descValue","$Realm","intrinsics","get","set","_","emitDefinePropertyBody","emitPropertyDelete","emitCall","createCallee","values","callExpression","emitConsoleLog","method","v","emitDoWhileStatement","testId","doWhileStatement","emitConditionalThrow","trueBranch","falseBranch","branchToGenerator","branch","consequent","alternate","joinGenerators","_issueThrowCompilerDiagnostic","message","objectMessage","evaluateWithUndo","_SafeGetDataPropertyValue","objectStack","diagnostic","expressionLocation","handleError","emitStatement","argument","throwStatement","emitFullInvariant","propertyIdentifier","computed","accessedPropertyOf","isTop","concreteComparisons","typeComparisons","populateComparisonsLists","absValue","nestedValue","getType","checks","concreteValue","binaryExpression","valueToNode","typeValue","typeString","typeToString","reduce","expr","newCondition","logicalExpression","_emitInvariant","objnode","getErrorStatement","invariantMode","newExpression","memoizeReference","targetReference","indexOf","substr","isNaN","emitPropertyInvariant","state","violationConditionFn","appendLastToInvariantFn","invariantLevel","messageComponents","nextInvariantId","last","pop","throwString","emitCallAndCaptureResult","types","deriveAbstract","buildNode_","emitVoidExpression","Function","emitForInStatement","o","lh","sourceObject","targetObject","boundName","obj","tgt","src","obj1","tgt1","src1","forInStatement","deriveConcrete","buildValue","optionalArgs","nameGenerator","generate","derivedIds","intrinsicNameGenerated","_isScopedTemplate","variableDeclaration","variableDeclarator","Constructor","isTypeCompatibleWith","res","size","skipInvariant","typeofString","visitFn","entry","serializeFn","initGenerator","finalizeGenerator","other","leadingComment","statement","composeGenerators","generator1","generator2","statements1","statements2","cond","block1","block2","escapeInvalidIdentifierCharacters","charCodeAt","base62characters","base62encode","f","NameGenerator","forbiddenNames","debugNames","uniqueSuffix","prefix","uidCounter","debugSuffix","PreludeGenerator","prelude","Map","memoizedRefs","usesThis","createNameGenerator","convertStringToMember","str","split","thisExpression","prop","globalScope","keyNode","ref","init","includes","lastIndexOf"],"mappings":"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","file":"generator.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Effects, Realm } from \"../realm.js\";\nimport type { ConsoleMethodTypes, Descriptor, PropertyBinding } from \"../types.js\";\nimport type { ResidualFunctionBinding } from \"../serializer/types.js\";\nimport type { Binding } from \"../environment.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  type AbstractValueKind,\n  BooleanValue,\n  ConcreteValue,\n  FunctionValue,\n  NullValue,\n  NumberValue,\n  IntegralValue,\n  ObjectValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport { CompilerDiagnostic } from \"../errors.js\";\nimport type { AbstractValueBuildNodeFunction } from \"../values/AbstractValue.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport * as t from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport {\n  Completion,\n  AbruptCompletion,\n  JoinedAbruptCompletions,\n  ThrowCompletion,\n  ReturnCompletion,\n  PossiblyNormalCompletion,\n} from \"../completions.js\";\nimport type {\n  BabelNodeExpression,\n  BabelNodeIdentifier,\n  BabelNodeThisExpression,\n  BabelNodeStatement,\n  BabelNodeMemberExpression,\n  BabelNodeVariableDeclaration,\n  BabelNodeBlockStatement,\n  BabelNodeLVal,\n} from \"babel-types\";\nimport { nullExpression } from \"./internalizer.js\";\nimport { Utils, concretize } from \"../singletons.js\";\nimport type { SerializerOptions } from \"../options.js\";\n\nexport type SerializationContext = {|\n  serializeValue: Value => BabelNodeExpression,\n  serializeBinding: Binding => BabelNodeIdentifier | BabelNodeMemberExpression,\n  serializeGenerator: (Generator, Set<AbstractValue | ConcreteValue>) => Array<BabelNodeStatement>,\n  initGenerator: Generator => void,\n  finalizeGenerator: Generator => void,\n  emitDefinePropertyBody: (ObjectValue, string | SymbolValue, Descriptor) => BabelNodeStatement,\n  emit: BabelNodeStatement => void,\n  processValues: (Set<AbstractValue | ConcreteValue>) => void,\n  canOmit: (AbstractValue | ConcreteValue) => boolean,\n  declare: (AbstractValue | ConcreteValue) => void,\n  emitPropertyModification: PropertyBinding => void,\n  options: SerializerOptions,\n|};\n\nexport type VisitEntryCallbacks = {|\n  visitEquivalentValue: Value => Value,\n  visitGenerator: (Generator, Generator) => void,\n  canSkip: (AbstractValue | ConcreteValue) => boolean,\n  recordDeclaration: (AbstractValue | ConcreteValue) => void,\n  recordDelayedEntry: (Generator, GeneratorEntry) => void,\n  visitModifiedObjectProperty: PropertyBinding => void,\n  visitModifiedBinding: Binding => [ResidualFunctionBinding, Value],\n  visitBindingAssignment: (Binding, Value) => Value,\n|};\n\nexport type DerivedExpressionBuildNodeFunction = (\n  Array<BabelNodeExpression>,\n  SerializationContext,\n  Set<AbstractValue | ConcreteValue>\n) => BabelNodeExpression;\n\nexport type GeneratorBuildNodeFunction = (\n  Array<BabelNodeExpression>,\n  SerializationContext,\n  Set<AbstractValue | ConcreteValue>\n) => BabelNodeStatement;\n\nexport class GeneratorEntry {\n  visit(callbacks: VisitEntryCallbacks, containingGenerator: Generator): boolean {\n    invariant(false, \"GeneratorEntry is an abstract base class\");\n  }\n\n  serialize(context: SerializationContext) {\n    invariant(false, \"GeneratorEntry is an abstract base class\");\n  }\n\n  getDependencies(): void | Array<Generator> {\n    invariant(false, \"GeneratorEntry is an abstract base class\");\n  }\n}\n\ntype TemporalBuildNodeEntryArgs = {\n  declared?: AbstractValue | ConcreteValue,\n  args: Array<Value>,\n  // If we're just trying to add roots for the serializer to notice, we don't need a buildNode.\n  buildNode?: GeneratorBuildNodeFunction,\n  dependencies?: Array<Generator>,\n  isPure?: boolean,\n};\n\nclass TemporalBuildNodeEntry extends GeneratorEntry {\n  constructor(args: TemporalBuildNodeEntryArgs) {\n    super();\n    Object.assign(this, args);\n  }\n\n  declared: void | AbstractValue | ConcreteValue;\n  args: Array<Value>;\n  // If we're just trying to add roots for the serializer to notice, we don't need a buildNode.\n  buildNode: void | GeneratorBuildNodeFunction;\n  dependencies: void | Array<Generator>;\n  isPure: void | boolean;\n\n  visit(callbacks: VisitEntryCallbacks, containingGenerator: Generator): boolean {\n    if (this.isPure && this.declared && callbacks.canSkip(this.declared)) {\n      callbacks.recordDelayedEntry(containingGenerator, this);\n      return false;\n    } else {\n      if (this.declared) callbacks.recordDeclaration(this.declared);\n      for (let i = 0, n = this.args.length; i < n; i++) this.args[i] = callbacks.visitEquivalentValue(this.args[i]);\n      if (this.dependencies)\n        for (let dependency of this.dependencies) callbacks.visitGenerator(dependency, containingGenerator);\n      return true;\n    }\n  }\n\n  serialize(context: SerializationContext) {\n    if (!this.isPure || !this.declared || !context.canOmit(this.declared)) {\n      let nodes = this.args.map((boundArg, i) => context.serializeValue(boundArg));\n      if (this.buildNode) {\n        let valuesToProcess = new Set();\n        let node = this.buildNode(nodes, context, valuesToProcess);\n        if (node.type === \"BlockStatement\") {\n          let block: BabelNodeBlockStatement = (node: any);\n          let statements = block.body;\n          if (statements.length === 0) return;\n          if (statements.length === 1) {\n            node = statements[0];\n          }\n        }\n        let declared = this.declared;\n        if (declared !== undefined && context.options.debugScopes) {\n          let s = t.emptyStatement();\n          s.leadingComments = [({ type: \"BlockComment\", value: `declaring ${declared.intrinsicName || \"?\"}` }: any)];\n          context.emit(s);\n        }\n        context.emit(node);\n        context.processValues(valuesToProcess);\n      }\n      if (this.declared !== undefined) context.declare(this.declared);\n    }\n  }\n\n  getDependencies() {\n    return this.dependencies;\n  }\n}\n\ntype ModifiedPropertyEntryArgs = {|\n  propertyBinding: PropertyBinding,\n  newDescriptor: void | Descriptor,\n  containingGenerator: Generator,\n|};\n\nclass ModifiedPropertyEntry extends GeneratorEntry {\n  constructor(args: ModifiedPropertyEntryArgs) {\n    super();\n    Object.assign(this, args);\n  }\n\n  containingGenerator: Generator;\n  propertyBinding: PropertyBinding;\n  newDescriptor: void | Descriptor;\n\n  serialize(context: SerializationContext) {\n    let desc = this.propertyBinding.descriptor;\n    invariant(desc === this.newDescriptor);\n    context.emitPropertyModification(this.propertyBinding);\n  }\n\n  visit(context: VisitEntryCallbacks, containingGenerator: Generator): boolean {\n    invariant(\n      containingGenerator === this.containingGenerator,\n      \"This entry requires effects to be applied and may not be moved\"\n    );\n    let desc = this.propertyBinding.descriptor;\n    invariant(desc === this.newDescriptor);\n    context.visitModifiedObjectProperty(this.propertyBinding);\n    return true;\n  }\n\n  getDependencies() {\n    return undefined;\n  }\n}\n\ntype ModifiedBindingEntryArgs = {|\n  modifiedBinding: Binding,\n  newValue: void | Value,\n  containingGenerator: Generator,\n|};\n\nclass ModifiedBindingEntry extends GeneratorEntry {\n  constructor(args: ModifiedBindingEntryArgs) {\n    super();\n    Object.assign(this, args);\n  }\n\n  containingGenerator: Generator;\n  modifiedBinding: Binding;\n  newValue: void | Value;\n  residualFunctionBinding: void | ResidualFunctionBinding;\n\n  serialize(context: SerializationContext) {\n    let residualFunctionBinding = this.residualFunctionBinding;\n    invariant(residualFunctionBinding !== undefined);\n    invariant(residualFunctionBinding.referentialized);\n    invariant(\n      residualFunctionBinding.serializedValue,\n      \"ResidualFunctionBinding must be referentialized before serializing a mutation to it.\"\n    );\n    let newValue = this.newValue;\n    invariant(newValue);\n    let bindingReference = ((residualFunctionBinding.serializedValue: any): BabelNodeLVal);\n    invariant(\n      t.isLVal(bindingReference),\n      \"Referentialized values must be LVals even though serializedValues may be any Expression\"\n    );\n    let serializedNewValue = context.serializeValue(newValue);\n    context.emit(t.expressionStatement(t.assignmentExpression(\"=\", bindingReference, serializedNewValue)));\n  }\n\n  visit(context: VisitEntryCallbacks, containingGenerator: Generator): boolean {\n    invariant(\n      containingGenerator === this.containingGenerator,\n      \"This entry requires effects to be applied and may not be moved\"\n    );\n    invariant(this.modifiedBinding.value === this.newValue);\n    let [residualBinding, newValue] = context.visitModifiedBinding(this.modifiedBinding);\n    invariant(this.residualFunctionBinding === undefined || this.residualFunctionBinding === residualBinding);\n    this.residualFunctionBinding = residualBinding;\n    this.newValue = newValue;\n    return true;\n  }\n\n  getDependencies() {\n    return undefined;\n  }\n}\n\nclass ReturnValueEntry extends GeneratorEntry {\n  constructor(generator: Generator, returnValue: Value) {\n    super();\n    this.returnValue = returnValue.promoteEmptyToUndefined();\n    this.containingGenerator = generator;\n  }\n\n  returnValue: Value;\n  containingGenerator: Generator;\n\n  visit(context: VisitEntryCallbacks, containingGenerator: Generator): boolean {\n    invariant(\n      containingGenerator === this.containingGenerator,\n      \"This entry requires effects to be applied and may not be moved\"\n    );\n    this.returnValue = context.visitEquivalentValue(this.returnValue);\n    return true;\n  }\n\n  serialize(context: SerializationContext) {\n    let result = context.serializeValue(this.returnValue);\n    context.emit(t.returnStatement(result));\n  }\n\n  getDependencies() {\n    return undefined;\n  }\n}\n\nclass IfThenElseEntry extends GeneratorEntry {\n  constructor(generator: Generator, completion: PossiblyNormalCompletion | JoinedAbruptCompletions, realm: Realm) {\n    super();\n    this.completion = completion;\n    this.containingGenerator = generator;\n    this.condition = completion.joinCondition;\n\n    this.consequentGenerator = Generator.fromEffects(completion.consequentEffects, realm, \"ConsequentEffects\");\n    this.alternateGenerator = Generator.fromEffects(completion.alternateEffects, realm, \"AlternateEffects\");\n  }\n\n  completion: PossiblyNormalCompletion | JoinedAbruptCompletions;\n  containingGenerator: Generator;\n\n  condition: Value;\n  consequentGenerator: Generator;\n  alternateGenerator: Generator;\n\n  visit(context: VisitEntryCallbacks, containingGenerator: Generator): boolean {\n    invariant(\n      containingGenerator === this.containingGenerator,\n      \"This entry requires effects to be applied and may not be moved\"\n    );\n    this.condition = context.visitEquivalentValue(this.condition);\n    context.visitGenerator(this.consequentGenerator, containingGenerator);\n    context.visitGenerator(this.alternateGenerator, containingGenerator);\n    return true;\n  }\n\n  serialize(context: SerializationContext) {\n    let condition = context.serializeValue(this.condition);\n    let valuesToProcess = new Set();\n    let consequentBody = context.serializeGenerator(this.consequentGenerator, valuesToProcess);\n    let alternateBody = context.serializeGenerator(this.alternateGenerator, valuesToProcess);\n    context.emit(t.ifStatement(condition, t.blockStatement(consequentBody), t.blockStatement(alternateBody)));\n    context.processValues(valuesToProcess);\n  }\n\n  getDependencies() {\n    return [this.consequentGenerator, this.alternateGenerator];\n  }\n}\n\nclass BindingAssignmentEntry extends GeneratorEntry {\n  constructor(binding: Binding, value: Value) {\n    super();\n    this.binding = binding;\n    this.value = value;\n  }\n\n  binding: Binding;\n  value: Value;\n\n  serialize(context: SerializationContext) {\n    context.emit(\n      t.expressionStatement(\n        t.assignmentExpression(\"=\", context.serializeBinding(this.binding), context.serializeValue(this.value))\n      )\n    );\n  }\n\n  visit(context: VisitEntryCallbacks, containingGenerator: Generator): boolean {\n    this.value = context.visitBindingAssignment(this.binding, this.value);\n    return true;\n  }\n\n  getDependencies() {\n    return undefined;\n  }\n}\n\nfunction serializeBody(\n  generator: Generator,\n  context: SerializationContext,\n  valuesToProcess: Set<AbstractValue | ConcreteValue>\n): BabelNodeBlockStatement {\n  let statements = context.serializeGenerator(generator, valuesToProcess);\n  if (statements.length === 1 && statements[0].type === \"BlockStatement\") return (statements[0]: any);\n  return t.blockStatement(statements);\n}\n\nexport class Generator {\n  constructor(realm: Realm, name: string, effects?: Effects) {\n    invariant(realm.useAbstractInterpretation);\n    let realmPreludeGenerator = realm.preludeGenerator;\n    invariant(realmPreludeGenerator);\n    this.preludeGenerator = realmPreludeGenerator;\n    this.realm = realm;\n    this._entries = [];\n    this.id = realm.nextGeneratorId++;\n    this._name = name;\n    this.effectsToApply = effects;\n    this.pathConditions = [].concat(realm.pathConditions);\n  }\n\n  realm: Realm;\n  _entries: Array<GeneratorEntry>;\n  preludeGenerator: PreludeGenerator;\n  effectsToApply: void | Effects;\n  id: number;\n  _name: string;\n  pathConditions: Array<AbstractValue>;\n\n  static _generatorOfEffects(realm: Realm, name: string, environmentRecordIdAfterGlobalCode: number, effects: Effects) {\n    let { result, generator, modifiedBindings, modifiedProperties, createdObjects } = effects;\n\n    let output = new Generator(realm, name, effects);\n    output.appendGenerator(generator, generator._name);\n\n    for (let propertyBinding of modifiedProperties.keys()) {\n      let object = propertyBinding.object;\n      if (object instanceof ObjectValue && createdObjects.has(object)) continue; // Created Object's binding\n      if (object.refuseSerialization) continue; // modification to internal state\n      // modifications to intrinsic objects are tracked in the generator\n      if (object.isIntrinsic()) continue;\n      output.emitPropertyModification(propertyBinding);\n    }\n\n    for (let modifiedBinding of modifiedBindings.keys()) {\n      // TODO: Instead of looking at the environment ids, keep instead track of a createdEnvironmentRecords set,\n      // and only consider bindings here from environment records that already existed, or even better,\n      // ensure upstream that only such bindings are ever added to the modified-bindings set.\n      if (modifiedBinding.environment.id >= environmentRecordIdAfterGlobalCode) continue;\n\n      output.emitBindingModification(modifiedBinding);\n    }\n\n    if (result instanceof UndefinedValue) return output;\n    if (result instanceof Value) {\n      output.emitReturnValue(result);\n    } else if (result instanceof ReturnCompletion) {\n      output.emitReturnValue(result.value);\n    } else if (result instanceof PossiblyNormalCompletion || result instanceof JoinedAbruptCompletions) {\n      output.emitIfThenElse(result, realm);\n    } else if (result instanceof ThrowCompletion) {\n      output.emitThrow(result.value);\n    } else if (result instanceof AbruptCompletion) {\n      // no-op\n    } else {\n      invariant(false);\n    }\n    return output;\n  }\n\n  // Make sure to to fixup\n  // how to apply things around sets of things\n  static fromEffects(\n    effects: Effects,\n    realm: Realm,\n    name: string,\n    environmentRecordIdAfterGlobalCode: number = 0\n  ): Generator {\n    return realm.withEffectsAppliedInGlobalEnv(\n      this._generatorOfEffects.bind(this, realm, name, environmentRecordIdAfterGlobalCode),\n      effects\n    );\n  }\n\n  emitPropertyModification(propertyBinding: PropertyBinding) {\n    invariant(this.effectsToApply !== undefined);\n    let desc = propertyBinding.descriptor;\n    if (desc !== undefined) {\n      let value = desc.value;\n      if (value instanceof AbstractValue) {\n        if (value.kind === \"conditional\") {\n          let [c, x, y] = value.args;\n          if (c instanceof AbstractValue && c.kind === \"template for property name condition\") {\n            let ydesc = Object.assign({}, desc, { value: y });\n            let yprop = Object.assign({}, propertyBinding, { descriptor: ydesc });\n            this.emitPropertyModification(yprop);\n            let xdesc = Object.assign({}, desc, { value: x });\n            let key = c.args[0];\n            invariant(key instanceof AbstractValue);\n            let xprop = Object.assign({}, propertyBinding, { key, descriptor: xdesc });\n            this.emitPropertyModification(xprop);\n            return;\n          }\n        } else if (value.kind === \"template for prototype member expression\") {\n          return;\n        }\n      }\n    }\n    this._entries.push(\n      new ModifiedPropertyEntry({\n        propertyBinding,\n        newDescriptor: desc,\n        containingGenerator: this,\n      })\n    );\n  }\n\n  emitBindingModification(modifiedBinding: Binding) {\n    invariant(this.effectsToApply !== undefined);\n    this._entries.push(\n      new ModifiedBindingEntry({\n        modifiedBinding,\n        newValue: modifiedBinding.value,\n        containingGenerator: this,\n      })\n    );\n  }\n\n  emitReturnValue(result: Value) {\n    this._entries.push(new ReturnValueEntry(this, result));\n  }\n\n  emitIfThenElse(result: PossiblyNormalCompletion | JoinedAbruptCompletions, realm: Realm) {\n    this._entries.push(new IfThenElseEntry(this, result, realm));\n  }\n\n  getName(): string {\n    return `${this._name}(#${this.id})`;\n  }\n\n  getAsPropertyNameExpression(key: string, canBeIdentifier: boolean = true): BabelNodeExpression {\n    // If key is a non-negative numeric string literal, parse it and set it as a numeric index instead.\n    let index = Number.parseInt(key, 10);\n    if (index >= 0 && index.toString() === key) {\n      return t.numericLiteral(index);\n    }\n\n    if (canBeIdentifier) {\n      // TODO #1020: revert this when Unicode identifiers are supported by all targetted JavaScript engines\n      let keyIsAscii = /^[\\u0000-\\u007f]*$/.test(key);\n      if (t.isValidIdentifier(key) && keyIsAscii) return t.identifier(key);\n    }\n\n    return t.stringLiteral(key);\n  }\n\n  empty() {\n    return this._entries.length === 0;\n  }\n\n  emitGlobalDeclaration(key: string, value: Value) {\n    this.preludeGenerator.declaredGlobals.add(key);\n    if (!(value instanceof UndefinedValue)) this.emitGlobalAssignment(key, value);\n  }\n\n  emitGlobalAssignment(key: string, value: Value) {\n    this._addEntry({\n      args: [value],\n      buildNode: ([valueNode]) =>\n        t.expressionStatement(\n          t.assignmentExpression(\"=\", this.preludeGenerator.globalReference(key, false), valueNode)\n        ),\n    });\n  }\n\n  emitConcreteModel(key: string, value: Value) {\n    this._addEntry({\n      args: [concretize(this.realm, value)],\n      buildNode: ([valueNode]) =>\n        t.expressionStatement(\n          t.assignmentExpression(\"=\", this.preludeGenerator.globalReference(key, false), valueNode)\n        ),\n    });\n  }\n\n  emitGlobalDelete(key: string) {\n    this._addEntry({\n      args: [],\n      buildNode: ([]) =>\n        t.expressionStatement(t.unaryExpression(\"delete\", this.preludeGenerator.globalReference(key, false))),\n    });\n  }\n\n  emitBindingAssignment(binding: Binding, value: Value) {\n    this._entries.push(new BindingAssignmentEntry(binding, value));\n  }\n\n  emitPropertyAssignment(object: ObjectValue, key: string, value: Value) {\n    if (object.refuseSerialization) return;\n    let propName = this.getAsPropertyNameExpression(key);\n    this._addEntry({\n      args: [object, value],\n      buildNode: ([objectNode, valueNode]) =>\n        t.expressionStatement(\n          t.assignmentExpression(\"=\", t.memberExpression(objectNode, propName, !t.isIdentifier(propName)), valueNode)\n        ),\n    });\n  }\n\n  emitDefineProperty(object: ObjectValue, key: string, desc: Descriptor, isDescChanged: boolean = true) {\n    if (object.refuseSerialization) return;\n    if (desc.enumerable && desc.configurable && desc.writable && desc.value && !isDescChanged) {\n      let descValue = desc.value;\n      invariant(descValue instanceof Value);\n      this.emitPropertyAssignment(object, key, descValue);\n    } else {\n      desc = Object.assign({}, desc);\n      let descValue = desc.value || object.$Realm.intrinsics.undefined;\n      invariant(descValue instanceof Value);\n      this._addEntry({\n        args: [\n          object,\n          descValue,\n          desc.get || object.$Realm.intrinsics.undefined,\n          desc.set || object.$Realm.intrinsics.undefined,\n        ],\n        buildNode: (_, context: SerializationContext) => context.emitDefinePropertyBody(object, key, desc),\n      });\n    }\n  }\n\n  emitPropertyDelete(object: ObjectValue, key: string) {\n    if (object.refuseSerialization) return;\n    let propName = this.getAsPropertyNameExpression(key);\n    this._addEntry({\n      args: [object],\n      buildNode: ([objectNode]) =>\n        t.expressionStatement(\n          t.unaryExpression(\"delete\", t.memberExpression(objectNode, propName, !t.isIdentifier(propName)))\n        ),\n    });\n  }\n\n  emitCall(createCallee: () => BabelNodeExpression, args: Array<Value>) {\n    this._addEntry({\n      args,\n      buildNode: values => t.expressionStatement(t.callExpression(createCallee(), [...values])),\n    });\n  }\n\n  emitConsoleLog(method: ConsoleMethodTypes, args: Array<string | ConcreteValue>) {\n    this.emitCall(\n      () => t.memberExpression(t.identifier(\"console\"), t.identifier(method)),\n      args.map(v => (typeof v === \"string\" ? new StringValue(this.realm, v) : v))\n    );\n  }\n\n  // test must be a temporal value, which means that it must have a defined intrinsicName\n  emitDoWhileStatement(test: AbstractValue, body: Generator) {\n    this._addEntry({\n      args: [],\n      buildNode: function([], context, valuesToProcess) {\n        let testId = test.intrinsicName;\n        invariant(testId !== undefined);\n        let statements = context.serializeGenerator(body, valuesToProcess);\n        let block = t.blockStatement(statements);\n        return t.doWhileStatement(t.identifier(testId), block);\n      },\n      dependencies: [body],\n    });\n  }\n\n  emitConditionalThrow(condition: AbstractValue, trueBranch: Completion | Value, falseBranch: Completion | Value) {\n    const branchToGenerator = (name: string, branch: Completion | Value): Generator => {\n      const result = new Generator(this.realm, name);\n      if (branch instanceof JoinedAbruptCompletions || branch instanceof PossiblyNormalCompletion) {\n        result.emitConditionalThrow(branch.joinCondition, branch.consequent, branch.alternate);\n      } else if (branch instanceof ThrowCompletion) {\n        result.emitThrow(branch.value);\n      } else {\n        invariant(branch instanceof ReturnCompletion || branch instanceof Value);\n      }\n      return result;\n    };\n\n    this.joinGenerators(\n      condition,\n      branchToGenerator(\"TrueBranch\", trueBranch),\n      branchToGenerator(\"FalseBranch\", falseBranch)\n    );\n  }\n\n  _issueThrowCompilerDiagnostic(value: Value) {\n    let message = \"Program may terminate with exception\";\n    if (value instanceof ObjectValue) {\n      let object = ((value: any): ObjectValue);\n      let objectMessage = this.realm.evaluateWithUndo(() => object._SafeGetDataPropertyValue(\"message\"));\n      if (objectMessage instanceof StringValue) message += `: ${objectMessage.value}`;\n      const objectStack = this.realm.evaluateWithUndo(() => object._SafeGetDataPropertyValue(\"stack\"));\n      if (objectStack instanceof StringValue)\n        message += `\n  ${objectStack.value}`;\n    }\n    const diagnostic = new CompilerDiagnostic(message, value.expressionLocation, \"PP0023\", \"Warning\");\n    this.realm.handleError(diagnostic);\n  }\n\n  emitThrow(value: Value) {\n    this._issueThrowCompilerDiagnostic(value);\n    this.emitStatement([value], ([argument]) => t.throwStatement(argument));\n  }\n\n  // Checks the full set of possible concrete values as well as typeof\n  // for any AbstractValues\n  // e.g: (obj.property !== undefined && typeof obj.property !== \"object\")\n  // NB: if the type of the AbstractValue is top, skips the invariant\n  emitFullInvariant(object: ObjectValue | AbstractObjectValue, key: string, value: Value) {\n    if (object.refuseSerialization) return;\n    let propertyIdentifier = this.getAsPropertyNameExpression(key);\n    let computed = !t.isIdentifier(propertyIdentifier);\n    let accessedPropertyOf = objectNode => t.memberExpression(objectNode, propertyIdentifier, computed);\n    let condition;\n    if (value instanceof AbstractValue) {\n      let isTop = false;\n      let concreteComparisons = [];\n      let typeComparisons = new Set();\n\n      function populateComparisonsLists(absValue: AbstractValue) {\n        if (absValue.kind === \"abstractConcreteUnion\") {\n          // recurse\n          for (let nestedValue of absValue.args)\n            if (nestedValue instanceof ConcreteValue) {\n              concreteComparisons.push(nestedValue);\n            } else {\n              invariant(nestedValue instanceof AbstractValue);\n              populateComparisonsLists(nestedValue);\n            }\n        } else if (absValue.getType().isTop || absValue.getType() === Value) {\n          isTop = true;\n        } else {\n          typeComparisons.add(absValue.getType());\n        }\n      }\n      populateComparisonsLists(value);\n\n      // No point in doing the invariant if we don't know the type\n      // of one of the nested abstract values\n      if (isTop) {\n        return;\n      } else {\n        condition = ([valueNode]) => {\n          // Create `object.property !== concreteValue`\n          let checks = concreteComparisons.map(concreteValue =>\n            t.binaryExpression(\"!==\", valueNode, t.valueToNode(concreteValue.serialize()))\n          );\n          // Create `typeof object.property !== typeValue`\n          checks = checks.concat(\n            [...typeComparisons].map(typeValue => {\n              let typeString = Utils.typeToString(typeValue);\n              invariant(typeString !== undefined, typeValue);\n              return t.binaryExpression(\n                \"!==\",\n                t.unaryExpression(\"typeof\", valueNode, true),\n                t.stringLiteral(typeString)\n              );\n            })\n          );\n          return checks.reduce((expr, newCondition) => t.logicalExpression(\"&&\", expr, newCondition));\n        };\n        this._emitInvariant([value, value], condition, valueNode => valueNode);\n      }\n    } else if (value instanceof FunctionValue) {\n      // We do a special case for functions,\n      // as we like to use concrete functions in the model to model abstract behaviors.\n      // These concrete functions do not have the right identity.\n      condition = ([objectNode]) =>\n        t.binaryExpression(\n          \"!==\",\n          t.unaryExpression(\"typeof\", accessedPropertyOf(objectNode), true),\n          t.stringLiteral(\"function\")\n        );\n      this._emitInvariant([object, value, object], condition, objnode => accessedPropertyOf(objnode));\n    } else {\n      condition = ([objectNode, valueNode]) => t.binaryExpression(\"!==\", accessedPropertyOf(objectNode), valueNode);\n      this._emitInvariant([object, value, object], condition, objnode => accessedPropertyOf(objnode));\n    }\n  }\n\n  getErrorStatement(message: BabelNodeExpression): BabelNodeStatement {\n    if (this.realm.invariantMode === \"throw\")\n      return t.throwStatement(t.newExpression(this.preludeGenerator.memoizeReference(\"Error\"), [message]));\n    else {\n      let targetReference = this.realm.invariantMode;\n      let args = [message];\n      let i = targetReference.indexOf(\"+\");\n      if (i !== -1) {\n        let s = targetReference.substr(i + 1);\n        let x = Number.parseInt(s, 10);\n        args.push(isNaN(x) ? t.stringLiteral(s) : t.numericLiteral(x));\n        targetReference = targetReference.substr(0, i);\n      }\n      return t.expressionStatement(t.callExpression(this.preludeGenerator.memoizeReference(targetReference), args));\n    }\n  }\n\n  emitPropertyInvariant(\n    object: ObjectValue | AbstractObjectValue,\n    key: string,\n    state: \"MISSING\" | \"PRESENT\" | \"DEFINED\"\n  ) {\n    if (object.refuseSerialization) return;\n    let propertyIdentifier = this.getAsPropertyNameExpression(key);\n    let computed = !t.isIdentifier(propertyIdentifier);\n    let accessedPropertyOf = (objectNode: BabelNodeExpression) =>\n      t.memberExpression(objectNode, propertyIdentifier, computed);\n    let condition = ([objectNode: BabelNodeExpression]) => {\n      let n = t.callExpression(\n        t.memberExpression(\n          this.preludeGenerator.memoizeReference(\"Object.prototype.hasOwnProperty\"),\n          t.identifier(\"call\")\n        ),\n        [objectNode, t.stringLiteral(key)]\n      );\n      if (state !== \"MISSING\") {\n        n = t.unaryExpression(\"!\", n, true);\n        if (state === \"DEFINED\")\n          n = t.logicalExpression(\n            \"||\",\n            n,\n            t.binaryExpression(\"===\", accessedPropertyOf(objectNode), t.valueToNode(undefined))\n          );\n      }\n      return n;\n    };\n\n    this._emitInvariant([object, object], condition, objnode => accessedPropertyOf(objnode));\n  }\n\n  _emitInvariant(\n    args: Array<Value>,\n    violationConditionFn: (Array<BabelNodeExpression>) => BabelNodeExpression,\n    appendLastToInvariantFn?: BabelNodeExpression => BabelNodeExpression\n  ): void {\n    invariant(this.realm.invariantLevel > 0);\n    this._addEntry({\n      args,\n      buildNode: (nodes: Array<BabelNodeExpression>) => {\n        let messageComponents = [\n          t.stringLiteral(\"Prepack model invariant violation (\"),\n          t.numericLiteral(this.preludeGenerator.nextInvariantId++),\n        ];\n        if (appendLastToInvariantFn) {\n          let last = nodes.pop();\n          messageComponents.push(t.stringLiteral(\"): \"));\n          messageComponents.push(appendLastToInvariantFn(last));\n        } else messageComponents.push(t.stringLiteral(\")\"));\n        let throwString = messageComponents[0];\n        for (let i = 1; i < messageComponents.length; i++)\n          throwString = t.binaryExpression(\"+\", throwString, messageComponents[i]);\n        let condition = violationConditionFn(nodes);\n        let consequent = this.getErrorStatement(throwString);\n        return t.ifStatement(condition, consequent);\n      },\n    });\n  }\n\n  emitCallAndCaptureResult(\n    types: TypesDomain,\n    values: ValuesDomain,\n    createCallee: () => BabelNodeExpression,\n    args: Array<Value>,\n    kind?: AbstractValueKind\n  ): AbstractValue {\n    return this.deriveAbstract(types, values, args, (nodes: any) => t.callExpression(createCallee(), nodes), { kind });\n  }\n\n  emitStatement(args: Array<Value>, buildNode_: (Array<BabelNodeExpression>) => BabelNodeStatement) {\n    this._addEntry({\n      args,\n      buildNode: buildNode_,\n    });\n  }\n\n  emitVoidExpression(\n    types: TypesDomain,\n    values: ValuesDomain,\n    args: Array<Value>,\n    buildNode_: AbstractValueBuildNodeFunction | BabelNodeExpression\n  ): UndefinedValue {\n    this._addEntry({\n      args,\n      buildNode: (nodes: Array<BabelNodeExpression>) =>\n        t.expressionStatement(\n          (buildNode_: any) instanceof Function\n            ? ((buildNode_: any): AbstractValueBuildNodeFunction)(nodes)\n            : ((buildNode_: any): BabelNodeExpression)\n        ),\n    });\n    return this.realm.intrinsics.undefined;\n  }\n\n  emitForInStatement(\n    o: ObjectValue | AbstractObjectValue,\n    lh: BabelNodeVariableDeclaration,\n    sourceObject: ObjectValue,\n    targetObject: ObjectValue,\n    boundName: BabelNodeIdentifier\n  ) {\n    this._addEntry({\n      // duplicate args to ensure refcount > 1\n      args: [o, targetObject, sourceObject, targetObject, sourceObject],\n      buildNode: ([obj, tgt, src, obj1, tgt1, src1]) => {\n        return t.forInStatement(\n          lh,\n          obj,\n          t.blockStatement([\n            t.expressionStatement(\n              t.assignmentExpression(\n                \"=\",\n                t.memberExpression(tgt, boundName, true),\n                t.memberExpression(src, boundName, true)\n              )\n            ),\n          ])\n        );\n      },\n    });\n  }\n\n  deriveConcrete(\n    buildValue: (intrinsicName: string) => ConcreteValue,\n    args: Array<Value>,\n    buildNode_: DerivedExpressionBuildNodeFunction | BabelNodeExpression,\n    optionalArgs?: {| isPure?: boolean |}\n  ): ConcreteValue {\n    invariant(buildNode_ instanceof Function || args.length === 0);\n    let id = t.identifier(this.preludeGenerator.nameGenerator.generate(\"derived\"));\n    this.preludeGenerator.derivedIds.set(id.name, args);\n    let value = buildValue(id.name);\n    if (value instanceof ObjectValue) {\n      value.intrinsicNameGenerated = true;\n      value._isScopedTemplate = true; // because this object doesn't exist ahead of time, and the visitor would otherwise declare it in the common scope\n    }\n    this._addEntry({\n      isPure: optionalArgs ? optionalArgs.isPure : undefined,\n      declared: value,\n      args,\n      buildNode: (nodes: Array<BabelNodeExpression>, context: SerializationContext, valuesToProcess) => {\n        return t.variableDeclaration(\"var\", [\n          t.variableDeclarator(\n            id,\n            (buildNode_: any) instanceof Function\n              ? ((buildNode_: any): DerivedExpressionBuildNodeFunction)(nodes, context, valuesToProcess)\n              : ((buildNode_: any): BabelNodeExpression)\n          ),\n        ]);\n      },\n    });\n    return value;\n  }\n\n  deriveAbstract(\n    types: TypesDomain,\n    values: ValuesDomain,\n    args: Array<Value>,\n    buildNode_: DerivedExpressionBuildNodeFunction | BabelNodeExpression,\n    optionalArgs?: {| kind?: AbstractValueKind, isPure?: boolean, skipInvariant?: boolean |}\n  ): AbstractValue {\n    invariant(buildNode_ instanceof Function || args.length === 0);\n    let id = t.identifier(this.preludeGenerator.nameGenerator.generate(\"derived\"));\n    this.preludeGenerator.derivedIds.set(id.name, args);\n    let options = {};\n    if (optionalArgs && optionalArgs.kind) options.kind = optionalArgs.kind;\n    let Constructor = Value.isTypeCompatibleWith(types.getType(), ObjectValue) ? AbstractObjectValue : AbstractValue;\n    let res = new Constructor(\n      this.realm,\n      types,\n      values,\n      1735003607742176 + this.preludeGenerator.derivedIds.size,\n      [],\n      id,\n      options\n    );\n    this._addEntry({\n      isPure: optionalArgs ? optionalArgs.isPure : undefined,\n      declared: res,\n      args,\n      buildNode: (nodes: Array<BabelNodeExpression>, context: SerializationContext, valuesToProcess) => {\n        return t.variableDeclaration(\"var\", [\n          t.variableDeclarator(\n            id,\n            (buildNode_: any) instanceof Function\n              ? ((buildNode_: any): DerivedExpressionBuildNodeFunction)(nodes, context, valuesToProcess)\n              : ((buildNode_: any): BabelNodeExpression)\n          ),\n        ]);\n      },\n    });\n    let type = types.getType();\n    res.intrinsicName = id.name;\n    if (optionalArgs && optionalArgs.skipInvariant) return res;\n    let typeofString;\n    if (type instanceof FunctionValue) typeofString = \"function\";\n    else if (type === UndefinedValue) invariant(false);\n    else if (type === NullValue) invariant(false);\n    else if (type === StringValue) typeofString = \"string\";\n    else if (type === BooleanValue) typeofString = \"boolean\";\n    else if (type === NumberValue) typeofString = \"number\";\n    else if (type === IntegralValue) typeofString = \"number\";\n    else if (type === SymbolValue) typeofString = \"symbol\";\n    else if (type === ObjectValue) typeofString = \"object\";\n    if (typeofString !== undefined && this.realm.invariantLevel >= 1) {\n      // Verify that the types are as expected, a failure of this invariant\n      // should mean the model is wrong.\n      this._emitInvariant(\n        [res, res],\n        nodes => {\n          invariant(typeofString !== undefined);\n          let condition = t.binaryExpression(\n            \"!==\",\n            t.unaryExpression(\"typeof\", nodes[0]),\n            t.stringLiteral(typeofString)\n          );\n          if (typeofString === \"object\") {\n            condition = t.logicalExpression(\n              \"&&\",\n              condition,\n              t.binaryExpression(\"!==\", t.unaryExpression(\"typeof\", nodes[0]), t.stringLiteral(\"function\"))\n            );\n            condition = t.logicalExpression(\"||\", condition, t.binaryExpression(\"===\", nodes[0], nullExpression));\n          }\n          return condition;\n        },\n        node => node\n      );\n    }\n\n    return res;\n  }\n\n  visit(callbacks: VisitEntryCallbacks) {\n    let visitFn = () => {\n      for (let entry of this._entries) entry.visit(callbacks, this);\n      return null;\n    };\n    if (this.effectsToApply) {\n      this.realm.withEffectsAppliedInGlobalEnv(visitFn, this.effectsToApply);\n    } else {\n      visitFn();\n    }\n  }\n\n  serialize(context: SerializationContext) {\n    let serializeFn = () => {\n      context.initGenerator(this);\n      for (let entry of this._entries) entry.serialize(context);\n      context.finalizeGenerator(this);\n      return null;\n    };\n    if (this.effectsToApply) {\n      this.realm.withEffectsAppliedInGlobalEnv(serializeFn, this.effectsToApply);\n    } else {\n      serializeFn();\n    }\n  }\n\n  getDependencies(): Array<Generator> {\n    let res = [];\n    for (let entry of this._entries) {\n      let dependencies = entry.getDependencies();\n      if (dependencies !== undefined) res.push(...dependencies);\n    }\n    return res;\n  }\n\n  // PITFALL Warning: adding a new kind of TemporalBuildNodeEntry that is not the result of a join or composition\n  // will break this purgeEntriesWithGeneratorDepencies.\n  _addEntry(entry: TemporalBuildNodeEntryArgs) {\n    this._entries.push(new TemporalBuildNodeEntry(entry));\n  }\n\n  appendGenerator(other: Generator, leadingComment: string): void {\n    invariant(other !== this);\n    invariant(other.realm === this.realm);\n    invariant(other.preludeGenerator === this.preludeGenerator);\n\n    if (other.empty()) return;\n    if (other.effectsToApply === undefined) {\n      this._entries.push(...other._entries);\n    } else {\n      this._addEntry({\n        args: [],\n        buildNode: function(args, context, valuesToProcess) {\n          let statements = context.serializeGenerator(other, valuesToProcess);\n          if (statements.length === 1) {\n            let statement = statements[0];\n            if (leadingComment.length > 0)\n              statement.leadingComments = [({ type: \"BlockComment\", value: leadingComment }: any)];\n            return statement;\n          }\n          let block = t.blockStatement(statements);\n          if (leadingComment.length > 0)\n            block.leadingComments = [({ type: \"BlockComment\", value: leadingComment }: any)];\n          return block;\n        },\n        dependencies: [other],\n      });\n    }\n  }\n\n  composeGenerators(generator1: Generator, generator2: Generator): void {\n    invariant(generator1 !== this && generator2 !== this && generator1 !== generator2);\n    this._addEntry({\n      args: [],\n      buildNode: function([], context, valuesToProcess) {\n        let statements1 = generator1.empty() ? [] : context.serializeGenerator(generator1, valuesToProcess);\n        let statements2 = generator2.empty() ? [] : context.serializeGenerator(generator2, valuesToProcess);\n        let statements = statements1.concat(statements2);\n        if (statements.length === 1) return statements[0];\n        return t.blockStatement(statements);\n      },\n      dependencies: [generator1, generator2],\n    });\n  }\n\n  joinGenerators(joinCondition: AbstractValue, generator1: Generator, generator2: Generator): void {\n    invariant(generator1 !== this && generator2 !== this && generator1 !== generator2);\n    if (generator1.empty() && generator2.empty()) return;\n    this._addEntry({\n      args: [joinCondition],\n      buildNode: function([cond], context, valuesToProcess) {\n        let block1 = generator1.empty() ? null : serializeBody(generator1, context, valuesToProcess);\n        let block2 = generator2.empty() ? null : serializeBody(generator2, context, valuesToProcess);\n        if (block1) return t.ifStatement(cond, block1, block2);\n        invariant(block2);\n        return t.ifStatement(t.unaryExpression(\"!\", cond), block2);\n      },\n      dependencies: [generator1, generator2],\n    });\n  }\n}\n\nfunction escapeInvalidIdentifierCharacters(s: string) {\n  let res = \"\";\n  for (let c of s)\n    if ((c >= \"0\" && c <= \"9\") || (c >= \"a\" && c <= \"z\") || (c >= \"A\" && c <= \"Z\")) res += c;\n    else res += \"_\" + c.charCodeAt(0);\n  return res;\n}\n\nconst base62characters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\nfunction base62encode(n: number): string {\n  invariant((n | 0) === n && n >= 0);\n  if (n === 0) return \"0\";\n  let s = \"\";\n  while (n > 0) {\n    let f = n % base62characters.length;\n    s = base62characters[f] + s;\n    n = (n - f) / base62characters.length;\n  }\n  return s;\n}\n\nexport class NameGenerator {\n  constructor(forbiddenNames: Set<string>, debugNames: boolean, uniqueSuffix: string, prefix: string) {\n    this.prefix = prefix;\n    this.uidCounter = 0;\n    this.debugNames = debugNames;\n    this.forbiddenNames = forbiddenNames;\n    this.uniqueSuffix = uniqueSuffix;\n  }\n  prefix: string;\n  uidCounter: number;\n  debugNames: boolean;\n  forbiddenNames: Set<string>;\n  uniqueSuffix: string;\n  generate(debugSuffix: ?string): string {\n    let id;\n    do {\n      id = this.prefix + base62encode(this.uidCounter++);\n      if (this.uniqueSuffix.length > 0) id += this.uniqueSuffix;\n      if (this.debugNames) {\n        if (debugSuffix) id += \"_\" + escapeInvalidIdentifierCharacters(debugSuffix);\n        else id += \"_\";\n      }\n    } while (this.forbiddenNames.has(id));\n    return id;\n  }\n}\n\nexport class PreludeGenerator {\n  constructor(debugNames: ?boolean, uniqueSuffix: ?string) {\n    this.prelude = [];\n    this.derivedIds = new Map();\n    this.memoizedRefs = new Map();\n    this.nameGenerator = new NameGenerator(new Set(), !!debugNames, uniqueSuffix || \"\", \"_$\");\n    this.usesThis = false;\n    this.declaredGlobals = new Set();\n    this.nextInvariantId = 0;\n  }\n\n  prelude: Array<BabelNodeStatement>;\n  derivedIds: Map<string, Array<Value>>;\n  memoizedRefs: Map<string, BabelNodeIdentifier>;\n  nameGenerator: NameGenerator;\n  usesThis: boolean;\n  declaredGlobals: Set<string>;\n  nextInvariantId: number;\n\n  createNameGenerator(prefix: string): NameGenerator {\n    return new NameGenerator(\n      this.nameGenerator.forbiddenNames,\n      this.nameGenerator.debugNames,\n      this.nameGenerator.uniqueSuffix,\n      prefix\n    );\n  }\n\n  convertStringToMember(str: string): BabelNodeIdentifier | BabelNodeThisExpression | BabelNodeMemberExpression {\n    return str\n      .split(\".\")\n      .map(name => {\n        if (name === \"global\") {\n          return this.memoizeReference(name);\n        } else if (name === \"this\") {\n          return t.thisExpression();\n        } else {\n          return t.identifier(name);\n        }\n      })\n      .reduce((obj, prop) => t.memberExpression(obj, prop));\n  }\n\n  globalReference(key: string, globalScope: boolean = false) {\n    if (globalScope && t.isValidIdentifier(key)) return t.identifier(key);\n    let keyNode = t.isValidIdentifier(key) ? t.identifier(key) : t.stringLiteral(key);\n    return t.memberExpression(this.memoizeReference(\"global\"), keyNode, !t.isIdentifier(keyNode));\n  }\n\n  memoizeReference(key: string): BabelNodeIdentifier {\n    let ref = this.memoizedRefs.get(key);\n    if (ref) return ref;\n\n    let init;\n    if (key.includes(\"(\") || key.includes(\"[\")) {\n      // Horrible but effective hack:\n      // Some internal object have intrinsic names such as\n      //    ([][Symbol.iterator]().__proto__.__proto__)\n      // and\n      //    RegExp.prototype[Symbol.match]\n      // which get turned into a babel node here.\n      // TODO: We should properly parse such a string, and memoize all references in it separately.\n      // Instead, we just turn it into a funky identifier, which Babel seems to accept.\n      init = t.identifier(key);\n    } else if (key === \"global\") {\n      this.usesThis = true;\n      init = t.thisExpression();\n    } else {\n      let i = key.lastIndexOf(\".\");\n      if (i === -1) {\n        init = t.memberExpression(this.memoizeReference(\"global\"), t.identifier(key));\n      } else {\n        init = t.memberExpression(this.memoizeReference(key.substr(0, i)), t.identifier(key.substr(i + 1)));\n      }\n    }\n    ref = t.identifier(this.nameGenerator.generate(key));\n    this.prelude.push(t.variableDeclaration(\"var\", [t.variableDeclarator(ref, init)]));\n    this.memoizedRefs.set(key, ref);\n    return ref;\n  }\n}\n"]}