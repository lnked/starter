{"version":3,"sources":["../../src/methods/widen.js"],"names":["t","WidenImplementation","_widenArrays","realm","v1","v2","_widenArraysOfValues","_widenArrayOfsMapEntries","a1","a2","n","Math","max","length","result","i","$Key","key1","$Value","val1","undefined","key2","val2","key3","widenValues","val3","wv","widenEffects","e1","e2","widenResults","bindings","widenBindings","modifiedBindings","properties","widenPropertyBindings","modifiedProperties","createdObjects","Set","generator","result1","result2","val","widenMaps","m1","m2","widen","m3","Map","forEach","key","map1","get","set","map2","has","b","b1","b2","l1","hasLeaked","l2","value","intrinsics","kind","phiNode","deriveAbstract","types","values","skipInvariant","intrinsicName","phiName","_buildNode","args","identifier","Array","isArray","throwIfNotConcrete","createFromWidening","c1","c2","d1","d2","object","descriptor","empty","widenDescriptors","rval","pathNode","mightNotBeString","mightNotBeNumber","createFromWidenedProperty","o","memberExpression","p","initVal","emitVoidExpression","v","assignmentExpression","dc","d2value","d1value","containsEffects","containsResults","containsBindings","containsPropertyBindings","_containsValues","containsMap","f","entries","keys","containsBinding","containsPropertyBinding","_containsArray","e","containsArraysOfValue","_containsArrayOfsMapEntries","equals","isTypeCompatibleWith","getType","containsValue"],"mappings":"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","file":"widen.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Binding } from \"../environment.js\";\nimport { FatalError } from \"../errors.js\";\nimport type { Bindings, BindingEntry, EvaluationResult, PropertyBindings, CreatedObjects, Realm } from \"../realm.js\";\nimport { Effects } from \"../realm.js\";\nimport type { Descriptor, PropertyBinding } from \"../types.js\";\n\nimport { AbruptCompletion, PossiblyNormalCompletion } from \"../completions.js\";\nimport { Reference } from \"../environment.js\";\nimport { cloneDescriptor, equalDescriptors, IsDataDescriptor, StrictEqualityComparison } from \"../methods/index.js\";\nimport { Generator } from \"../utils/generator.js\";\nimport { AbstractValue, ArrayValue, EmptyValue, ObjectValue, Value } from \"../values/index.js\";\n\nimport invariant from \"../invariant.js\";\nimport * as t from \"babel-types\";\n\nexport class WidenImplementation {\n  _widenArrays(\n    realm: Realm,\n    v1: Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n    v2: Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>\n  ): Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }> {\n    if (v1[0] instanceof Value) {\n      invariant(v2[0] instanceof Value);\n      return this._widenArraysOfValues(realm, (v1: any), (v2: any));\n    }\n    invariant(!(v2[0] instanceof Value));\n    return this._widenArrayOfsMapEntries(realm, (v1: any), (v2: any));\n  }\n\n  _widenArrayOfsMapEntries(\n    realm: Realm,\n    a1: Array<{ $Key: void | Value, $Value: void | Value }>,\n    a2: Array<{ $Key: void | Value, $Value: void | Value }>\n  ): Array<{ $Key: void | Value, $Value: void | Value }> {\n    let n = Math.max((a1 && a1.length) || 0, (a2 && a2.length) || 0);\n    let result: Array<{ $Key: void | Value, $Value: void | Value }> = [];\n    for (let i = 0; i < n; i++) {\n      let { $Key: key1, $Value: val1 } = a1[i] || { $Key: undefined, $Value: undefined };\n      let { $Key: key2, $Value: val2 } = a2[i] || { $Key: undefined, $Value: undefined };\n      if (key1 === undefined && key2 === undefined) {\n        result[i] = { $Key: undefined, $Value: undefined };\n      } else {\n        if (key1 === undefined) key1 = key2;\n        else if (key2 === undefined) key2 = key1;\n        invariant(key1 !== undefined);\n        invariant(key2 !== undefined);\n        let key3 = this.widenValues(realm, key1, key2);\n        invariant(key3 instanceof Value);\n        if (val1 === undefined && val2 === undefined) {\n          result[i] = { $Key: key3, $Value: undefined };\n        } else {\n          if (val1 === undefined) val1 = val2;\n          else if (val2 === undefined) val2 = val1;\n          invariant(val1 !== undefined);\n          invariant(val2 !== undefined);\n          let val3 = this.widenValues(realm, val1, val2);\n          invariant(val3 === undefined || val3 instanceof Value);\n          result[i] = { $Key: key3, $Value: val3 };\n        }\n      }\n    }\n    return result;\n  }\n\n  _widenArraysOfValues(realm: Realm, a1: Array<Value>, a2: Array<Value>): Array<Value> {\n    let n = Math.max((a1 && a1.length) || 0, (a2 && a2.length) || 0);\n    let result = [];\n    for (let i = 0; i < n; i++) {\n      let wv = this.widenValues(realm, a1[i], a2[i]);\n      invariant(wv === undefined || wv instanceof Value);\n      result[i] = wv;\n    }\n    return result;\n  }\n\n  // Returns a new effects summary that includes both e1 and e2.\n  widenEffects(realm: Realm, e1: Effects, e2: Effects): Effects {\n    let result = this.widenResults(realm, e1.result, e2.result);\n    let bindings = this.widenBindings(realm, e1.modifiedBindings, e2.modifiedBindings);\n    let properties = this.widenPropertyBindings(\n      realm,\n      e1.modifiedProperties,\n      e2.modifiedProperties,\n      e1.createdObjects,\n      e2.createdObjects\n    );\n    let createdObjects = new Set(); // Top, since the empty set knows nothing. There is no other choice for widen.\n    let generator = new Generator(realm, \"widen\"); // code subject to widening will be generated somewhere else\n    return new Effects(result, generator, bindings, properties, createdObjects);\n  }\n\n  widenResults(realm: Realm, result1: EvaluationResult, result2: EvaluationResult): PossiblyNormalCompletion | Value {\n    invariant(!(result1 instanceof Reference || result2 instanceof Reference), \"loop bodies should not result in refs\");\n    invariant(\n      !(result1 instanceof AbruptCompletion || result2 instanceof AbruptCompletion),\n      \"if a loop iteration ends abruptly, there is no need for fixed point computation\"\n    );\n    if (result1 instanceof Value && result2 instanceof Value) {\n      let val = this.widenValues(realm, result1, result2);\n      invariant(val instanceof Value);\n      return val;\n    }\n    if (result1 instanceof PossiblyNormalCompletion || result2 instanceof PossiblyNormalCompletion) {\n      //todo: #1174 figure out how to deal with loops that have embedded conditional exits\n      // widen join pathConditions\n      // widen normal result and Effects\n      // use abrupt part of result2, depend stability to make this safe. See below.\n      throw new FatalError();\n    }\n    invariant(false);\n  }\n\n  widenMaps<K, V>(m1: Map<K, V>, m2: Map<K, V>, widen: (K, void | V, void | V) => V): Map<K, V> {\n    let m3: Map<K, V> = new Map();\n    m1.forEach((val1, key, map1) => {\n      let val2 = m2.get(key);\n      let val3 = widen(key, val1, val2);\n      m3.set(key, val3);\n    });\n    m2.forEach((val2, key, map2) => {\n      if (!m1.has(key)) {\n        m3.set(key, widen(key, undefined, val2));\n      }\n    });\n    return m3;\n  }\n\n  widenBindings(realm: Realm, m1: Bindings, m2: Bindings): Bindings {\n    let widen = (b: Binding, b1: void | BindingEntry, b2: void | BindingEntry) => {\n      let l1 = b1 === undefined ? b.hasLeaked : b1.hasLeaked;\n      let l2 = b2 === undefined ? b.hasLeaked : b2.hasLeaked;\n      let hasLeaked = l1 || l2; // If either has leaked, then this binding has leaked.\n      let v1 = b1 === undefined || b1.value === undefined ? b.value : b1.value;\n      invariant(b2 !== undefined); // Local variables are not going to get deleted as a result of widening\n      let v2 = b2.value;\n      invariant(v2 !== undefined);\n      let result = this.widenValues(realm, v1 || realm.intrinsics.undefined, v2);\n      if (result instanceof AbstractValue && result.kind === \"widened\") {\n        let phiNode = b.phiNode;\n        if (phiNode === undefined) {\n          // Create a temporal location for binding\n          let generator = realm.generator;\n          invariant(generator !== undefined);\n          phiNode = generator.deriveAbstract(\n            result.types,\n            result.values,\n            [b.value || realm.intrinsics.undefined],\n            ([n]) => n,\n            { skipInvariant: true }\n          );\n          b.phiNode = phiNode;\n        }\n        // Let the widened value be a reference to the phiNode of the binding\n        invariant(phiNode.intrinsicName !== undefined);\n        let phiName = phiNode.intrinsicName;\n        result.intrinsicName = phiName;\n        result._buildNode = args => t.identifier(phiName);\n      }\n      invariant(result instanceof Value);\n      return { hasLeaked, value: result };\n    };\n    return this.widenMaps(m1, m2, widen);\n  }\n\n  // Returns an abstract value that includes both v1 and v2 as potential values.\n  widenValues(\n    realm: Realm,\n    v1: Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n    v2: Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>\n  ): Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }> {\n    if (Array.isArray(v1) || Array.isArray(v2)) {\n      invariant(Array.isArray(v1));\n      invariant(Array.isArray(v2));\n      return this._widenArrays(realm, ((v1: any): Array<Value>), ((v2: any): Array<Value>));\n    }\n    invariant(v1 instanceof Value);\n    invariant(v2 instanceof Value);\n    if (\n      !(v1 instanceof AbstractValue) &&\n      !(v2 instanceof AbstractValue) &&\n      StrictEqualityComparison(realm, v1.throwIfNotConcrete(), v2.throwIfNotConcrete())\n    ) {\n      return v1; // no need to widen a loop invariant value\n    } else {\n      invariant(v1 && v2);\n      return AbstractValue.createFromWidening(realm, v1, v2);\n    }\n  }\n\n  widenPropertyBindings(\n    realm: Realm,\n    m1: PropertyBindings,\n    m2: PropertyBindings,\n    c1: CreatedObjects,\n    c2: CreatedObjects\n  ): PropertyBindings {\n    let widen = (b: PropertyBinding, d1: void | Descriptor, d2: void | Descriptor) => {\n      if (d1 === undefined && d2 === undefined) return undefined;\n      // If the PropertyBinding object has been freshly allocated do not widen (that happens in AbstractObjectValue)\n      if (d1 === undefined) {\n        if (b.object instanceof ObjectValue && c2.has(b.object)) return d2; // no widen\n        if (b.descriptor !== undefined && m1.has(b)) {\n          // property was present in (n-1)th iteration and deleted in nth iteration\n          d1 = cloneDescriptor(b.descriptor);\n          invariant(d1 !== undefined);\n          d1.value = realm.intrinsics.empty;\n        } else {\n          // no write to property in nth iteration, use the value from the (n-1)th iteration\n          d1 = b.descriptor;\n          if (d1 === undefined) {\n            d1 = cloneDescriptor(d2);\n            invariant(d1 !== undefined);\n            d1.value = realm.intrinsics.empty;\n          }\n        }\n      }\n      if (d2 === undefined) {\n        if (b.object instanceof ObjectValue && c1.has(b.object)) return d1; // no widen\n        if (m2.has(b)) {\n          // property was present in nth iteration and deleted in (n+1)th iteration\n          d2 = cloneDescriptor(d1);\n          invariant(d2 !== undefined);\n          d2.value = realm.intrinsics.empty;\n        } else {\n          // no write to property in (n+1)th iteration, use the value from the nth iteration\n          d2 = d1;\n        }\n        invariant(d2 !== undefined);\n      }\n      let result = this.widenDescriptors(realm, d1, d2);\n      if (result && result.value instanceof AbstractValue && result.value.kind === \"widened\") {\n        let rval = result.value;\n        let pathNode = b.pathNode;\n        if (pathNode === undefined) {\n          //Since properties already have mutable storage locations associated with them, we do not\n          //need phi nodes. What we need is an abstract value with a build node that results in a memberExpression\n          //that resolves to the storage location of the property.\n\n          // For now, we only handle loop invariant properties\n          //i.e. properties where the member expresssion does not involve any values written to inside the loop.\n          let key = b.key;\n          if (\n            typeof key === \"string\" ||\n            (key instanceof AbstractValue && !(key.mightNotBeString() && key.mightNotBeNumber()))\n          ) {\n            if (typeof key === \"string\") {\n              pathNode = AbstractValue.createFromWidenedProperty(realm, rval, [b.object], ([o]) =>\n                t.memberExpression(o, t.identifier(key))\n              );\n            } else {\n              invariant(key instanceof AbstractValue);\n              pathNode = AbstractValue.createFromWidenedProperty(realm, rval, [b.object, key], ([o, p]) => {\n                return t.memberExpression(o, p, true);\n              });\n            }\n            // The value of the property at the start of the loop needs to be written to the property\n            // before the loop commences, otherwise the memberExpression will result in an undefined value.\n            let generator = realm.generator;\n            invariant(generator !== undefined);\n            let initVal = (b.descriptor && b.descriptor.value) || realm.intrinsics.empty;\n            if (!(initVal instanceof Value)) throw new FatalError(\"todo: handle internal properties\");\n            if (!(initVal instanceof EmptyValue)) {\n              if (key === \"length\" && b.object instanceof ArrayValue) {\n                // do nothing, the array length will already be initialized\n              } else if (typeof key === \"string\") {\n                generator.emitVoidExpression(rval.types, rval.values, [b.object, initVal], ([o, v]) => {\n                  invariant(typeof key === \"string\");\n                  return t.assignmentExpression(\"=\", t.memberExpression(o, t.identifier(key)), v);\n                });\n              } else {\n                invariant(key instanceof AbstractValue);\n                generator.emitVoidExpression(rval.types, rval.values, [b.object, key, initVal], ([o, p, v]) =>\n                  t.assignmentExpression(\"=\", t.memberExpression(o, p, true), v)\n                );\n              }\n            }\n          } else {\n            throw new FatalError(\"todo: handle the case where key is an abstract value\");\n          }\n          b.pathNode = pathNode;\n        }\n        result.value = pathNode;\n      }\n      return result;\n    };\n    return this.widenMaps(m1, m2, widen);\n  }\n\n  widenDescriptors(realm: Realm, d1: void | Descriptor, d2: Descriptor): void | Descriptor {\n    if (d1 === undefined) {\n      // d2 is a property written to only in the (n+1)th iteration\n      if (!IsDataDescriptor(realm, d2)) return d2; // accessor properties need not be widened.\n      let dc = cloneDescriptor(d2);\n      invariant(dc !== undefined);\n      let d2value = dc.value;\n      invariant(d2value !== undefined); // because IsDataDescriptor is true for d2/dc\n      dc.value = this.widenValues(realm, d2value, d2value);\n      return dc;\n    } else {\n      if (equalDescriptors(d1, d2)) {\n        if (!IsDataDescriptor(realm, d1)) return d1; // identical accessor properties need not be widened.\n        // equalDescriptors plus IsDataDescriptor guarantee that both have value props and if you have a value prop is value is defined.\n        let dc = cloneDescriptor(d1);\n        invariant(dc !== undefined);\n        let d1value = d1.value;\n        invariant(d1value !== undefined);\n        let d2value = d2.value;\n        invariant(d2value !== undefined);\n        dc.value = this.widenValues(realm, d1value, d2value);\n        return dc;\n      }\n      //todo: #1174 if we get here, the loop body contains a call to create a property and different iterations\n      // create them differently. That seems beyond what a fixpoint computation can reasonably handle without\n      // losing precision. Report an error here.\n      throw new FatalError();\n    }\n  }\n\n  // If e2 is the result of a loop iteration starting with effects e1 and it has a subset of elements of e1,\n  // then we have reached a fixed point and no further calls to widen are needed. e1/e2 represent a general\n  // summary of the loop, regardless of how many iterations will be performed at runtime.\n  containsEffects(e1: Effects, e2: Effects): boolean {\n    if (!this.containsResults(e1.result, e2.result)) return false;\n    if (!this.containsBindings(e1.modifiedBindings, e2.modifiedBindings)) return false;\n    if (\n      !this.containsPropertyBindings(e1.modifiedProperties, e2.modifiedProperties, e1.createdObjects, e2.createdObjects)\n    )\n      return false;\n    return true;\n  }\n\n  containsResults(result1: EvaluationResult, result2: EvaluationResult): boolean {\n    if (result1 instanceof Value && result2 instanceof Value) return this._containsValues(result1, result2);\n    return false;\n  }\n\n  containsMap<K, V>(m1: Map<K, V>, m2: Map<K, V>, f: (void | V, void | V) => boolean): boolean {\n    for (const [key1, val1] of m1.entries()) {\n      if (val1 === undefined) continue; // deleted\n      let val2 = m2.get(key1);\n      if (val2 === undefined) continue; // A key that disappears has been widened away into the unknown key\n      if (!f(val1, val2)) return false;\n    }\n    for (const key2 of m2.keys()) {\n      if (!m1.has(key2)) return false;\n    }\n    return true;\n  }\n\n  containsBindings(m1: Bindings, m2: Bindings): boolean {\n    let containsBinding = (b1: void | BindingEntry, b2: void | BindingEntry) => {\n      if (\n        b1 === undefined ||\n        b2 === undefined ||\n        b1.value === undefined ||\n        b2.value === undefined ||\n        !this._containsValues(b1.value, b2.value) ||\n        b1.hasLeaked !== b2.hasLeaked\n      ) {\n        return false;\n      }\n      return true;\n    };\n    return this.containsMap(m1, m2, containsBinding);\n  }\n\n  containsPropertyBindings(\n    m1: PropertyBindings,\n    m2: PropertyBindings,\n    c1: CreatedObjects,\n    c2: CreatedObjects\n  ): boolean {\n    let containsPropertyBinding = (d1: void | Descriptor, d2: void | Descriptor) => {\n      let [v1, v2] = [d1 && d1.value, d2 && d2.value];\n      if (v1 === undefined) {\n        return v2 === undefined;\n      }\n      if (v1 instanceof Value && v2 instanceof Value) return this._containsValues(v1, v2);\n      if (Array.isArray(v1) && Array.isArray(v2)) {\n        return this._containsArray(((v1: any): Array<Value>), ((v2: any): Array<Value>));\n      }\n      return v2 === undefined;\n    };\n    for (const [key1, val1] of m1.entries()) {\n      if (val1 === undefined) continue; // deleted\n      let val2 = m2.get(key1);\n      if (val2 === undefined) continue; // A key that disappears has been widened away into the unknown key\n      if (key1.object instanceof ObjectValue && c1.has(key1.object)) {\n        continue;\n      }\n      if (!containsPropertyBinding(val1, val2)) return false;\n    }\n    for (const key2 of m2.keys()) {\n      if (key2.object instanceof ObjectValue && c2.has(key2.object)) {\n        continue;\n      }\n      if (!m1.has(key2)) return false;\n    }\n    return true;\n  }\n\n  _containsArray(\n    v1: void | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n    v2: void | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>\n  ): boolean {\n    let e = (v1 && v1[0]) || (v2 && v2[0]);\n    if (e instanceof Value) return this.containsArraysOfValue((v1: any), (v2: any));\n    else return this._containsArrayOfsMapEntries((v1: any), (v2: any));\n  }\n\n  _containsArrayOfsMapEntries(\n    realm: Realm,\n    a1: void | Array<{ $Key: void | Value, $Value: void | Value }>,\n    a2: void | Array<{ $Key: void | Value, $Value: void | Value }>\n  ): boolean {\n    let empty = realm.intrinsics.empty;\n    let n = Math.max((a1 && a1.length) || 0, (a2 && a2.length) || 0);\n    for (let i = 0; i < n; i++) {\n      let { $Key: key1, $Value: val1 } = (a1 && a1[i]) || { $Key: empty, $Value: empty };\n      let { $Key: key2, $Value: val2 } = (a2 && a2[i]) || { $Key: empty, $Value: empty };\n      if (key1 === undefined) {\n        if (key2 !== undefined) return false;\n      } else {\n        if (key1 instanceof Value && key2 instanceof Value && key1.equals(key2)) {\n          if (val1 instanceof Value && val2 instanceof Value && this._containsValues(val1, val2)) continue;\n        }\n        return false;\n      }\n    }\n    return true;\n  }\n\n  containsArraysOfValue(realm: Realm, a1: void | Array<Value>, a2: void | Array<Value>): boolean {\n    let n = Math.max((a1 && a1.length) || 0, (a2 && a2.length) || 0);\n    for (let i = 0; i < n; i++) {\n      let [val1, val2] = [a1 && a1[i], a2 && a2[i]];\n      if (val1 instanceof Value && val2 instanceof Value && !this._containsValues(val1, val2)) return false;\n    }\n    return true;\n  }\n\n  _containsValues(val1: Value, val2: Value) {\n    if (val1 instanceof AbstractValue) {\n      if (\n        !Value.isTypeCompatibleWith(val2.getType(), val1.getType()) &&\n        !Value.isTypeCompatibleWith(val1.getType(), val2.getType())\n      )\n        return false;\n      return val1.values.containsValue(val2);\n    }\n    return val1.equals(val2);\n  }\n}\n"]}