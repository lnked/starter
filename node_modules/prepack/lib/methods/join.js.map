{"version":3,"sources":["../../src/methods/join.js"],"names":["joinGenerators","realm","joinCondition","generator1","generator2","result","empty","joinArrays","v1","v2","getAbstractValue","e","joinArraysOfValues","joinArrayOfsMapEntries","a1","a2","intrinsics","n","Math","max","length","i","$Key","key1","$Value","val1","key2","val2","undefined","key3","val3","JoinImplementation","stopEffectCaptureJoinApplyAndReturnCompletion","c1","c2","getCapturedEffects","stopEffectCaptureAndUndoEffects","joined_effects","joinPossiblyNormalCompletionWithAbruptCompletion","applyEffects","unbundleNormalCompletion","completionOrValue","completion","value","composeNormalCompletions","leftCompletion","rightCompletion","resultValue","updatePossiblyNormalCompletionWithValue","composePossiblyNormalCompletions","pnc","c","priorEffects","savedEffects","savedPathConditions","consequent","alternate","generator","modifiedBindings","modifiedProperties","createdObjects","alternateEffects","newAlternateEffects","consequentEffects","composeEffects","na","newConsequentEffects","nc","updatePossiblyNormalCompletionWithSubsequentEffects","subsequentEffects","v","ac","joinEffects","alternate_effects","composedEffects","consequent_effects","joinPossiblyNormalCompletionWithValue","joinValuesAsConditional","joinValueWithPossiblyNormalCompletion","joinPossiblyNormalCompletions","a","rJoinCondition","cp","ap","createFromLogicalOp","notA","createFromUnaryOp","notC","ce1","ce2","ae1","ae2","rce","rae","rc","ra","rv","extractAndJoinCompletionsOfType","CompletionType","convertToPNC","emptyEffects","dummyCompletion","ce","transferChildrenToPossiblyNormalCompletion","ae","unbundle","empty_effects","name","removeNormalEffects","e1","e2","mightNotBeTrue","mightNotBeFalse","result1","modifiedBindings1","modifiedProperties1","createdObject1","result2","modifiedBindings2","modifiedProperties2","createdObjects2","joinResults","bindings","joinBindings","properties","joinPropertyBindings","Set","forEach","o","add","joinNestedEffects","precedingEffects","e3","reportIntrospectionError","target","val","joinValues","expressionLocation","location","composeGenerators","joinMaps","m1","m2","join","m3","Map","key","map1","get","set","map2","has","b","b1","b2","l1","hasLeaked","l2","Array","isArray","throwIfNotConcrete","condition","createFromConditionalOp","d1","d2","object","descriptor","joinDescriptors","clone_with_abstract_value","d","d3","dc","dcValue","elem0","map","descriptor2","descriptor1"],"mappings":"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","file":"join.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Binding } from \"../environment.js\";\nimport { FatalError } from \"../errors.js\";\nimport type { Bindings, BindingEntry, EvaluationResult, PropertyBindings, CreatedObjects, Realm } from \"../realm.js\";\nimport { Effects } from \"../realm.js\";\nimport type { Descriptor, PropertyBinding } from \"../types.js\";\n\nimport {\n  AbruptCompletion,\n  BreakCompletion,\n  Completion,\n  ContinueCompletion,\n  PossiblyNormalCompletion,\n  JoinedAbruptCompletions,\n  NormalCompletion,\n  ReturnCompletion,\n  ThrowCompletion,\n} from \"../completions.js\";\nimport { Reference } from \"../environment.js\";\nimport { cloneDescriptor, equalDescriptors, IsDataDescriptor, StrictEqualityComparison } from \"../methods/index.js\";\nimport { construct_empty_effects } from \"../realm.js\";\nimport { Generator } from \"../utils/generator.js\";\nimport { AbstractValue, ObjectValue, Value } from \"../values/index.js\";\n\nimport invariant from \"../invariant.js\";\n\nfunction joinGenerators(\n  realm: Realm,\n  joinCondition: AbstractValue,\n  generator1: Generator,\n  generator2: Generator\n): Generator {\n  let result = new Generator(realm, \"joined\");\n  if (!generator1.empty() || !generator2.empty()) {\n    result.joinGenerators(joinCondition, generator1, generator2);\n  }\n  return result;\n}\n\nfunction joinArrays(\n  realm: Realm,\n  v1: void | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n  v2: void | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n  getAbstractValue: (void | Value, void | Value) => Value\n): Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }> {\n  let e = (v1 && v1[0]) || (v2 && v2[0]);\n  if (e instanceof Value) return joinArraysOfValues(realm, (v1: any), (v2: any), getAbstractValue);\n  else return joinArrayOfsMapEntries(realm, (v1: any), (v2: any), getAbstractValue);\n}\n\nfunction joinArrayOfsMapEntries(\n  realm: Realm,\n  a1: void | Array<{ $Key: void | Value, $Value: void | Value }>,\n  a2: void | Array<{ $Key: void | Value, $Value: void | Value }>,\n  getAbstractValue: (void | Value, void | Value) => Value\n): Array<{ $Key: void | Value, $Value: void | Value }> {\n  let empty = realm.intrinsics.empty;\n  let n = Math.max((a1 && a1.length) || 0, (a2 && a2.length) || 0);\n  let result = [];\n  for (let i = 0; i < n; i++) {\n    let { $Key: key1, $Value: val1 } = (a1 && a1[i]) || { $Key: empty, $Value: empty };\n    let { $Key: key2, $Value: val2 } = (a2 && a2[i]) || { $Key: empty, $Value: empty };\n    if (key1 === undefined && key2 === undefined) {\n      result[i] = { $Key: undefined, $Value: undefined };\n    } else {\n      let key3 = getAbstractValue(key1, key2);\n      let val3 = getAbstractValue(val1, val2);\n      result[i] = { $Key: key3, $Value: val3 };\n    }\n  }\n  return result;\n}\n\nfunction joinArraysOfValues(\n  realm: Realm,\n  a1: void | Array<Value>,\n  a2: void | Array<Value>,\n  getAbstractValue: (void | Value, void | Value) => Value\n): Array<Value> {\n  let n = Math.max((a1 && a1.length) || 0, (a2 && a2.length) || 0);\n  let result = [];\n  for (let i = 0; i < n; i++) {\n    result[i] = getAbstractValue((a1 && a1[i]) || undefined, (a2 && a2[i]) || undefined);\n  }\n  return result;\n}\n\nexport class JoinImplementation {\n  stopEffectCaptureJoinApplyAndReturnCompletion(\n    c1: PossiblyNormalCompletion,\n    c2: AbruptCompletion,\n    realm: Realm\n  ): AbruptCompletion {\n    let e = realm.getCapturedEffects(c1);\n    invariant(e !== undefined);\n    realm.stopEffectCaptureAndUndoEffects(c1);\n    let joined_effects = this.joinPossiblyNormalCompletionWithAbruptCompletion(realm, c1, c2, e);\n    realm.applyEffects(joined_effects);\n    let result = joined_effects.result;\n    invariant(result instanceof AbruptCompletion);\n    return result;\n  }\n\n  unbundleNormalCompletion(\n    completionOrValue: Completion | Value | Reference\n  ): [void | NormalCompletion, Value | Reference] {\n    let completion, value;\n    if (completionOrValue instanceof PossiblyNormalCompletion) {\n      completion = completionOrValue;\n      value = completionOrValue.value;\n    } else {\n      invariant(completionOrValue instanceof Value || completionOrValue instanceof Reference);\n      value = completionOrValue;\n    }\n    return [completion, value];\n  }\n\n  composeNormalCompletions(\n    leftCompletion: void | NormalCompletion,\n    rightCompletion: void | NormalCompletion,\n    resultValue: Value,\n    realm: Realm\n  ): PossiblyNormalCompletion | Value {\n    if (leftCompletion instanceof PossiblyNormalCompletion) {\n      if (rightCompletion instanceof PossiblyNormalCompletion) {\n        this.updatePossiblyNormalCompletionWithValue(realm, rightCompletion, resultValue);\n        return this.composePossiblyNormalCompletions(realm, leftCompletion, rightCompletion);\n      }\n      this.updatePossiblyNormalCompletionWithValue(realm, leftCompletion, resultValue);\n      return leftCompletion;\n    } else if (rightCompletion instanceof PossiblyNormalCompletion) {\n      this.updatePossiblyNormalCompletionWithValue(realm, rightCompletion, resultValue);\n      return rightCompletion;\n    } else {\n      invariant(leftCompletion === undefined && rightCompletion === undefined);\n      return resultValue;\n    }\n  }\n\n  // Note that the resulting completion expects to be returned in a state where its normal effects have been applied\n  composePossiblyNormalCompletions(\n    realm: Realm,\n    pnc: PossiblyNormalCompletion,\n    c: PossiblyNormalCompletion,\n    priorEffects?: Effects\n  ): PossiblyNormalCompletion {\n    invariant(c.savedEffects === undefined); // the caller should ensure this\n    let savedPathConditions = pnc.savedPathConditions;\n    if (pnc.consequent instanceof AbruptCompletion) {\n      if (pnc.alternate instanceof Value) {\n        let { generator, modifiedBindings, modifiedProperties, createdObjects } = pnc.alternateEffects;\n        let newAlternateEffects = new Effects(c, generator, modifiedBindings, modifiedProperties, createdObjects);\n        return new PossiblyNormalCompletion(\n          c.value,\n          pnc.joinCondition,\n          pnc.consequent,\n          pnc.consequentEffects,\n          c,\n          !priorEffects ? newAlternateEffects : realm.composeEffects(priorEffects, newAlternateEffects),\n          savedPathConditions,\n          pnc.savedEffects\n        );\n      }\n      invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n      let na = this.composePossiblyNormalCompletions(realm, pnc.alternate, c, priorEffects);\n      let { generator, modifiedBindings, modifiedProperties, createdObjects } = pnc.alternateEffects;\n      let newAlternateEffects = new Effects(na, generator, modifiedBindings, modifiedProperties, createdObjects);\n      return new PossiblyNormalCompletion(\n        c.value,\n        pnc.joinCondition,\n        pnc.consequent,\n        pnc.consequentEffects,\n        na,\n        newAlternateEffects,\n        savedPathConditions,\n        pnc.savedEffects\n      );\n    } else {\n      invariant(pnc.alternate instanceof AbruptCompletion);\n      if (pnc.consequent instanceof Value) {\n        let { generator, modifiedBindings, modifiedProperties, createdObjects } = pnc.consequentEffects;\n        let newConsequentEffects = new Effects(c, generator, modifiedBindings, modifiedProperties, createdObjects);\n        return new PossiblyNormalCompletion(\n          c.value,\n          pnc.joinCondition,\n          c,\n          !priorEffects ? newConsequentEffects : realm.composeEffects(priorEffects, newConsequentEffects),\n          pnc.alternate,\n          pnc.alternateEffects,\n          savedPathConditions,\n          pnc.savedEffects\n        );\n      }\n      invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n      let nc = this.composePossiblyNormalCompletions(realm, pnc.consequent, c);\n      let { generator, modifiedBindings, modifiedProperties, createdObjects } = pnc.consequentEffects;\n      let newConsequentEffects = new Effects(nc, generator, modifiedBindings, modifiedProperties, createdObjects);\n      return new PossiblyNormalCompletion(\n        c.value,\n        pnc.joinCondition,\n        nc,\n        newConsequentEffects,\n        pnc.alternate,\n        pnc.alternateEffects,\n        savedPathConditions,\n        pnc.savedEffects\n      );\n    }\n  }\n\n  updatePossiblyNormalCompletionWithSubsequentEffects(\n    realm: Realm,\n    pnc: PossiblyNormalCompletion,\n    subsequentEffects: Effects\n  ) {\n    let v = subsequentEffects.result;\n    invariant(v instanceof Value);\n    pnc.value = v;\n    if (pnc.consequent instanceof AbruptCompletion) {\n      if (pnc.alternate instanceof Value) {\n        pnc.alternate = v;\n        pnc.alternateEffects.result = v;\n        pnc.alternateEffects = realm.composeEffects(pnc.alternateEffects, subsequentEffects);\n      } else {\n        invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n        this.updatePossiblyNormalCompletionWithSubsequentEffects(realm, pnc.alternate, subsequentEffects);\n      }\n    } else {\n      if (pnc.consequent instanceof Value) {\n        pnc.consequent = v;\n        pnc.consequentEffects.result = v;\n        pnc.consequentEffects = realm.composeEffects(pnc.consequentEffects, subsequentEffects);\n      } else {\n        invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n        this.updatePossiblyNormalCompletionWithSubsequentEffects(realm, pnc.consequent, subsequentEffects);\n      }\n    }\n  }\n\n  updatePossiblyNormalCompletionWithValue(realm: Realm, pnc: PossiblyNormalCompletion, v: Value) {\n    pnc.value = v;\n    if (pnc.consequent instanceof AbruptCompletion) {\n      if (pnc.alternate instanceof Value) {\n        pnc.alternate = v;\n        pnc.alternateEffects.result = v;\n      } else {\n        invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n        this.updatePossiblyNormalCompletionWithValue(realm, pnc.alternate, v);\n      }\n    } else {\n      if (pnc.consequent instanceof Value) {\n        pnc.consequent = v;\n        pnc.consequentEffects.result = v;\n      } else {\n        invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n        this.updatePossiblyNormalCompletionWithValue(realm, pnc.consequent, v);\n      }\n    }\n  }\n\n  // Returns the joined effects of all of the paths in pnc.\n  // The normal path in pnc is modified to become terminated by ac,\n  // so the overall completion will always be an instance of JoinedAbruptCompletions\n  joinPossiblyNormalCompletionWithAbruptCompletion(\n    realm: Realm,\n    // a forked path with a non abrupt (normal) component\n    pnc: PossiblyNormalCompletion,\n    // an abrupt completion that completes the normal path\n    ac: AbruptCompletion,\n    // effects collected after pnc was constructed\n    e: Effects\n  ): Effects {\n    // set up e with ac as the completion. It's OK to do this repeatedly since ac is not changed by recursive calls.\n    e.result = ac;\n    if (pnc.consequent instanceof AbruptCompletion) {\n      if (pnc.alternate instanceof Value) {\n        return this.joinEffects(\n          realm,\n          pnc.joinCondition,\n          pnc.consequentEffects,\n          realm.composeEffects(pnc.alternateEffects, e)\n        );\n      }\n      invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n      let alternate_effects = this.joinPossiblyNormalCompletionWithAbruptCompletion(realm, pnc.alternate, ac, e);\n      let composedEffects = realm.composeEffects(pnc.alternateEffects, alternate_effects);\n      invariant(pnc.consequent instanceof AbruptCompletion);\n      return this.joinEffects(realm, pnc.joinCondition, pnc.consequentEffects, composedEffects);\n    } else {\n      invariant(pnc.alternate instanceof AbruptCompletion);\n      if (pnc.consequent instanceof Value) {\n        return this.joinEffects(\n          realm,\n          pnc.joinCondition,\n          realm.composeEffects(pnc.consequentEffects, e),\n          pnc.alternateEffects\n        );\n      }\n      invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n      let consequent_effects = this.joinPossiblyNormalCompletionWithAbruptCompletion(realm, pnc.consequent, ac, e);\n      let composedEffects = realm.composeEffects(pnc.consequentEffects, consequent_effects);\n      invariant(pnc.alternate instanceof AbruptCompletion);\n      return this.joinEffects(realm, pnc.joinCondition, composedEffects, pnc.alternateEffects);\n    }\n  }\n\n  joinPossiblyNormalCompletionWithValue(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    pnc: PossiblyNormalCompletion,\n    v: Value\n  ) {\n    if (pnc.consequent instanceof AbruptCompletion) {\n      if (pnc.alternate instanceof Value) {\n        pnc.alternate = this.joinValuesAsConditional(realm, joinCondition, pnc.alternate, v);\n        pnc.alternateEffects.result = pnc.alternate;\n      } else {\n        invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n        this.joinPossiblyNormalCompletionWithValue(realm, joinCondition, pnc.alternate, v);\n      }\n    } else {\n      if (pnc.consequent instanceof Value) {\n        pnc.consequent = this.joinValuesAsConditional(realm, joinCondition, pnc.consequent, v);\n        pnc.consequentEffects.result = pnc.consequent;\n      } else {\n        invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n        this.joinPossiblyNormalCompletionWithValue(realm, joinCondition, pnc.consequent, v);\n      }\n    }\n  }\n\n  joinValueWithPossiblyNormalCompletion(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    pnc: PossiblyNormalCompletion,\n    v: Value\n  ) {\n    if (pnc.consequent instanceof AbruptCompletion) {\n      if (pnc.alternate instanceof Value) {\n        pnc.alternate = this.joinValuesAsConditional(realm, joinCondition, v, pnc.alternate);\n        pnc.alternateEffects.result = pnc.alternate;\n      } else {\n        invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n        this.joinValueWithPossiblyNormalCompletion(realm, joinCondition, pnc.alternate, v);\n      }\n    } else {\n      if (pnc.consequent instanceof Value) {\n        pnc.consequent = this.joinValuesAsConditional(realm, joinCondition, v, pnc.consequent);\n        pnc.consequentEffects.result = pnc.consequent;\n      } else {\n        invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n        this.joinValueWithPossiblyNormalCompletion(realm, joinCondition, pnc.consequent, v);\n      }\n    }\n  }\n\n  joinPossiblyNormalCompletions(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    c: PossiblyNormalCompletion,\n    a: PossiblyNormalCompletion\n  ): PossiblyNormalCompletion {\n    let rJoinCondition: Value;\n    let cp: [Effects, Effects];\n    let ap: [Effects, Effects];\n    if (c.consequent instanceof AbruptCompletion) {\n      if (a.consequent instanceof AbruptCompletion) {\n        rJoinCondition = AbstractValue.createFromLogicalOp(realm, \"&&\", c.joinCondition, a.joinCondition);\n        cp = [c.consequentEffects, a.consequentEffects];\n        ap = [c.alternateEffects, a.alternateEffects];\n      } else {\n        let notA = AbstractValue.createFromUnaryOp(realm, \"!\", a.joinCondition);\n        rJoinCondition = AbstractValue.createFromLogicalOp(realm, \"&&\", c.joinCondition, notA);\n        cp = [c.consequentEffects, a.alternateEffects];\n        ap = [c.alternateEffects, a.consequentEffects];\n      }\n    } else {\n      let notC = AbstractValue.createFromUnaryOp(realm, \"!\", c.joinCondition);\n      if (a.consequent instanceof AbruptCompletion) {\n        rJoinCondition = AbstractValue.createFromLogicalOp(realm, \"&&\", notC, a.joinCondition);\n        cp = [c.alternateEffects, a.consequentEffects];\n        ap = [c.consequentEffects, a.alternateEffects];\n      } else {\n        let notA = AbstractValue.createFromUnaryOp(realm, \"!\", a.joinCondition);\n        rJoinCondition = AbstractValue.createFromLogicalOp(realm, \"&&\", notC, notA);\n        cp = [c.alternateEffects, a.alternateEffects];\n        ap = [c.consequentEffects, a.consequentEffects];\n      }\n    }\n    invariant(rJoinCondition instanceof AbstractValue); // the transformations will not result in tautologies\n    let [ce1, ce2] = cp;\n    let [ae1, ae2] = ap;\n    let rce = this.joinEffects(realm, joinCondition, ce1, ce2);\n    let rae = this.joinEffects(realm, joinCondition, ae1, ae2);\n    let rc = rce.result;\n    invariant(rc instanceof Value || rc instanceof Completion);\n    let ra = rae.result;\n    invariant(ra instanceof Value || ra instanceof Completion);\n    let rv = ra instanceof PossiblyNormalCompletion ? ra.value : ra;\n    invariant(rv instanceof Value);\n    return new PossiblyNormalCompletion(rv, rJoinCondition, rc, rce, ra, rae, []);\n  }\n\n  // Join all effects that result in completions of type CompletionType.\n  // Erase all completions of type Completion type from c, so that we never join them again.\n  // Also erase any generators that appears in branches resulting in completions of type CompletionType.\n  // Note that c is modified in place and should be replaced with a PossiblyNormalCompletion by the caller\n  // if either of its branches cease to be an AbruptCompletion.\n  extractAndJoinCompletionsOfType(\n    CompletionType: typeof AbruptCompletion,\n    realm: Realm,\n    c: AbruptCompletion,\n    convertToPNC: boolean = true\n  ): Effects {\n    let emptyEffects = construct_empty_effects(realm);\n    if (c instanceof CompletionType) {\n      emptyEffects.result = c;\n      return emptyEffects;\n    }\n    if (!(c instanceof JoinedAbruptCompletions)) {\n      return emptyEffects;\n    }\n    let dummyCompletion = new AbruptCompletion(realm.intrinsics.empty);\n    // Join up the consequent and alternate completions and compose them with their prefix effects\n    let ce = this.extractAndJoinCompletionsOfType(CompletionType, realm, c.consequent, convertToPNC);\n    // ce will be applied to the global state before any non joining branches in c.consequent, so move\n    // the generator from c.consequentEffects to ae.generator so that all branches will see its effects.\n    ce = realm.composeEffects(c.consequentEffects, ce);\n    ce.generator = c.consequentEffects.generator;\n    c.consequentEffects.generator = emptyEffects.generator;\n    if (ce.result instanceof CompletionType) {\n      // Erase completions of type CompletionType and prepare for transformation of c to a possibly normal completion\n      if (c.consequent instanceof CompletionType) {\n        c.consequentEffects.result = c.consequent = convertToPNC ? (realm.intrinsics.empty: any) : dummyCompletion;\n        convertToPNC = false;\n      } else if (convertToPNC && c.consequent instanceof JoinedAbruptCompletions) {\n        c.consequentEffects.result = c.consequent = (c.consequent.transferChildrenToPossiblyNormalCompletion(): any);\n        convertToPNC = false;\n      }\n    } else {\n      ce.result = new CompletionType(realm.intrinsics.empty);\n    }\n    let ae = this.extractAndJoinCompletionsOfType(CompletionType, realm, c.alternate, convertToPNC);\n    // ae will be applied to the global state before any non joining branches in c.alternate, so move\n    // the generator from c.alternateEffects to ae.generator so that all branches will see its effects.\n    ae = realm.composeEffects(c.alternateEffects, ae);\n    ae.generator = c.alternateEffects.generator;\n    c.alternateEffects.generator = emptyEffects.generator;\n    if (ae.result instanceof CompletionType) {\n      // Erase completions of type CompletionType and prepare for transformation of c to a possibly normal completion\n      if (c.alternate instanceof CompletionType) {\n        c.alternateEffects.result = c.alternate = convertToPNC ? (realm.intrinsics.empty: any) : dummyCompletion;\n      } else if (convertToPNC && c.alternate instanceof JoinedAbruptCompletions) {\n        c.alternateEffects.result = c.alternate = (c.alternate.transferChildrenToPossiblyNormalCompletion(): any);\n      }\n    } else {\n      ae.result = new CompletionType(realm.intrinsics.empty);\n    }\n\n    return this.joinEffects(realm, c.joinCondition, ce, ae);\n  }\n\n  unbundle(\n    CompletionType: typeof Completion,\n    realm: Realm,\n    c: JoinedAbruptCompletions\n  ): [Effects, PossiblyNormalCompletion] {\n    let empty_effects = construct_empty_effects(realm);\n    let v = realm.intrinsics.empty;\n    if (c.consequent instanceof CompletionType) {\n      let pnc = new PossiblyNormalCompletion(v, c.joinCondition, v, empty_effects, c.alternate, c.alternateEffects, []);\n      return [c.consequentEffects, pnc];\n    } else if (c.alternate instanceof CompletionType) {\n      let pnc = new PossiblyNormalCompletion(\n        v,\n        c.joinCondition,\n        c.consequent,\n        c.consequentEffects,\n        v,\n        empty_effects,\n        []\n      );\n      return [c.alternateEffects, pnc];\n    } else {\n      invariant(\n        false,\n        `unbundle needs an argument that contains a non nested completion of type ${CompletionType.name}`\n      );\n    }\n  }\n\n  removeNormalEffects(realm: Realm, c: PossiblyNormalCompletion): Effects {\n    if (c.consequent instanceof AbruptCompletion) {\n      if (c.alternate instanceof Value) {\n        let result = c.alternateEffects;\n        c.alternateEffects = construct_empty_effects(realm);\n        return result;\n      } else {\n        invariant(c.alternate instanceof PossiblyNormalCompletion);\n        let result = realm.composeEffects(c.alternateEffects, this.removeNormalEffects(realm, c.alternate));\n        c.alternateEffects = construct_empty_effects(realm);\n        return result;\n      }\n    } else {\n      if (c.consequent instanceof Value) {\n        let result = c.consequentEffects;\n        c.consequentEffects = construct_empty_effects(realm);\n        return result;\n      } else {\n        invariant(c.consequent instanceof PossiblyNormalCompletion);\n        let result = realm.composeEffects(c.consequentEffects, this.removeNormalEffects(realm, c.consequent));\n        c.consequentEffects = construct_empty_effects(realm);\n        return result;\n      }\n    }\n  }\n\n  joinEffects(realm: Realm, joinCondition: Value, e1: Effects, e2: Effects): Effects {\n    if (!joinCondition.mightNotBeTrue()) return e1;\n    if (!joinCondition.mightNotBeFalse()) return e2;\n    invariant(joinCondition instanceof AbstractValue);\n\n    let {\n      result: result1,\n      generator: generator1,\n      modifiedBindings: modifiedBindings1,\n      modifiedProperties: modifiedProperties1,\n      createdObjects: createdObject1,\n    } = e1;\n\n    let {\n      result: result2,\n      generator: generator2,\n      modifiedBindings: modifiedBindings2,\n      modifiedProperties: modifiedProperties2,\n      createdObjects: createdObjects2,\n    } = e2;\n\n    let result = this.joinResults(realm, joinCondition, result1, result2, e1, e2);\n    if (result1 instanceof AbruptCompletion) {\n      if (!(result2 instanceof AbruptCompletion)) {\n        invariant(result instanceof PossiblyNormalCompletion);\n        return new Effects(result, generator2, modifiedBindings2, modifiedProperties2, createdObjects2);\n      }\n    } else if (result2 instanceof AbruptCompletion) {\n      invariant(result instanceof PossiblyNormalCompletion);\n      return new Effects(result, generator1, modifiedBindings1, modifiedProperties1, createdObject1);\n    }\n\n    let bindings = this.joinBindings(realm, joinCondition, modifiedBindings1, modifiedBindings2);\n    let properties = this.joinPropertyBindings(\n      realm,\n      joinCondition,\n      modifiedProperties1,\n      modifiedProperties2,\n      createdObject1,\n      createdObjects2\n    );\n    let createdObjects = new Set();\n    createdObject1.forEach(o => {\n      createdObjects.add(o);\n    });\n    createdObjects2.forEach(o => {\n      createdObjects.add(o);\n    });\n\n    let generator = joinGenerators(realm, joinCondition, generator1, generator2);\n\n    return new Effects(result, generator, bindings, properties, createdObjects);\n  }\n\n  joinNestedEffects(realm: Realm, c: Completion | Value, precedingEffects?: Effects): Effects {\n    if (c instanceof PossiblyNormalCompletion || c instanceof JoinedAbruptCompletions) {\n      let e1 = this.joinNestedEffects(realm, c.consequent, c.consequentEffects);\n      let e2 = this.joinNestedEffects(realm, c.alternate, c.alternateEffects);\n      e1.result = realm.intrinsics.empty;\n      e2.result = realm.intrinsics.empty;\n      let e3 = this.joinEffects(realm, c.joinCondition, e1, e2);\n      e3.result = c;\n      return e3;\n    }\n    if (precedingEffects !== undefined) return precedingEffects;\n    let result = construct_empty_effects(realm);\n    result.result = c;\n    return result;\n  }\n\n  joinResults(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    result1: EvaluationResult,\n    result2: EvaluationResult,\n    e1: Effects,\n    e2: Effects\n  ): AbruptCompletion | PossiblyNormalCompletion | Value {\n    let getAbstractValue = (v1: void | Value, v2: void | Value) => {\n      return this.joinValuesAsConditional(realm, joinCondition, v1, v2);\n    };\n    if (result1 instanceof Reference || result2 instanceof Reference) {\n      AbstractValue.reportIntrospectionError(joinCondition);\n      throw new FatalError();\n    }\n    if (result1 instanceof BreakCompletion && result2 instanceof BreakCompletion && result1.target === result2.target) {\n      let val = this.joinValues(realm, result1.value, result2.value, getAbstractValue);\n      invariant(val instanceof Value);\n      return new BreakCompletion(val, joinCondition.expressionLocation, result1.target);\n    }\n    if (\n      result1 instanceof ContinueCompletion &&\n      result2 instanceof ContinueCompletion &&\n      result1.target === result2.target\n    ) {\n      return new ContinueCompletion(realm.intrinsics.empty, joinCondition.expressionLocation, result1.target);\n    }\n    if (result1 instanceof ReturnCompletion && result2 instanceof ReturnCompletion) {\n      let val = this.joinValues(realm, result1.value, result2.value, getAbstractValue);\n      invariant(val instanceof Value);\n      return new ReturnCompletion(val, joinCondition.expressionLocation);\n    }\n    if (result1 instanceof ThrowCompletion && result2 instanceof ThrowCompletion) {\n      let val = this.joinValues(realm, result1.value, result2.value, getAbstractValue);\n      invariant(val instanceof Value);\n      return new ThrowCompletion(realm, val, result1.location);\n    }\n    if (result1 instanceof AbruptCompletion && result2 instanceof AbruptCompletion) {\n      return new JoinedAbruptCompletions(realm, joinCondition, result1, e1, result2, e2);\n    }\n    if (result1 instanceof Value && result2 instanceof Value) {\n      let val = this.joinValues(realm, result1, result2, getAbstractValue);\n      invariant(val instanceof Value);\n      return val;\n    }\n    if (result1 instanceof PossiblyNormalCompletion && result2 instanceof PossiblyNormalCompletion) {\n      return this.joinPossiblyNormalCompletions(realm, joinCondition, result1, result2);\n    }\n    if (result1 instanceof AbruptCompletion) {\n      let value = result2;\n      let savedEffects;\n      let savedPathConditions = [];\n      if (result2 instanceof PossiblyNormalCompletion) {\n        value = result2.value;\n        savedEffects = result2.savedEffects;\n        savedPathConditions = result2.savedPathConditions;\n      }\n      invariant(value instanceof Value);\n      return new PossiblyNormalCompletion(\n        value,\n        joinCondition,\n        result1,\n        e1,\n        result2,\n        e2,\n        savedPathConditions,\n        savedEffects\n      );\n    }\n    if (result2 instanceof AbruptCompletion) {\n      let value = result1;\n      let savedEffects;\n      let savedPathConditions = [];\n      if (result1 instanceof PossiblyNormalCompletion) {\n        value = result1.value;\n        savedEffects = result1.savedEffects;\n        savedPathConditions = result1.savedPathConditions;\n      }\n      invariant(value instanceof Value);\n      return new PossiblyNormalCompletion(\n        value,\n        joinCondition,\n        result1,\n        e1,\n        result2,\n        e2,\n        savedPathConditions,\n        savedEffects\n      );\n    }\n    if (result1 instanceof PossiblyNormalCompletion) {\n      invariant(result2 instanceof Value);\n      this.joinPossiblyNormalCompletionWithValue(realm, joinCondition, result1, result2);\n      return result1;\n    }\n    if (result2 instanceof PossiblyNormalCompletion) {\n      invariant(result1 instanceof Value);\n      this.joinValueWithPossiblyNormalCompletion(realm, joinCondition, result2, result1);\n      return result2;\n    }\n    invariant(false);\n  }\n\n  composeGenerators(realm: Realm, generator1: Generator, generator2: Generator): Generator {\n    let result = new Generator(realm, \"composed\");\n    if (!generator1.empty() || !generator2.empty()) {\n      result.composeGenerators(generator1, generator2);\n    }\n    return result;\n  }\n\n  // Creates a single map that joins together maps m1 and m2 using the given join\n  // operator. If an entry is present in one map but not the other, the missing\n  // entry is treated as if it were there and its value were undefined.\n  joinMaps<K, V>(m1: Map<K, V>, m2: Map<K, V>, join: (K, void | V, void | V) => V): Map<K, V> {\n    let m3: Map<K, V> = new Map();\n    m1.forEach((val1, key, map1) => {\n      let val2 = m2.get(key);\n      let val3 = join(key, val1, val2);\n      m3.set(key, val3);\n    });\n    m2.forEach((val2, key, map2) => {\n      if (!m1.has(key)) {\n        m3.set(key, join(key, undefined, val2));\n      }\n    });\n    return m3;\n  }\n\n  // Creates a single map that has an key, value pair for the union of the key\n  // sets of m1 and m2. The value of a pair is the join of m1[key] and m2[key]\n  // where the join is defined to be just m1[key] if m1[key] === m2[key] and\n  // and abstract value with expression \"joinCondition ? m1[key] : m2[key]\" if not.\n  joinBindings(realm: Realm, joinCondition: AbstractValue, m1: Bindings, m2: Bindings): Bindings {\n    let getAbstractValue = (v1: void | Value, v2: void | Value) => {\n      return this.joinValuesAsConditional(realm, joinCondition, v1, v2);\n    };\n    let join = (b: Binding, b1: void | BindingEntry, b2: void | BindingEntry) => {\n      let l1 = b1 === undefined ? b.hasLeaked : b1.hasLeaked;\n      let l2 = b2 === undefined ? b.hasLeaked : b2.hasLeaked;\n      let v1 = b1 === undefined ? b.value : b1.value;\n      let v2 = b2 === undefined ? b.value : b2.value;\n      let hasLeaked = l1 || l2; // If either has leaked, then this binding has leaked.\n      let value = this.joinValues(realm, v1, v2, getAbstractValue);\n      invariant(value instanceof Value);\n      return { hasLeaked, value };\n    };\n    return this.joinMaps(m1, m2, join);\n  }\n\n  // If v1 is known and defined and v1 === v2 return v1,\n  // otherwise return getAbstractValue(v1, v2)\n  joinValues(\n    realm: Realm,\n    v1: void | Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n    v2: void | Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n    getAbstractValue: (void | Value, void | Value) => Value\n  ): Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }> {\n    if (Array.isArray(v1) || Array.isArray(v2)) {\n      invariant(v1 === undefined || Array.isArray(v1));\n      invariant(v2 === undefined || Array.isArray(v2));\n      return joinArrays(realm, ((v1: any): void | Array<Value>), ((v2: any): void | Array<Value>), getAbstractValue);\n    }\n    invariant(v1 === undefined || v1 instanceof Value);\n    invariant(v2 === undefined || v2 instanceof Value);\n    if (\n      v1 !== undefined &&\n      v2 !== undefined &&\n      !(v1 instanceof AbstractValue) &&\n      !(v2 instanceof AbstractValue) &&\n      StrictEqualityComparison(realm, v1.throwIfNotConcrete(), v2.throwIfNotConcrete())\n    ) {\n      return v1;\n    } else {\n      return getAbstractValue(v1, v2);\n    }\n  }\n\n  joinValuesAsConditional(realm: Realm, condition: Value, v1: void | Value, v2: void | Value): Value {\n    return AbstractValue.createFromConditionalOp(realm, condition, v1, v2);\n  }\n\n  joinPropertyBindings(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    m1: PropertyBindings,\n    m2: PropertyBindings,\n    c1: CreatedObjects,\n    c2: CreatedObjects\n  ): PropertyBindings {\n    let join = (b: PropertyBinding, d1: void | Descriptor, d2: void | Descriptor) => {\n      // If the PropertyBinding object has been freshly allocated do not join\n      if (d1 === undefined) {\n        if (b.object instanceof ObjectValue && c2.has(b.object)) return d2; // no join\n        if (b.descriptor !== undefined && m1.has(b)) {\n          // property was deleted\n          d1 = cloneDescriptor(b.descriptor);\n          invariant(d1 !== undefined);\n          d1.value = realm.intrinsics.empty;\n        } else {\n          // no write to property\n          d1 = b.descriptor; //Get value of property before the split\n        }\n      }\n      if (d2 === undefined) {\n        if (b.object instanceof ObjectValue && c1.has(b.object)) return d1; // no join\n        if (b.descriptor !== undefined && m2.has(b)) {\n          // property was deleted\n          d2 = cloneDescriptor(b.descriptor);\n          invariant(d2 !== undefined);\n          d2.value = realm.intrinsics.empty;\n        } else {\n          // no write to property\n          d2 = b.descriptor; //Get value of property before the split\n        }\n      }\n      return this.joinDescriptors(realm, joinCondition, d1, d2);\n    };\n    return this.joinMaps(m1, m2, join);\n  }\n\n  joinDescriptors(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    d1: void | Descriptor,\n    d2: void | Descriptor\n  ): void | Descriptor {\n    let getAbstractValue = (v1: void | Value, v2: void | Value) => {\n      return this.joinValuesAsConditional(realm, joinCondition, v1, v2);\n    };\n    let clone_with_abstract_value = (d: Descriptor) => {\n      invariant(d === d1 || d === d2);\n      if (!IsDataDescriptor(realm, d)) {\n        let d3: Descriptor = {};\n        d3.joinCondition = joinCondition;\n        return d3;\n      }\n      let dc = cloneDescriptor(d);\n      invariant(dc !== undefined);\n      let dcValue = dc.value;\n      if (Array.isArray(dcValue)) {\n        invariant(dcValue.length > 0);\n        let elem0 = dcValue[0];\n        if (elem0 instanceof Value) {\n          dc.value = dcValue.map(e => {\n            return d === d1\n              ? getAbstractValue((e: any), realm.intrinsics.empty)\n              : getAbstractValue(realm.intrinsics.empty, (e: any));\n          });\n        } else {\n          dc.value = dcValue.map(e => {\n            let { $Key: key1, $Value: val1 } = (e: any);\n            let key3 =\n              d === d1\n                ? getAbstractValue(key1, realm.intrinsics.empty)\n                : getAbstractValue(realm.intrinsics.empty, key1);\n            let val3 =\n              d === d1\n                ? getAbstractValue(val1, realm.intrinsics.empty)\n                : getAbstractValue(realm.intrinsics.empty, val1);\n            return { $Key: key3, $Value: val3 };\n          });\n        }\n      } else {\n        invariant(dcValue === undefined || dcValue instanceof Value);\n        dc.value =\n          d === d1\n            ? getAbstractValue(dcValue, realm.intrinsics.empty)\n            : getAbstractValue(realm.intrinsics.empty, dcValue);\n      }\n      return dc;\n    };\n    if (d1 === undefined) {\n      if (d2 === undefined) return undefined;\n      // d2 is a new property created in only one branch, join with empty\n      let d3 = clone_with_abstract_value(d2);\n      if (!IsDataDescriptor(realm, d2)) d3.descriptor2 = d2;\n      return d3;\n    } else if (d2 === undefined) {\n      invariant(d1 !== undefined);\n      // d1 is a new property created in only one branch, join with empty\n      let d3 = clone_with_abstract_value(d1);\n      if (!IsDataDescriptor(realm, d1)) d3.descriptor1 = d1;\n      return d3;\n    } else {\n      if (equalDescriptors(d1, d2) && IsDataDescriptor(realm, d1)) {\n        let dc = cloneDescriptor(d1);\n        invariant(dc !== undefined);\n        dc.value = this.joinValues(realm, d1.value, d2.value, getAbstractValue);\n        return dc;\n      }\n      let d3: Descriptor = {};\n      d3.joinCondition = joinCondition;\n      d3.descriptor1 = d1;\n      d3.descriptor2 = d2;\n      return d3;\n    }\n  }\n}\n"]}