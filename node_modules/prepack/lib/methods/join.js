"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.JoinImplementation = undefined;

var _errors = require("../errors.js");

var _realm = require("../realm.js");

var _completions = require("../completions.js");

var _environment = require("../environment.js");

var _index = require("../methods/index.js");

var _generator = require("../utils/generator.js");

var _index2 = require("../values/index.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

function joinGenerators(realm, joinCondition, generator1, generator2) {
  let result = new _generator.Generator(realm, "joined");
  if (!generator1.empty() || !generator2.empty()) {
    result.joinGenerators(joinCondition, generator1, generator2);
  }
  return result;
}

function joinArrays(realm, v1, v2, getAbstractValue) {
  let e = v1 && v1[0] || v2 && v2[0];
  if (e instanceof _index2.Value) return joinArraysOfValues(realm, v1, v2, getAbstractValue);else return joinArrayOfsMapEntries(realm, v1, v2, getAbstractValue);
}

function joinArrayOfsMapEntries(realm, a1, a2, getAbstractValue) {
  let empty = realm.intrinsics.empty;
  let n = Math.max(a1 && a1.length || 0, a2 && a2.length || 0);
  let result = [];
  for (let i = 0; i < n; i++) {
    let { $Key: key1, $Value: val1 } = a1 && a1[i] || { $Key: empty, $Value: empty };
    let { $Key: key2, $Value: val2 } = a2 && a2[i] || { $Key: empty, $Value: empty };
    if (key1 === undefined && key2 === undefined) {
      result[i] = { $Key: undefined, $Value: undefined };
    } else {
      let key3 = getAbstractValue(key1, key2);
      let val3 = getAbstractValue(val1, val2);
      result[i] = { $Key: key3, $Value: val3 };
    }
  }
  return result;
}

function joinArraysOfValues(realm, a1, a2, getAbstractValue) {
  let n = Math.max(a1 && a1.length || 0, a2 && a2.length || 0);
  let result = [];
  for (let i = 0; i < n; i++) {
    result[i] = getAbstractValue(a1 && a1[i] || undefined, a2 && a2[i] || undefined);
  }
  return result;
}

class JoinImplementation {
  stopEffectCaptureJoinApplyAndReturnCompletion(c1, c2, realm) {
    let e = realm.getCapturedEffects(c1);
    (0, _invariant2.default)(e !== undefined);
    realm.stopEffectCaptureAndUndoEffects(c1);
    let joined_effects = this.joinPossiblyNormalCompletionWithAbruptCompletion(realm, c1, c2, e);
    realm.applyEffects(joined_effects);
    let result = joined_effects.result;
    (0, _invariant2.default)(result instanceof _completions.AbruptCompletion);
    return result;
  }

  unbundleNormalCompletion(completionOrValue) {
    let completion, value;
    if (completionOrValue instanceof _completions.PossiblyNormalCompletion) {
      completion = completionOrValue;
      value = completionOrValue.value;
    } else {
      (0, _invariant2.default)(completionOrValue instanceof _index2.Value || completionOrValue instanceof _environment.Reference);
      value = completionOrValue;
    }
    return [completion, value];
  }

  composeNormalCompletions(leftCompletion, rightCompletion, resultValue, realm) {
    if (leftCompletion instanceof _completions.PossiblyNormalCompletion) {
      if (rightCompletion instanceof _completions.PossiblyNormalCompletion) {
        this.updatePossiblyNormalCompletionWithValue(realm, rightCompletion, resultValue);
        return this.composePossiblyNormalCompletions(realm, leftCompletion, rightCompletion);
      }
      this.updatePossiblyNormalCompletionWithValue(realm, leftCompletion, resultValue);
      return leftCompletion;
    } else if (rightCompletion instanceof _completions.PossiblyNormalCompletion) {
      this.updatePossiblyNormalCompletionWithValue(realm, rightCompletion, resultValue);
      return rightCompletion;
    } else {
      (0, _invariant2.default)(leftCompletion === undefined && rightCompletion === undefined);
      return resultValue;
    }
  }

  // Note that the resulting completion expects to be returned in a state where its normal effects have been applied
  composePossiblyNormalCompletions(realm, pnc, c, priorEffects) {
    (0, _invariant2.default)(c.savedEffects === undefined); // the caller should ensure this
    let savedPathConditions = pnc.savedPathConditions;
    if (pnc.consequent instanceof _completions.AbruptCompletion) {
      if (pnc.alternate instanceof _index2.Value) {
        let { generator, modifiedBindings, modifiedProperties, createdObjects } = pnc.alternateEffects;
        let newAlternateEffects = new _realm.Effects(c, generator, modifiedBindings, modifiedProperties, createdObjects);
        return new _completions.PossiblyNormalCompletion(c.value, pnc.joinCondition, pnc.consequent, pnc.consequentEffects, c, !priorEffects ? newAlternateEffects : realm.composeEffects(priorEffects, newAlternateEffects), savedPathConditions, pnc.savedEffects);
      }
      (0, _invariant2.default)(pnc.alternate instanceof _completions.PossiblyNormalCompletion);
      let na = this.composePossiblyNormalCompletions(realm, pnc.alternate, c, priorEffects);
      let { generator, modifiedBindings, modifiedProperties, createdObjects } = pnc.alternateEffects;
      let newAlternateEffects = new _realm.Effects(na, generator, modifiedBindings, modifiedProperties, createdObjects);
      return new _completions.PossiblyNormalCompletion(c.value, pnc.joinCondition, pnc.consequent, pnc.consequentEffects, na, newAlternateEffects, savedPathConditions, pnc.savedEffects);
    } else {
      (0, _invariant2.default)(pnc.alternate instanceof _completions.AbruptCompletion);
      if (pnc.consequent instanceof _index2.Value) {
        let { generator, modifiedBindings, modifiedProperties, createdObjects } = pnc.consequentEffects;
        let newConsequentEffects = new _realm.Effects(c, generator, modifiedBindings, modifiedProperties, createdObjects);
        return new _completions.PossiblyNormalCompletion(c.value, pnc.joinCondition, c, !priorEffects ? newConsequentEffects : realm.composeEffects(priorEffects, newConsequentEffects), pnc.alternate, pnc.alternateEffects, savedPathConditions, pnc.savedEffects);
      }
      (0, _invariant2.default)(pnc.consequent instanceof _completions.PossiblyNormalCompletion);
      let nc = this.composePossiblyNormalCompletions(realm, pnc.consequent, c);
      let { generator, modifiedBindings, modifiedProperties, createdObjects } = pnc.consequentEffects;
      let newConsequentEffects = new _realm.Effects(nc, generator, modifiedBindings, modifiedProperties, createdObjects);
      return new _completions.PossiblyNormalCompletion(c.value, pnc.joinCondition, nc, newConsequentEffects, pnc.alternate, pnc.alternateEffects, savedPathConditions, pnc.savedEffects);
    }
  }

  updatePossiblyNormalCompletionWithSubsequentEffects(realm, pnc, subsequentEffects) {
    let v = subsequentEffects.result;
    (0, _invariant2.default)(v instanceof _index2.Value);
    pnc.value = v;
    if (pnc.consequent instanceof _completions.AbruptCompletion) {
      if (pnc.alternate instanceof _index2.Value) {
        pnc.alternate = v;
        pnc.alternateEffects.result = v;
        pnc.alternateEffects = realm.composeEffects(pnc.alternateEffects, subsequentEffects);
      } else {
        (0, _invariant2.default)(pnc.alternate instanceof _completions.PossiblyNormalCompletion);
        this.updatePossiblyNormalCompletionWithSubsequentEffects(realm, pnc.alternate, subsequentEffects);
      }
    } else {
      if (pnc.consequent instanceof _index2.Value) {
        pnc.consequent = v;
        pnc.consequentEffects.result = v;
        pnc.consequentEffects = realm.composeEffects(pnc.consequentEffects, subsequentEffects);
      } else {
        (0, _invariant2.default)(pnc.consequent instanceof _completions.PossiblyNormalCompletion);
        this.updatePossiblyNormalCompletionWithSubsequentEffects(realm, pnc.consequent, subsequentEffects);
      }
    }
  }

  updatePossiblyNormalCompletionWithValue(realm, pnc, v) {
    pnc.value = v;
    if (pnc.consequent instanceof _completions.AbruptCompletion) {
      if (pnc.alternate instanceof _index2.Value) {
        pnc.alternate = v;
        pnc.alternateEffects.result = v;
      } else {
        (0, _invariant2.default)(pnc.alternate instanceof _completions.PossiblyNormalCompletion);
        this.updatePossiblyNormalCompletionWithValue(realm, pnc.alternate, v);
      }
    } else {
      if (pnc.consequent instanceof _index2.Value) {
        pnc.consequent = v;
        pnc.consequentEffects.result = v;
      } else {
        (0, _invariant2.default)(pnc.consequent instanceof _completions.PossiblyNormalCompletion);
        this.updatePossiblyNormalCompletionWithValue(realm, pnc.consequent, v);
      }
    }
  }

  // Returns the joined effects of all of the paths in pnc.
  // The normal path in pnc is modified to become terminated by ac,
  // so the overall completion will always be an instance of JoinedAbruptCompletions
  joinPossiblyNormalCompletionWithAbruptCompletion(realm,
  // a forked path with a non abrupt (normal) component
  pnc,
  // an abrupt completion that completes the normal path
  ac,
  // effects collected after pnc was constructed
  e) {
    // set up e with ac as the completion. It's OK to do this repeatedly since ac is not changed by recursive calls.
    e.result = ac;
    if (pnc.consequent instanceof _completions.AbruptCompletion) {
      if (pnc.alternate instanceof _index2.Value) {
        return this.joinEffects(realm, pnc.joinCondition, pnc.consequentEffects, realm.composeEffects(pnc.alternateEffects, e));
      }
      (0, _invariant2.default)(pnc.alternate instanceof _completions.PossiblyNormalCompletion);
      let alternate_effects = this.joinPossiblyNormalCompletionWithAbruptCompletion(realm, pnc.alternate, ac, e);
      let composedEffects = realm.composeEffects(pnc.alternateEffects, alternate_effects);
      (0, _invariant2.default)(pnc.consequent instanceof _completions.AbruptCompletion);
      return this.joinEffects(realm, pnc.joinCondition, pnc.consequentEffects, composedEffects);
    } else {
      (0, _invariant2.default)(pnc.alternate instanceof _completions.AbruptCompletion);
      if (pnc.consequent instanceof _index2.Value) {
        return this.joinEffects(realm, pnc.joinCondition, realm.composeEffects(pnc.consequentEffects, e), pnc.alternateEffects);
      }
      (0, _invariant2.default)(pnc.consequent instanceof _completions.PossiblyNormalCompletion);
      let consequent_effects = this.joinPossiblyNormalCompletionWithAbruptCompletion(realm, pnc.consequent, ac, e);
      let composedEffects = realm.composeEffects(pnc.consequentEffects, consequent_effects);
      (0, _invariant2.default)(pnc.alternate instanceof _completions.AbruptCompletion);
      return this.joinEffects(realm, pnc.joinCondition, composedEffects, pnc.alternateEffects);
    }
  }

  joinPossiblyNormalCompletionWithValue(realm, joinCondition, pnc, v) {
    if (pnc.consequent instanceof _completions.AbruptCompletion) {
      if (pnc.alternate instanceof _index2.Value) {
        pnc.alternate = this.joinValuesAsConditional(realm, joinCondition, pnc.alternate, v);
        pnc.alternateEffects.result = pnc.alternate;
      } else {
        (0, _invariant2.default)(pnc.alternate instanceof _completions.PossiblyNormalCompletion);
        this.joinPossiblyNormalCompletionWithValue(realm, joinCondition, pnc.alternate, v);
      }
    } else {
      if (pnc.consequent instanceof _index2.Value) {
        pnc.consequent = this.joinValuesAsConditional(realm, joinCondition, pnc.consequent, v);
        pnc.consequentEffects.result = pnc.consequent;
      } else {
        (0, _invariant2.default)(pnc.consequent instanceof _completions.PossiblyNormalCompletion);
        this.joinPossiblyNormalCompletionWithValue(realm, joinCondition, pnc.consequent, v);
      }
    }
  }

  joinValueWithPossiblyNormalCompletion(realm, joinCondition, pnc, v) {
    if (pnc.consequent instanceof _completions.AbruptCompletion) {
      if (pnc.alternate instanceof _index2.Value) {
        pnc.alternate = this.joinValuesAsConditional(realm, joinCondition, v, pnc.alternate);
        pnc.alternateEffects.result = pnc.alternate;
      } else {
        (0, _invariant2.default)(pnc.alternate instanceof _completions.PossiblyNormalCompletion);
        this.joinValueWithPossiblyNormalCompletion(realm, joinCondition, pnc.alternate, v);
      }
    } else {
      if (pnc.consequent instanceof _index2.Value) {
        pnc.consequent = this.joinValuesAsConditional(realm, joinCondition, v, pnc.consequent);
        pnc.consequentEffects.result = pnc.consequent;
      } else {
        (0, _invariant2.default)(pnc.consequent instanceof _completions.PossiblyNormalCompletion);
        this.joinValueWithPossiblyNormalCompletion(realm, joinCondition, pnc.consequent, v);
      }
    }
  }

  joinPossiblyNormalCompletions(realm, joinCondition, c, a) {
    let rJoinCondition;
    let cp;
    let ap;
    if (c.consequent instanceof _completions.AbruptCompletion) {
      if (a.consequent instanceof _completions.AbruptCompletion) {
        rJoinCondition = _index2.AbstractValue.createFromLogicalOp(realm, "&&", c.joinCondition, a.joinCondition);
        cp = [c.consequentEffects, a.consequentEffects];
        ap = [c.alternateEffects, a.alternateEffects];
      } else {
        let notA = _index2.AbstractValue.createFromUnaryOp(realm, "!", a.joinCondition);
        rJoinCondition = _index2.AbstractValue.createFromLogicalOp(realm, "&&", c.joinCondition, notA);
        cp = [c.consequentEffects, a.alternateEffects];
        ap = [c.alternateEffects, a.consequentEffects];
      }
    } else {
      let notC = _index2.AbstractValue.createFromUnaryOp(realm, "!", c.joinCondition);
      if (a.consequent instanceof _completions.AbruptCompletion) {
        rJoinCondition = _index2.AbstractValue.createFromLogicalOp(realm, "&&", notC, a.joinCondition);
        cp = [c.alternateEffects, a.consequentEffects];
        ap = [c.consequentEffects, a.alternateEffects];
      } else {
        let notA = _index2.AbstractValue.createFromUnaryOp(realm, "!", a.joinCondition);
        rJoinCondition = _index2.AbstractValue.createFromLogicalOp(realm, "&&", notC, notA);
        cp = [c.alternateEffects, a.alternateEffects];
        ap = [c.consequentEffects, a.consequentEffects];
      }
    }
    (0, _invariant2.default)(rJoinCondition instanceof _index2.AbstractValue); // the transformations will not result in tautologies
    let [ce1, ce2] = cp;
    let [ae1, ae2] = ap;
    let rce = this.joinEffects(realm, joinCondition, ce1, ce2);
    let rae = this.joinEffects(realm, joinCondition, ae1, ae2);
    let rc = rce.result;
    (0, _invariant2.default)(rc instanceof _index2.Value || rc instanceof _completions.Completion);
    let ra = rae.result;
    (0, _invariant2.default)(ra instanceof _index2.Value || ra instanceof _completions.Completion);
    let rv = ra instanceof _completions.PossiblyNormalCompletion ? ra.value : ra;
    (0, _invariant2.default)(rv instanceof _index2.Value);
    return new _completions.PossiblyNormalCompletion(rv, rJoinCondition, rc, rce, ra, rae, []);
  }

  // Join all effects that result in completions of type CompletionType.
  // Erase all completions of type Completion type from c, so that we never join them again.
  // Also erase any generators that appears in branches resulting in completions of type CompletionType.
  // Note that c is modified in place and should be replaced with a PossiblyNormalCompletion by the caller
  // if either of its branches cease to be an AbruptCompletion.
  extractAndJoinCompletionsOfType(CompletionType, realm, c, convertToPNC = true) {
    let emptyEffects = (0, _realm.construct_empty_effects)(realm);
    if (c instanceof CompletionType) {
      emptyEffects.result = c;
      return emptyEffects;
    }
    if (!(c instanceof _completions.JoinedAbruptCompletions)) {
      return emptyEffects;
    }
    let dummyCompletion = new _completions.AbruptCompletion(realm.intrinsics.empty);
    // Join up the consequent and alternate completions and compose them with their prefix effects
    let ce = this.extractAndJoinCompletionsOfType(CompletionType, realm, c.consequent, convertToPNC);
    // ce will be applied to the global state before any non joining branches in c.consequent, so move
    // the generator from c.consequentEffects to ae.generator so that all branches will see its effects.
    ce = realm.composeEffects(c.consequentEffects, ce);
    ce.generator = c.consequentEffects.generator;
    c.consequentEffects.generator = emptyEffects.generator;
    if (ce.result instanceof CompletionType) {
      // Erase completions of type CompletionType and prepare for transformation of c to a possibly normal completion
      if (c.consequent instanceof CompletionType) {
        c.consequentEffects.result = c.consequent = convertToPNC ? realm.intrinsics.empty : dummyCompletion;
        convertToPNC = false;
      } else if (convertToPNC && c.consequent instanceof _completions.JoinedAbruptCompletions) {
        c.consequentEffects.result = c.consequent = c.consequent.transferChildrenToPossiblyNormalCompletion();
        convertToPNC = false;
      }
    } else {
      ce.result = new CompletionType(realm.intrinsics.empty);
    }
    let ae = this.extractAndJoinCompletionsOfType(CompletionType, realm, c.alternate, convertToPNC);
    // ae will be applied to the global state before any non joining branches in c.alternate, so move
    // the generator from c.alternateEffects to ae.generator so that all branches will see its effects.
    ae = realm.composeEffects(c.alternateEffects, ae);
    ae.generator = c.alternateEffects.generator;
    c.alternateEffects.generator = emptyEffects.generator;
    if (ae.result instanceof CompletionType) {
      // Erase completions of type CompletionType and prepare for transformation of c to a possibly normal completion
      if (c.alternate instanceof CompletionType) {
        c.alternateEffects.result = c.alternate = convertToPNC ? realm.intrinsics.empty : dummyCompletion;
      } else if (convertToPNC && c.alternate instanceof _completions.JoinedAbruptCompletions) {
        c.alternateEffects.result = c.alternate = c.alternate.transferChildrenToPossiblyNormalCompletion();
      }
    } else {
      ae.result = new CompletionType(realm.intrinsics.empty);
    }

    return this.joinEffects(realm, c.joinCondition, ce, ae);
  }

  unbundle(CompletionType, realm, c) {
    let empty_effects = (0, _realm.construct_empty_effects)(realm);
    let v = realm.intrinsics.empty;
    if (c.consequent instanceof CompletionType) {
      let pnc = new _completions.PossiblyNormalCompletion(v, c.joinCondition, v, empty_effects, c.alternate, c.alternateEffects, []);
      return [c.consequentEffects, pnc];
    } else if (c.alternate instanceof CompletionType) {
      let pnc = new _completions.PossiblyNormalCompletion(v, c.joinCondition, c.consequent, c.consequentEffects, v, empty_effects, []);
      return [c.alternateEffects, pnc];
    } else {
      (0, _invariant2.default)(false, `unbundle needs an argument that contains a non nested completion of type ${CompletionType.name}`);
    }
  }

  removeNormalEffects(realm, c) {
    if (c.consequent instanceof _completions.AbruptCompletion) {
      if (c.alternate instanceof _index2.Value) {
        let result = c.alternateEffects;
        c.alternateEffects = (0, _realm.construct_empty_effects)(realm);
        return result;
      } else {
        (0, _invariant2.default)(c.alternate instanceof _completions.PossiblyNormalCompletion);
        let result = realm.composeEffects(c.alternateEffects, this.removeNormalEffects(realm, c.alternate));
        c.alternateEffects = (0, _realm.construct_empty_effects)(realm);
        return result;
      }
    } else {
      if (c.consequent instanceof _index2.Value) {
        let result = c.consequentEffects;
        c.consequentEffects = (0, _realm.construct_empty_effects)(realm);
        return result;
      } else {
        (0, _invariant2.default)(c.consequent instanceof _completions.PossiblyNormalCompletion);
        let result = realm.composeEffects(c.consequentEffects, this.removeNormalEffects(realm, c.consequent));
        c.consequentEffects = (0, _realm.construct_empty_effects)(realm);
        return result;
      }
    }
  }

  joinEffects(realm, joinCondition, e1, e2) {
    if (!joinCondition.mightNotBeTrue()) return e1;
    if (!joinCondition.mightNotBeFalse()) return e2;
    (0, _invariant2.default)(joinCondition instanceof _index2.AbstractValue);

    let {
      result: result1,
      generator: generator1,
      modifiedBindings: modifiedBindings1,
      modifiedProperties: modifiedProperties1,
      createdObjects: createdObject1
    } = e1;

    let {
      result: result2,
      generator: generator2,
      modifiedBindings: modifiedBindings2,
      modifiedProperties: modifiedProperties2,
      createdObjects: createdObjects2
    } = e2;

    let result = this.joinResults(realm, joinCondition, result1, result2, e1, e2);
    if (result1 instanceof _completions.AbruptCompletion) {
      if (!(result2 instanceof _completions.AbruptCompletion)) {
        (0, _invariant2.default)(result instanceof _completions.PossiblyNormalCompletion);
        return new _realm.Effects(result, generator2, modifiedBindings2, modifiedProperties2, createdObjects2);
      }
    } else if (result2 instanceof _completions.AbruptCompletion) {
      (0, _invariant2.default)(result instanceof _completions.PossiblyNormalCompletion);
      return new _realm.Effects(result, generator1, modifiedBindings1, modifiedProperties1, createdObject1);
    }

    let bindings = this.joinBindings(realm, joinCondition, modifiedBindings1, modifiedBindings2);
    let properties = this.joinPropertyBindings(realm, joinCondition, modifiedProperties1, modifiedProperties2, createdObject1, createdObjects2);
    let createdObjects = new Set();
    createdObject1.forEach(o => {
      createdObjects.add(o);
    });
    createdObjects2.forEach(o => {
      createdObjects.add(o);
    });

    let generator = joinGenerators(realm, joinCondition, generator1, generator2);

    return new _realm.Effects(result, generator, bindings, properties, createdObjects);
  }

  joinNestedEffects(realm, c, precedingEffects) {
    if (c instanceof _completions.PossiblyNormalCompletion || c instanceof _completions.JoinedAbruptCompletions) {
      let e1 = this.joinNestedEffects(realm, c.consequent, c.consequentEffects);
      let e2 = this.joinNestedEffects(realm, c.alternate, c.alternateEffects);
      e1.result = realm.intrinsics.empty;
      e2.result = realm.intrinsics.empty;
      let e3 = this.joinEffects(realm, c.joinCondition, e1, e2);
      e3.result = c;
      return e3;
    }
    if (precedingEffects !== undefined) return precedingEffects;
    let result = (0, _realm.construct_empty_effects)(realm);
    result.result = c;
    return result;
  }

  joinResults(realm, joinCondition, result1, result2, e1, e2) {
    let getAbstractValue = (v1, v2) => {
      return this.joinValuesAsConditional(realm, joinCondition, v1, v2);
    };
    if (result1 instanceof _environment.Reference || result2 instanceof _environment.Reference) {
      _index2.AbstractValue.reportIntrospectionError(joinCondition);
      throw new _errors.FatalError();
    }
    if (result1 instanceof _completions.BreakCompletion && result2 instanceof _completions.BreakCompletion && result1.target === result2.target) {
      let val = this.joinValues(realm, result1.value, result2.value, getAbstractValue);
      (0, _invariant2.default)(val instanceof _index2.Value);
      return new _completions.BreakCompletion(val, joinCondition.expressionLocation, result1.target);
    }
    if (result1 instanceof _completions.ContinueCompletion && result2 instanceof _completions.ContinueCompletion && result1.target === result2.target) {
      return new _completions.ContinueCompletion(realm.intrinsics.empty, joinCondition.expressionLocation, result1.target);
    }
    if (result1 instanceof _completions.ReturnCompletion && result2 instanceof _completions.ReturnCompletion) {
      let val = this.joinValues(realm, result1.value, result2.value, getAbstractValue);
      (0, _invariant2.default)(val instanceof _index2.Value);
      return new _completions.ReturnCompletion(val, joinCondition.expressionLocation);
    }
    if (result1 instanceof _completions.ThrowCompletion && result2 instanceof _completions.ThrowCompletion) {
      let val = this.joinValues(realm, result1.value, result2.value, getAbstractValue);
      (0, _invariant2.default)(val instanceof _index2.Value);
      return new _completions.ThrowCompletion(realm, val, result1.location);
    }
    if (result1 instanceof _completions.AbruptCompletion && result2 instanceof _completions.AbruptCompletion) {
      return new _completions.JoinedAbruptCompletions(realm, joinCondition, result1, e1, result2, e2);
    }
    if (result1 instanceof _index2.Value && result2 instanceof _index2.Value) {
      let val = this.joinValues(realm, result1, result2, getAbstractValue);
      (0, _invariant2.default)(val instanceof _index2.Value);
      return val;
    }
    if (result1 instanceof _completions.PossiblyNormalCompletion && result2 instanceof _completions.PossiblyNormalCompletion) {
      return this.joinPossiblyNormalCompletions(realm, joinCondition, result1, result2);
    }
    if (result1 instanceof _completions.AbruptCompletion) {
      let value = result2;
      let savedEffects;
      let savedPathConditions = [];
      if (result2 instanceof _completions.PossiblyNormalCompletion) {
        value = result2.value;
        savedEffects = result2.savedEffects;
        savedPathConditions = result2.savedPathConditions;
      }
      (0, _invariant2.default)(value instanceof _index2.Value);
      return new _completions.PossiblyNormalCompletion(value, joinCondition, result1, e1, result2, e2, savedPathConditions, savedEffects);
    }
    if (result2 instanceof _completions.AbruptCompletion) {
      let value = result1;
      let savedEffects;
      let savedPathConditions = [];
      if (result1 instanceof _completions.PossiblyNormalCompletion) {
        value = result1.value;
        savedEffects = result1.savedEffects;
        savedPathConditions = result1.savedPathConditions;
      }
      (0, _invariant2.default)(value instanceof _index2.Value);
      return new _completions.PossiblyNormalCompletion(value, joinCondition, result1, e1, result2, e2, savedPathConditions, savedEffects);
    }
    if (result1 instanceof _completions.PossiblyNormalCompletion) {
      (0, _invariant2.default)(result2 instanceof _index2.Value);
      this.joinPossiblyNormalCompletionWithValue(realm, joinCondition, result1, result2);
      return result1;
    }
    if (result2 instanceof _completions.PossiblyNormalCompletion) {
      (0, _invariant2.default)(result1 instanceof _index2.Value);
      this.joinValueWithPossiblyNormalCompletion(realm, joinCondition, result2, result1);
      return result2;
    }
    (0, _invariant2.default)(false);
  }

  composeGenerators(realm, generator1, generator2) {
    let result = new _generator.Generator(realm, "composed");
    if (!generator1.empty() || !generator2.empty()) {
      result.composeGenerators(generator1, generator2);
    }
    return result;
  }

  // Creates a single map that joins together maps m1 and m2 using the given join
  // operator. If an entry is present in one map but not the other, the missing
  // entry is treated as if it were there and its value were undefined.
  joinMaps(m1, m2, join) {
    let m3 = new Map();
    m1.forEach((val1, key, map1) => {
      let val2 = m2.get(key);
      let val3 = join(key, val1, val2);
      m3.set(key, val3);
    });
    m2.forEach((val2, key, map2) => {
      if (!m1.has(key)) {
        m3.set(key, join(key, undefined, val2));
      }
    });
    return m3;
  }

  // Creates a single map that has an key, value pair for the union of the key
  // sets of m1 and m2. The value of a pair is the join of m1[key] and m2[key]
  // where the join is defined to be just m1[key] if m1[key] === m2[key] and
  // and abstract value with expression "joinCondition ? m1[key] : m2[key]" if not.
  joinBindings(realm, joinCondition, m1, m2) {
    let getAbstractValue = (v1, v2) => {
      return this.joinValuesAsConditional(realm, joinCondition, v1, v2);
    };
    let join = (b, b1, b2) => {
      let l1 = b1 === undefined ? b.hasLeaked : b1.hasLeaked;
      let l2 = b2 === undefined ? b.hasLeaked : b2.hasLeaked;
      let v1 = b1 === undefined ? b.value : b1.value;
      let v2 = b2 === undefined ? b.value : b2.value;
      let hasLeaked = l1 || l2; // If either has leaked, then this binding has leaked.
      let value = this.joinValues(realm, v1, v2, getAbstractValue);
      (0, _invariant2.default)(value instanceof _index2.Value);
      return { hasLeaked, value };
    };
    return this.joinMaps(m1, m2, join);
  }

  // If v1 is known and defined and v1 === v2 return v1,
  // otherwise return getAbstractValue(v1, v2)
  joinValues(realm, v1, v2, getAbstractValue) {
    if (Array.isArray(v1) || Array.isArray(v2)) {
      (0, _invariant2.default)(v1 === undefined || Array.isArray(v1));
      (0, _invariant2.default)(v2 === undefined || Array.isArray(v2));
      return joinArrays(realm, v1, v2, getAbstractValue);
    }
    (0, _invariant2.default)(v1 === undefined || v1 instanceof _index2.Value);
    (0, _invariant2.default)(v2 === undefined || v2 instanceof _index2.Value);
    if (v1 !== undefined && v2 !== undefined && !(v1 instanceof _index2.AbstractValue) && !(v2 instanceof _index2.AbstractValue) && (0, _index.StrictEqualityComparison)(realm, v1.throwIfNotConcrete(), v2.throwIfNotConcrete())) {
      return v1;
    } else {
      return getAbstractValue(v1, v2);
    }
  }

  joinValuesAsConditional(realm, condition, v1, v2) {
    return _index2.AbstractValue.createFromConditionalOp(realm, condition, v1, v2);
  }

  joinPropertyBindings(realm, joinCondition, m1, m2, c1, c2) {
    let join = (b, d1, d2) => {
      // If the PropertyBinding object has been freshly allocated do not join
      if (d1 === undefined) {
        if (b.object instanceof _index2.ObjectValue && c2.has(b.object)) return d2; // no join
        if (b.descriptor !== undefined && m1.has(b)) {
          // property was deleted
          d1 = (0, _index.cloneDescriptor)(b.descriptor);
          (0, _invariant2.default)(d1 !== undefined);
          d1.value = realm.intrinsics.empty;
        } else {
          // no write to property
          d1 = b.descriptor; //Get value of property before the split
        }
      }
      if (d2 === undefined) {
        if (b.object instanceof _index2.ObjectValue && c1.has(b.object)) return d1; // no join
        if (b.descriptor !== undefined && m2.has(b)) {
          // property was deleted
          d2 = (0, _index.cloneDescriptor)(b.descriptor);
          (0, _invariant2.default)(d2 !== undefined);
          d2.value = realm.intrinsics.empty;
        } else {
          // no write to property
          d2 = b.descriptor; //Get value of property before the split
        }
      }
      return this.joinDescriptors(realm, joinCondition, d1, d2);
    };
    return this.joinMaps(m1, m2, join);
  }

  joinDescriptors(realm, joinCondition, d1, d2) {
    let getAbstractValue = (v1, v2) => {
      return this.joinValuesAsConditional(realm, joinCondition, v1, v2);
    };
    let clone_with_abstract_value = d => {
      (0, _invariant2.default)(d === d1 || d === d2);
      if (!(0, _index.IsDataDescriptor)(realm, d)) {
        let d3 = {};
        d3.joinCondition = joinCondition;
        return d3;
      }
      let dc = (0, _index.cloneDescriptor)(d);
      (0, _invariant2.default)(dc !== undefined);
      let dcValue = dc.value;
      if (Array.isArray(dcValue)) {
        (0, _invariant2.default)(dcValue.length > 0);
        let elem0 = dcValue[0];
        if (elem0 instanceof _index2.Value) {
          dc.value = dcValue.map(e => {
            return d === d1 ? getAbstractValue(e, realm.intrinsics.empty) : getAbstractValue(realm.intrinsics.empty, e);
          });
        } else {
          dc.value = dcValue.map(e => {
            let { $Key: key1, $Value: val1 } = e;
            let key3 = d === d1 ? getAbstractValue(key1, realm.intrinsics.empty) : getAbstractValue(realm.intrinsics.empty, key1);
            let val3 = d === d1 ? getAbstractValue(val1, realm.intrinsics.empty) : getAbstractValue(realm.intrinsics.empty, val1);
            return { $Key: key3, $Value: val3 };
          });
        }
      } else {
        (0, _invariant2.default)(dcValue === undefined || dcValue instanceof _index2.Value);
        dc.value = d === d1 ? getAbstractValue(dcValue, realm.intrinsics.empty) : getAbstractValue(realm.intrinsics.empty, dcValue);
      }
      return dc;
    };
    if (d1 === undefined) {
      if (d2 === undefined) return undefined;
      // d2 is a new property created in only one branch, join with empty
      let d3 = clone_with_abstract_value(d2);
      if (!(0, _index.IsDataDescriptor)(realm, d2)) d3.descriptor2 = d2;
      return d3;
    } else if (d2 === undefined) {
      (0, _invariant2.default)(d1 !== undefined);
      // d1 is a new property created in only one branch, join with empty
      let d3 = clone_with_abstract_value(d1);
      if (!(0, _index.IsDataDescriptor)(realm, d1)) d3.descriptor1 = d1;
      return d3;
    } else {
      if ((0, _index.equalDescriptors)(d1, d2) && (0, _index.IsDataDescriptor)(realm, d1)) {
        let dc = (0, _index.cloneDescriptor)(d1);
        (0, _invariant2.default)(dc !== undefined);
        dc.value = this.joinValues(realm, d1.value, d2.value, getAbstractValue);
        return dc;
      }
      let d3 = {};
      d3.joinCondition = joinCondition;
      d3.descriptor1 = d1;
      d3.descriptor2 = d2;
      return d3;
    }
  }
}
exports.JoinImplementation = JoinImplementation;
//# sourceMappingURL=join.js.map