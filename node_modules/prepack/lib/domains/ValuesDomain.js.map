{"version":3,"sources":["../../src/domains/ValuesDomain.js"],"names":["ValuesDomain","constructor","values","valueSet","Set","add","_elements","contains","x","elems","xelems","undefined","size","e","has","containsValue","isTop","getElements","binaryOp","realm","op","left","right","leftElements","rightElements","topVal","resultSet","savedHandler","errorHandler","savedIsReadOnly","isReadOnly","leftElem","rightElem","result","computeBinary","lval","rval","lprim","ToPrimitiveOrAbstract","rprim","createFromBinaryOp","lstr","ToString","rstr","lnum","ToNumber","rnum","r","intrinsics","false","value","true","ToUint32","createFromNumberValue","ToInt32","base","ToNumberOrAbstract","exponent","baseVal","exponentVal","Math","pow","lnumVal","rnumVal","isNaN","NaN","ToPropertyKey","logicalOp","computeLogical","lbool","ToBoolean","computeUnary","oldValue","val","typeString","typeToString","getType","unaryOp","operandValues","operandElements","operandElem","includesValueNotOfType","type","cval","includesValueOfType","mightBeFalse","mightNotBeFalse","joinValues","v1","v2","joinWith","union","y","forEach","v","meetValues","meetWith","intersection","elements","promoteEmptyToUndefined","newSet","$Realm"],"mappings":"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","file":"ValuesDomain.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelBinaryOperator, BabelNodeLogicalOperator, BabelUnaryOperator } from \"babel-types\";\nimport { AbruptCompletion } from \"../completions.js\";\nimport { FatalError } from \"../errors.js\";\nimport invariant from \"../invariant.js\";\nimport {\n  AbstractEqualityComparison,\n  AbstractRelationalComparison,\n  Add,\n  HasProperty,\n  InstanceofOperator,\n  StrictEqualityComparison,\n} from \"../methods/index.js\";\nimport type { Realm } from \"../realm.js\";\nimport { To } from \"../singletons.js\";\nimport {\n  AbstractValue,\n  BooleanValue,\n  ConcreteValue,\n  EmptyValue,\n  NumberValue,\n  IntegralValue,\n  ObjectValue,\n  StringValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport { Utils } from \"../singletons.js\";\n\n/* An abstract domain that collects together a set of concrete values\n   that might be the value of a variable at runtime.\n   Initially, every variable has the value undefined.\n   A property that has been weakly deleted will have more than\n   one value, one of which will by the EmptyValue.  */\n\nexport default class ValuesDomain {\n  constructor(values: void | Set<ConcreteValue> | ConcreteValue) {\n    if (values instanceof ConcreteValue) {\n      let valueSet = new Set();\n      valueSet.add(values);\n      values = valueSet;\n    }\n    this._elements = values;\n  }\n\n  static topVal = new ValuesDomain(undefined);\n\n  _elements: void | Set<ConcreteValue>;\n\n  contains(x: ValuesDomain): boolean {\n    let elems = this._elements;\n    let xelems = x._elements;\n    if (elems === xelems) return true;\n    if (elems === undefined) return true;\n    if (xelems === undefined) return false;\n    if (elems.size < xelems.size) return false;\n    for (let e of xelems) {\n      if (!elems.has(e)) return false;\n    }\n    return true;\n  }\n\n  containsValue(x: Value): boolean {\n    let elems = this._elements;\n    if (elems === undefined) return true; // Top contains everything\n    if (x instanceof AbstractValue) return this.contains(x.values);\n    invariant(x instanceof ConcreteValue);\n    return elems.has(x);\n  }\n\n  isTop() {\n    return this._elements === undefined;\n  }\n\n  getElements() {\n    invariant(this._elements !== undefined);\n    return this._elements;\n  }\n\n  // return a set of values that may be result of performing the given operation on each pair in the\n  // Cartesian product of the value sets of the operands.\n  static binaryOp(realm: Realm, op: BabelBinaryOperator, left: ValuesDomain, right: ValuesDomain): ValuesDomain {\n    let leftElements = left._elements;\n    let rightElements = right._elements;\n    // Return top if left and/or right are top or if the size of the value set would get to be quite large.\n    // Note: the larger the set of values, the less we know and therefore the less we get value from computing\n    // all of these values. TODO #1000: probably the upper bound can be quite a bit smaller.\n    if (!leftElements || !rightElements || leftElements.size > 100 || rightElements.size > 100)\n      return ValuesDomain.topVal;\n    let resultSet = new Set();\n    let savedHandler = realm.errorHandler;\n    let savedIsReadOnly = realm.isReadOnly;\n    realm.isReadOnly = true;\n    try {\n      realm.errorHandler = () => {\n        throw new FatalError();\n      };\n      for (let leftElem of leftElements) {\n        for (let rightElem of rightElements) {\n          let result = ValuesDomain.computeBinary(realm, op, leftElem, rightElem);\n          invariant(result instanceof ConcreteValue);\n          resultSet.add(result);\n        }\n      }\n    } catch (e) {\n      if (e instanceof AbruptCompletion) return ValuesDomain.topVal;\n    } finally {\n      realm.errorHandler = savedHandler;\n      realm.isReadOnly = savedIsReadOnly;\n    }\n    return new ValuesDomain(resultSet);\n  }\n\n  // Note that calling this can result in user code running, which can side-effect the heap.\n  // If that is not the desired behavior, mark the realm as read-only for the duration of the call.\n  static computeBinary(realm: Realm, op: BabelBinaryOperator, lval: ConcreteValue, rval: ConcreteValue): Value {\n    if (op === \"+\") {\n      // ECMA262 12.8.3 The Addition Operator\n      let lprim = To.ToPrimitiveOrAbstract(realm, lval);\n      let rprim = To.ToPrimitiveOrAbstract(realm, rval);\n\n      if (lprim instanceof AbstractValue || rprim instanceof AbstractValue) {\n        return AbstractValue.createFromBinaryOp(realm, op, lprim, rprim);\n      }\n\n      if (lprim instanceof StringValue || rprim instanceof StringValue) {\n        let lstr = To.ToString(realm, lprim);\n        let rstr = To.ToString(realm, rprim);\n        return new StringValue(realm, lstr + rstr);\n      }\n\n      let lnum = To.ToNumber(realm, lprim);\n      let rnum = To.ToNumber(realm, rprim);\n      return Add(realm, lnum, rnum);\n    } else if (op === \"<\" || op === \">\" || op === \">=\" || op === \"<=\") {\n      // ECMA262 12.10.3\n      if (op === \"<\") {\n        let r = AbstractRelationalComparison(realm, lval, rval, true, op);\n        if (r instanceof UndefinedValue) {\n          return realm.intrinsics.false;\n        } else {\n          return r;\n        }\n      } else if (op === \"<=\") {\n        let r = AbstractRelationalComparison(realm, rval, lval, false, op);\n        if (r instanceof UndefinedValue || (r instanceof BooleanValue && r.value)) {\n          return realm.intrinsics.false;\n        } else if (r instanceof AbstractValue) {\n          return r;\n        } else {\n          return realm.intrinsics.true;\n        }\n      } else if (op === \">\") {\n        let r = AbstractRelationalComparison(realm, rval, lval, false, op);\n        if (r instanceof UndefinedValue) {\n          return realm.intrinsics.false;\n        } else {\n          return r;\n        }\n      } else if (op === \">=\") {\n        let r = AbstractRelationalComparison(realm, lval, rval, true, op);\n        if (r instanceof UndefinedValue || (r instanceof BooleanValue && r.value)) {\n          return realm.intrinsics.false;\n        } else if (r instanceof AbstractValue) {\n          return r;\n        } else {\n          return realm.intrinsics.true;\n        }\n      }\n    } else if (op === \">>>\") {\n      // ECMA262 12.9.5.1\n      let lnum = To.ToUint32(realm, lval);\n      let rnum = To.ToUint32(realm, rval);\n\n      return IntegralValue.createFromNumberValue(realm, lnum >>> rnum);\n    } else if (op === \"<<\" || op === \">>\") {\n      let lnum = To.ToInt32(realm, lval);\n      let rnum = To.ToUint32(realm, rval);\n\n      if (op === \"<<\") {\n        // ECMA262 12.9.3.1\n        return IntegralValue.createFromNumberValue(realm, lnum << rnum);\n      } else if (op === \">>\") {\n        // ECMA262 12.9.4.1\n        return IntegralValue.createFromNumberValue(realm, lnum >> rnum);\n      }\n    } else if (op === \"**\") {\n      // ECMA262 12.6.3\n\n      // 5. Let base be ? ToNumber(leftValue).\n      let base = To.ToNumberOrAbstract(realm, lval);\n\n      // 6. Let exponent be ? ToNumber(rightValue).\n      let exponent = To.ToNumberOrAbstract(realm, rval);\n\n      if (base instanceof AbstractValue || exponent instanceof AbstractValue) {\n        const baseVal = base instanceof AbstractValue ? base : new NumberValue(realm, base);\n        const exponentVal = exponent instanceof AbstractValue ? exponent : new NumberValue(realm, exponent);\n        return AbstractValue.createFromBinaryOp(realm, op, baseVal, exponentVal);\n      }\n\n      // 7. Return the result of Applying the ** operator with base and exponent as specified in 12.7.3.4.\n      return new NumberValue(realm, Math.pow(base, exponent));\n    } else if (op === \"%\" || op === \"/\" || op === \"*\" || op === \"-\") {\n      // ECMA262 12.7.3\n      let lnum = To.ToNumberOrAbstract(realm, lval);\n      let rnum = To.ToNumberOrAbstract(realm, rval);\n      if (lnum instanceof AbstractValue || rnum instanceof AbstractValue) {\n        const lnumVal = lnum instanceof AbstractValue ? lnum : new NumberValue(realm, lnum);\n        const rnumVal = rnum instanceof AbstractValue ? rnum : new NumberValue(realm, rnum);\n        return AbstractValue.createFromBinaryOp(realm, op, lnumVal, rnumVal);\n      }\n\n      if (isNaN(rnum)) return realm.intrinsics.NaN;\n      if (isNaN(lnum)) return realm.intrinsics.NaN;\n\n      if (op === \"-\") {\n        return Add(realm, lnum, rnum, true);\n      } else if (op === \"%\") {\n        // The sign of the result equals the sign of the dividend.\n        // If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.\n        // If the dividend is finite and the divisor is an infinity, the result equals the dividend.\n        // If the dividend is a zero and the divisor is nonzero and finite, the result is the same as the dividend.\n        return new NumberValue(realm, lnum % rnum);\n      } else if (op === \"/\") {\n        // The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.\n        // Division of an infinity by an infinity results in NaN.\n        // Division of an infinity by a zero results in an infinity. The sign is determined by the rule already stated above.\n        // Division of an infinity by a nonzero finite value results in a signed infinity. The sign is determined by the rule already stated above.\n        // Division of a finite value by an infinity results in zero. The sign is determined by the rule already stated above.\n        // Division of a zero by a zero results in NaN; division of zero by any other finite value results in zero, with the sign determined by the rule already stated above.\n        // Division of a nonzero finite value by a zero results in a signed infinity. The sign is determined by the rule already stated above.\n        return new NumberValue(realm, lnum / rnum);\n      } else if (op === \"*\") {\n        // The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.\n        // Multiplication of an infinity by a zero results in NaN.\n        // Multiplication of an infinity by an infinity results in an infinity. The sign is determined by the rule already stated above.\n        // Multiplication of an infinity by a finite nonzero value results in a signed infinity. The sign is determined by the rule already stated above.\n        return new NumberValue(realm, lnum * rnum);\n      }\n    } else if (op === \"!==\") {\n      return new BooleanValue(realm, !StrictEqualityComparison(realm, lval, rval));\n    } else if (op === \"===\") {\n      return new BooleanValue(realm, StrictEqualityComparison(realm, lval, rval));\n    } else if (op === \"!=\" || op === \"==\") {\n      return AbstractEqualityComparison(realm, lval, rval, op);\n    } else if (op === \"&\" || op === \"|\" || op === \"^\") {\n      // ECMA262 12.12.3\n\n      // 5. Let lnum be ? ToInt32(lval).\n      let lnum: number = To.ToInt32(realm, lval);\n\n      // 6. Let rnum be ? ToInt32(rval).\n      let rnum: number = To.ToInt32(realm, rval);\n\n      // 7. Return the result of applying the bitwise operator @ to lnum and rnum. The result is a signed 32 bit integer.\n      if (op === \"&\") {\n        return IntegralValue.createFromNumberValue(realm, lnum & rnum);\n      } else if (op === \"|\") {\n        return IntegralValue.createFromNumberValue(realm, lnum | rnum);\n      } else if (op === \"^\") {\n        return IntegralValue.createFromNumberValue(realm, lnum ^ rnum);\n      }\n    } else if (op === \"in\") {\n      // ECMA262 12.10.3\n\n      // 5. If Type(rval) is not Object, throw a TypeError exception.\n      if (!(rval instanceof ObjectValue)) {\n        throw new FatalError();\n      }\n\n      // 6. Return ? HasProperty(rval, ToPropertyKey(lval)).\n      return new BooleanValue(realm, HasProperty(realm, rval, To.ToPropertyKey(realm, lval)));\n    } else if (op === \"instanceof\") {\n      // ECMA262 12.10.3\n\n      // 5. Return ? InstanceofOperator(lval, rval).;\n      return new BooleanValue(realm, InstanceofOperator(realm, lval, rval));\n    }\n\n    invariant(false, \"unimplemented \" + op);\n  }\n\n  static logicalOp(realm: Realm, op: BabelNodeLogicalOperator, left: ValuesDomain, right: ValuesDomain): ValuesDomain {\n    let leftElements = left._elements;\n    let rightElements = right._elements;\n    // Return top if left and/or right are top or if the size of the value set would get to be quite large.\n    // Note: the larger the set of values, the less we know and therefore the less we get value from computing\n    // all of these values. TODO #1000: probably the upper bound can be quite a bit smaller.\n    if (!leftElements || !rightElements || leftElements.size > 100 || rightElements.size > 100)\n      return ValuesDomain.topVal;\n    let resultSet = new Set();\n    let savedHandler = realm.errorHandler;\n    let savedIsReadOnly = realm.isReadOnly;\n    realm.isReadOnly = true;\n    try {\n      realm.errorHandler = () => {\n        throw new FatalError();\n      };\n      for (let leftElem of leftElements) {\n        for (let rightElem of rightElements) {\n          let result = ValuesDomain.computeLogical(realm, op, leftElem, rightElem);\n          invariant(result instanceof ConcreteValue);\n          resultSet.add(result);\n        }\n      }\n    } catch (e) {\n      if (e instanceof AbruptCompletion) return ValuesDomain.topVal;\n    } finally {\n      realm.errorHandler = savedHandler;\n      realm.isReadOnly = savedIsReadOnly;\n    }\n    return new ValuesDomain(resultSet);\n  }\n\n  // Note that calling this can result in user code running, which can side-effect the heap.\n  // If that is not the desired behavior, mark the realm as read-only for the duration of the call.\n  static computeLogical(realm: Realm, op: BabelNodeLogicalOperator, lval: ConcreteValue, rval: ConcreteValue): Value {\n    let lbool = To.ToBoolean(realm, lval);\n\n    if (op === \"&&\") {\n      // ECMA262 12.13.3\n      if (lbool === false) return lval;\n    } else if (op === \"||\") {\n      // ECMA262 12.13.3\n      if (lbool === true) return lval;\n    }\n    return rval;\n  }\n\n  // Note that calling this can result in user code running, which can side-effect the heap.\n  // If that is not the desired behavior, mark the realm as read-only for the duration of the call.\n  static computeUnary(realm: Realm, op: BabelUnaryOperator, value: ConcreteValue): Value {\n    if (op === \"+\") {\n      // ECMA262 12.5.6.1\n      // 1. Let expr be the result of evaluating UnaryExpression.\n      // 2. Return ? ToNumber(? GetValue(expr)).\n      return IntegralValue.createFromNumberValue(realm, To.ToNumber(realm, value));\n    } else if (op === \"-\") {\n      // ECMA262 12.5.7.1\n      // 1. Let expr be the result of evaluating UnaryExpression.\n      // 2. Let oldValue be ? ToNumber(? GetValue(expr)).\n      let oldValue = To.ToNumber(realm, value);\n\n      // 3. If oldValue is NaN, return NaN.\n      if (isNaN(oldValue)) {\n        return realm.intrinsics.NaN;\n      }\n\n      // 4. Return the result of negating oldValue; that is, compute a Number with the same magnitude but opposite sign.\n      return IntegralValue.createFromNumberValue(realm, -oldValue);\n    } else if (op === \"~\") {\n      // ECMA262 12.5.8\n      // 1. Let expr be the result of evaluating UnaryExpression.\n      // 2. Let oldValue be ? ToInt32(? GetValue(expr)).\n      let oldValue = To.ToInt32(realm, value);\n\n      // 3. Return the result of applying bitwise complement to oldValue. The result is a signed 32-bit integer.\n      return IntegralValue.createFromNumberValue(realm, ~oldValue);\n    } else if (op === \"!\") {\n      // ECMA262 12.6.9\n      // 1. Let expr be the result of evaluating UnaryExpression.\n      // 2. Let oldValue be ToBoolean(? GetValue(expr)).\n      let oldValue = To.ToBoolean(realm, value);\n\n      // 3. If oldValue is true, return false.\n      if (oldValue === true) return realm.intrinsics.false;\n\n      // 4. Return true.\n      return realm.intrinsics.true;\n    } else if (op === \"void\") {\n      // 1. Let expr be the result of evaluating UnaryExpression.\n      // 2. Perform ? GetValue(expr).\n      // 3. Return undefined.\n      return realm.intrinsics.undefined;\n    } else if (op === \"typeof\") {\n      // ECMA262 12.6.5\n      // 1. Let val be the result of evaluating UnaryExpression.\n      // 2. If Type(val) is Reference, then\n      // 3. Let val be ? GetValue(val).\n      let val = value;\n      // 4. Return a String according to Table 35.\n      let typeString = Utils.typeToString(val.getType());\n      invariant(typeString !== undefined);\n      return new StringValue(realm, typeString);\n    } else {\n      invariant(false, `${op} is a state update, not a pure operation, so we don't support it`);\n    }\n  }\n\n  static unaryOp(realm: Realm, op: BabelUnaryOperator, operandValues: ValuesDomain): ValuesDomain {\n    let operandElements = operandValues._elements;\n    if (operandElements === undefined) return ValuesDomain.topVal;\n    let resultSet = new Set();\n    let savedHandler = realm.errorHandler;\n    let savedIsReadOnly = realm.isReadOnly;\n    realm.isReadOnly = true;\n    try {\n      realm.errorHandler = () => {\n        throw new FatalError();\n      };\n      for (let operandElem of operandElements) {\n        let result = ValuesDomain.computeUnary(realm, op, operandElem);\n        invariant(result instanceof ConcreteValue);\n        resultSet.add(result);\n      }\n    } catch (e) {\n      if (e instanceof AbruptCompletion) return ValuesDomain.topVal;\n    } finally {\n      realm.errorHandler = savedHandler;\n      realm.isReadOnly = savedIsReadOnly;\n    }\n    return new ValuesDomain(resultSet);\n  }\n\n  includesValueNotOfType(type: typeof Value): boolean {\n    invariant(!this.isTop());\n    for (let cval of this.getElements()) {\n      if (!(cval instanceof type)) return true;\n    }\n    return false;\n  }\n\n  includesValueOfType(type: typeof Value): boolean {\n    invariant(!this.isTop());\n    for (let cval of this.getElements()) {\n      if (cval instanceof type) return true;\n    }\n    return false;\n  }\n\n  mightBeFalse(): boolean {\n    invariant(!this.isTop());\n    for (let cval of this.getElements()) {\n      if (cval.mightBeFalse()) return true;\n    }\n    return false;\n  }\n\n  mightNotBeFalse(): boolean {\n    invariant(!this.isTop());\n    for (let cval of this.getElements()) {\n      if (cval.mightNotBeFalse()) return true;\n    }\n    return false;\n  }\n\n  static joinValues(realm: Realm, v1: void | Value, v2: void | Value): ValuesDomain {\n    if (v1 === undefined) v1 = realm.intrinsics.undefined;\n    if (v2 === undefined) v2 = realm.intrinsics.undefined;\n    if (v1 instanceof AbstractValue) return v1.values.joinWith(v2);\n    if (v2 instanceof AbstractValue) return v2.values.joinWith(v1);\n    let union = new Set();\n    invariant(v1 instanceof ConcreteValue);\n    union.add(v1);\n    invariant(v2 instanceof ConcreteValue);\n    union.add(v2);\n    return new ValuesDomain(union);\n  }\n\n  joinWith(y: Value): ValuesDomain {\n    if (this.isTop()) return this;\n    let union = new Set(this.getElements());\n    if (y instanceof AbstractValue) {\n      if (y.values.isTop()) return y.values;\n      y.values.getElements().forEach(v => union.add(v));\n    } else {\n      invariant(y instanceof ConcreteValue);\n      union.add(y);\n    }\n    return new ValuesDomain(union);\n  }\n\n  static meetValues(realm: Realm, v1: void | Value, v2: void | Value): ValuesDomain {\n    if (v1 === undefined) v1 = realm.intrinsics.undefined;\n    if (v2 === undefined) v2 = realm.intrinsics.undefined;\n    if (v1 instanceof AbstractValue) return v1.values.meetWith(v2);\n    if (v2 instanceof AbstractValue) return v2.values.meetWith(v1);\n    let intersection = new Set();\n    invariant(v1 instanceof ConcreteValue);\n    invariant(v2 instanceof ConcreteValue);\n    if (v1 === v2) intersection.add(v1);\n    return new ValuesDomain(intersection);\n  }\n\n  meetWith(y: Value): ValuesDomain {\n    let intersection = new Set();\n    let elements = this._elements;\n    if (y instanceof AbstractValue) {\n      if (y.values.isTop()) return this;\n      y.values.getElements().forEach(v => {\n        if (elements === undefined || elements.has(v)) intersection.add(v);\n      });\n    } else {\n      invariant(y instanceof ConcreteValue);\n      if (elements === undefined || elements.has(y)) intersection.add(y);\n    }\n    return new ValuesDomain(intersection);\n  }\n\n  promoteEmptyToUndefined(): ValuesDomain {\n    if (this.isTop()) return this;\n    let newSet = new Set();\n    for (let cval of this.getElements()) {\n      if (cval instanceof EmptyValue) newSet.add(cval.$Realm.intrinsics.undefined);\n      else newSet.add(cval);\n    }\n    return new ValuesDomain(newSet);\n  }\n}\n"]}