{"version":3,"sources":["../../src/serializer/Referentializer.js"],"names":["t","Referentializer","constructor","realm","options","scopeNameGenerator","scopeBindingNameGenerator","_options","referentializationState","Map","getStatistics","statistics","_createReferentializationState","capturedScopeInstanceIdx","capturedScopesArray","identifier","generate","capturedScopeAccessFunctionId","serializedScopes","_getReferentializationState","referentializationScope","bind","createCaptureScopeAccessFunction","body","selectorParam","captured","selectorExpression","memberExpression","cases","initializationCases","scopeBinding","values","expr","arrayExpression","initializationValues","key","code","has","set","scopeIDs","id","value","ic","get","push","forEach","i","consequent","length","expressionStatement","assignmentExpression","breakStatement","switchCase","numericLiteral","throwStatement","newExpression","stringLiteral","variableDeclaration","variableDeclarator","switchStatement","returnStatement","factoryFunction","functionExpression","blockStatement","accessFunctionId","_getReferentializationScope","residualBinding","potentialReferentializationScopes","size","scope","_getSerializedBindingScopeInstance","declarativeEnvironmentRecord","refState","name","getReferentializedScopeInitialization","scopeName","capturedScope","state","funcName","scopeArray","init","logicalExpression","callExpression","referentializeBinding","variableIndexInScope","indexExpression","serializedValue","capturedScopeExpression","serializedUnscopedLocation","referentialized","cleanInstance","instance","initializationStatements","b","residualFunctionBindings","binding","referentialize","residualBindings","undefined","modified","scopeInstances","createCapturedScopesArrayInitialization"],"mappings":"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","file":"Referentializer.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { DeclarativeEnvironmentRecord } from \"../environment.js\";\nimport type { SerializerOptions } from \"../options.js\";\nimport * as t from \"babel-types\";\nimport generate from \"babel-generator\";\nimport type { BabelNodeStatement, BabelNodeExpression, BabelNodeIdentifier } from \"babel-types\";\nimport { NameGenerator } from \"../utils/generator.js\";\nimport invariant from \"../invariant.js\";\nimport type { ResidualFunctionBinding, ScopeBinding, FunctionInstance } from \"./types.js\";\nimport { type ReferentializationScope } from \"./types.js\";\nimport { SerializerStatistics } from \"./statistics.js\";\nimport { getOrDefault } from \"./utils.js\";\nimport { Realm } from \"../realm.js\";\n\ntype ReferentializationState = {|\n  capturedScopeInstanceIdx: number,\n  capturedScopesArray: BabelNodeIdentifier,\n  capturedScopeAccessFunctionId: BabelNodeIdentifier,\n  serializedScopes: Map<DeclarativeEnvironmentRecord, ScopeBinding>,\n|};\n\n/*\n * This class helps fixup names in residual functions for variables that these\n * functions capture from parent scopes.\n * For each ReferentializationScope it creates a _get_scope_binding function\n * that contains the initialization for all of that scope's FunctionInstances\n * which will contain a switch statement with all the initializations.\n */\nexport class Referentializer {\n  constructor(\n    realm: Realm,\n    options: SerializerOptions,\n    scopeNameGenerator: NameGenerator,\n    scopeBindingNameGenerator: NameGenerator\n  ) {\n    this._options = options;\n    this.scopeNameGenerator = scopeNameGenerator;\n    this.scopeBindingNameGenerator = scopeBindingNameGenerator;\n\n    this.referentializationState = new Map();\n    this.realm = realm;\n  }\n\n  _options: SerializerOptions;\n  scopeNameGenerator: NameGenerator;\n  scopeBindingNameGenerator: NameGenerator;\n  realm: Realm;\n\n  _newCapturedScopeInstanceIdx: number;\n  referentializationState: Map<ReferentializationScope, ReferentializationState>;\n\n  getStatistics(): SerializerStatistics {\n    invariant(this.realm.statistics instanceof SerializerStatistics, \"serialization requires SerializerStatistics\");\n    return this.realm.statistics;\n  }\n\n  _createReferentializationState(): ReferentializationState {\n    return {\n      capturedScopeInstanceIdx: 0,\n      capturedScopesArray: t.identifier(this.scopeNameGenerator.generate(\"main\")),\n      capturedScopeAccessFunctionId: t.identifier(this.scopeBindingNameGenerator.generate(\"get_scope_binding\")),\n      serializedScopes: new Map(),\n    };\n  }\n\n  _getReferentializationState(referentializationScope: ReferentializationScope): ReferentializationState {\n    return getOrDefault(\n      this.referentializationState,\n      referentializationScope,\n      this._createReferentializationState.bind(this)\n    );\n  }\n\n  // Generate a shared function for accessing captured scope bindings.\n  // TODO: skip generating this function if the captured scope is not shared by multiple residual functions.\n  createCaptureScopeAccessFunction(referentializationScope: ReferentializationScope): BabelNodeStatement {\n    const body = [];\n    const selectorParam = t.identifier(\"__selector\");\n    const captured = t.identifier(\"__captured\");\n    const capturedScopesArray = this._getReferentializationState(referentializationScope).capturedScopesArray;\n    const selectorExpression = t.memberExpression(capturedScopesArray, selectorParam, /*Indexer syntax*/ true);\n\n    // One switch case for one scope.\n    const cases = [];\n    const serializedScopes = this._getReferentializationState(referentializationScope).serializedScopes;\n    type InitializationCase = {|\n      scopeIDs: Array<number>,\n      value: BabelNodeExpression,\n    |};\n    const initializationCases: Map<string, InitializationCase> = new Map();\n    for (const scopeBinding of serializedScopes.values()) {\n      const expr = t.arrayExpression((scopeBinding.initializationValues: any));\n      const key = generate(expr, {}, \"\").code;\n      if (!initializationCases.has(key)) {\n        initializationCases.set(key, {\n          scopeIDs: [scopeBinding.id],\n          value: expr,\n        });\n      } else {\n        const ic = initializationCases.get(key);\n        invariant(ic);\n        ic.scopeIDs.push(scopeBinding.id);\n      }\n    }\n    for (const ic of initializationCases.values()) {\n      ic.scopeIDs.forEach((id, i) => {\n        let consequent: Array<BabelNodeStatement> = [];\n        if (i === ic.scopeIDs.length - 1) {\n          consequent = [t.expressionStatement(t.assignmentExpression(\"=\", captured, ic.value)), t.breakStatement()];\n        }\n        cases.push(t.switchCase(t.numericLiteral(id), consequent));\n      });\n    }\n    // Default case.\n    cases.push(\n      t.switchCase(null, [\n        t.throwStatement(t.newExpression(t.identifier(\"Error\"), [t.stringLiteral(\"Unknown scope selector\")])),\n      ])\n    );\n\n    body.push(t.variableDeclaration(\"var\", [t.variableDeclarator(captured)]));\n    body.push(t.switchStatement(selectorParam, cases));\n    body.push(t.expressionStatement(t.assignmentExpression(\"=\", selectorExpression, captured)));\n    body.push(t.returnStatement(captured));\n    const factoryFunction = t.functionExpression(null, [selectorParam], t.blockStatement(body));\n    const accessFunctionId = this._getReferentializationState(referentializationScope).capturedScopeAccessFunctionId;\n    return t.variableDeclaration(\"var\", [t.variableDeclarator(accessFunctionId, factoryFunction)]);\n  }\n\n  _getReferentializationScope(residualBinding: ResidualFunctionBinding): ReferentializationScope {\n    if (residualBinding.potentialReferentializationScopes.has(\"GLOBAL\")) return \"GLOBAL\";\n    if (residualBinding.potentialReferentializationScopes.size > 1) {\n      // TODO Revisit for nested optimized functions.\n      return \"GLOBAL\";\n    }\n    for (let scope of residualBinding.potentialReferentializationScopes) return scope;\n    invariant(false);\n  }\n\n  _getSerializedBindingScopeInstance(residualBinding: ResidualFunctionBinding): ScopeBinding {\n    let declarativeEnvironmentRecord = residualBinding.declarativeEnvironmentRecord;\n    invariant(declarativeEnvironmentRecord);\n\n    let referentializationScope = this._getReferentializationScope(residualBinding);\n\n    // figure out if this is accessed only from additional functions\n    let refState: ReferentializationState = this._getReferentializationState(referentializationScope);\n    let scope = refState.serializedScopes.get(declarativeEnvironmentRecord);\n    if (!scope) {\n      scope = {\n        name: this.scopeNameGenerator.generate(),\n        id: refState.capturedScopeInstanceIdx++,\n        initializationValues: [],\n        referentializationScope,\n      };\n      refState.serializedScopes.set(declarativeEnvironmentRecord, scope);\n    }\n\n    invariant(scope.referentializationScope === referentializationScope);\n    invariant(!residualBinding.scope || residualBinding.scope === scope);\n    residualBinding.scope = scope;\n    return scope;\n  }\n\n  getReferentializedScopeInitialization(\n    scope: ScopeBinding,\n    scopeName: BabelNodeExpression\n  ): Array<BabelNodeStatement> {\n    const capturedScope = scope.capturedScope;\n    invariant(capturedScope);\n    const state = this._getReferentializationState(scope.referentializationScope);\n    const funcName = state.capturedScopeAccessFunctionId;\n    const scopeArray = state.capturedScopesArray;\n    // First get scope array entry and check if it's already initialized.\n    // Only if not yet, then call the initialization function.\n    const init = t.logicalExpression(\n      \"||\",\n      t.memberExpression(scopeArray, scopeName, true),\n      t.callExpression(funcName, [scopeName])\n    );\n    return [t.variableDeclaration(\"var\", [t.variableDeclarator(t.identifier(capturedScope), init)])];\n  }\n\n  referentializeBinding(residualBinding: ResidualFunctionBinding): void {\n    // Space for captured mutable bindings is allocated lazily.\n    let scope = this._getSerializedBindingScopeInstance(residualBinding);\n    let capturedScope = \"__captured\" + scope.name;\n    // Save the serialized value for initialization at the top of\n    // the factory.\n    // This can serialize more variables than are necessary to execute\n    // the function because every function serializes every\n    // modified variable of its parent scope. In some cases it could be\n    // an improvement to split these variables into multiple\n    // scopes.\n    const variableIndexInScope = scope.initializationValues.length;\n    const indexExpression = t.numericLiteral(variableIndexInScope);\n    invariant(residualBinding.serializedValue);\n    scope.initializationValues.push(residualBinding.serializedValue);\n    scope.capturedScope = capturedScope;\n\n    // Replace binding usage with scope references\n\n    // The rewritten .serializedValue refers to a local capturedScope variable\n    // which is only accessible from within residual functions where code\n    // to create this variable is emitted.\n    residualBinding.serializedValue = t.memberExpression(\n      t.identifier(capturedScope),\n      indexExpression,\n      true // Array style access.\n    );\n\n    // .serializedUnscopedLocation is initialized with a more general expressions\n    // that can be used outside of residual functions.\n    // TODO: Creating these expressions just in case looks expensive. Measure, and potentially only create lazily.\n    const state = this._getReferentializationState(scope.referentializationScope);\n    const funcName = state.capturedScopeAccessFunctionId;\n    const scopeArray = state.capturedScopesArray;\n    // First get scope array entry and check if it's already initialized.\n    // Only if not yet, then call the initialization function.\n    const scopeName = t.numericLiteral(scope.id);\n    const capturedScopeExpression = t.logicalExpression(\n      \"||\",\n      t.memberExpression(scopeArray, scopeName, true),\n      t.callExpression(funcName, [scopeName])\n    );\n    residualBinding.serializedUnscopedLocation = t.memberExpression(\n      capturedScopeExpression,\n      indexExpression,\n      true // Array style access.\n    );\n\n    this.getStatistics().referentialized++;\n  }\n\n  // Cleans all scopes between passes of the serializer\n  cleanInstance(instance: FunctionInstance) {\n    instance.initializationStatements = [];\n    for (let b of ((instance: any): FunctionInstance).residualFunctionBindings.values()) {\n      let binding = ((b: any): ResidualFunctionBinding);\n      if (binding.referentialized && binding.declarativeEnvironmentRecord) {\n        let declarativeEnvironmentRecord = binding.declarativeEnvironmentRecord;\n        let referentializationScope = this._getReferentializationScope(binding);\n\n        let refState = this.referentializationState.get(referentializationScope);\n        if (refState) {\n          let scope = refState.serializedScopes.get(declarativeEnvironmentRecord);\n          if (scope) {\n            scope.initializationValues = [];\n          }\n        }\n      }\n      delete binding.serializedValue;\n    }\n  }\n\n  referentialize(instance: FunctionInstance): void {\n    let residualBindings = instance.residualFunctionBindings;\n\n    for (let residualBinding of residualBindings.values()) {\n      if (residualBinding === undefined) continue;\n      if (residualBinding.modified) {\n        // Initialize captured scope at function call instead of globally\n        if (!residualBinding.declarativeEnvironmentRecord) residualBinding.referentialized = true;\n        if (!residualBinding.referentialized) {\n          this._getSerializedBindingScopeInstance(residualBinding);\n          residualBinding.referentialized = true;\n        }\n\n        invariant(residualBinding.referentialized);\n        if (residualBinding.declarativeEnvironmentRecord && residualBinding.scope) {\n          instance.scopeInstances.set(residualBinding.scope.name, residualBinding.scope);\n        }\n      }\n    }\n  }\n\n  createCapturedScopesArrayInitialization(referentializationScope: ReferentializationScope): BabelNodeStatement {\n    return t.variableDeclaration(\"var\", [\n      t.variableDeclarator(\n        this._getReferentializationState(referentializationScope).capturedScopesArray,\n        t.newExpression(t.identifier(\"Array\"), [\n          t.numericLiteral(this._getReferentializationState(referentializationScope).capturedScopeInstanceIdx),\n        ])\n      ),\n    ]);\n  }\n}\n"]}