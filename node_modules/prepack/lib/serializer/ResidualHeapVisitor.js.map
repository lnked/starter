{"version":3,"sources":["../../src/serializer/ResidualHeapVisitor.js"],"names":["t","ResidualHeapVisitor","constructor","realm","logger","modules","additionalFunctionValuesAndEffects","referentializer","useAbstractInterpretation","undefined","declarativeEnvironmentRecordsBindings","Map","globalBindings","functionInfos","classMethodInstances","functionInstances","values","conditionalFeasibility","generator","scope","globalGenerator","inspector","referencedDeclaredValues","delayedActions","equivalenceSet","additionalFunctionValueInfos","functionToCapturedScopes","environment","$GlobalEnv","environmentRecord","globalEnvironmentRecord","additionalGeneratorRoots","residualReactElementVisitor","generatorDAG","_getCommonScope","s","getParent","has","getCreator","_getAdditionalFunctionOfScope","_registerAdditionalRoot","value","creationGenerator","additionalFunction","targetAdditionalFunction","usageScope","additionalFVEffects","get","additionalRoots","add","_visitInUnrelatedScope","anyRelevantEffects","g","set","Set","effectsToApply","pb","modifiedProperties","keys","object","_withScope","f","oldScope","_enqueueWithUnrelatedScope","action","push","val","scopes","visitValue","visitObjectProperty","binding","desc","descriptor","obj","key","canIgnoreProperty","visitDescriptor","visitObjectProperties","kind","skipPrototype","temporalAlias","symbol","propertyBinding","symbols","propertyBindingKey","propertyBindingValue","properties","$FunctionKind","pathNode","unknownProperty","visitObjectPropertiesWithComputedNames","visitObjectPrototype","visitConstructorPrototype","proto","$Prototype","getKind","intrinsics","$IsClassPrototype","null","func","prototype","getPropertyValue","originalConstructor","isDefaultPrototype","absVal","cond","args","P","V","earlier_props","visitEquivalentValue","consequent","alternate","joinCondition","descriptor1","descriptor2","visitValueArray","lenProperty","isHavocedObject","evaluateWithoutLeakLogic","ToLength","visitValueMap","entries","$MapData","len","length","i","entry","$Key","$Value","visitValueWeakMap","$WeakMapData","fixpoint_rerun","progress","visitValueSet","$SetData","visitValueWeakSet","$WeakSetData","visitValueFunction","isClass","homeObject","$HomeObject","$BoundTargetFunction","$BoundThis","boundArg","$BoundArguments","formalParameters","$FormalParameters","code","$ECMAScriptCode","functionInfo","residualFunctionBindings","initializationStatements","functionValue","scopeInstances","depth","unbound","requireCalls","modified","usesArguments","usesThis","state","getModuleIdIfNodeIsRequireFunction","getGetModuleIdIfNodeIsRequireFunction","file","program","expressionStatement","functionExpression","clearCache","isResidual","size","isUnsafeResidual","logError","loc","Object","join","additionalFunctionEffects","_visitAdditionalFunction","innerName","resolveBinding","residualBinding","getBinding","visitBinding","_visitClass","_visitBindingHelper","residualFunctionBinding","declarativeEnvironmentRecord","bindings","name","deletable","initialized","refScope","potentialReferentializationScopes","funcToScopes","envRec","bindingState","capturedBindings","capturingFunctions","doesNotMatter","reference","tryQuery","ResolveBinding","$Environment","IsUnresolvableReference","base","$DeclarativeRecord","referencedBase","referencedName","getGlobalLetBinding","classFunc","classPrototype","visitClassMethod","propertyNameOrSymbol","methodFunc","methodType","isStatic","_visitClassMethod","propertyName","method","$HasEmptyConstructor","visitClassProperty","constructorFunc","classSuperNode","classMethodIsStatic","classMethodKeyNode","classMethodComputed","$HasComputedName","visitValueObject","visitReactElement","dateValue","$DateValue","buf","$ViewedArrayBuffer","react","enabled","fbLibraries","visitValueSymbol","$Description","visitValueProxy","$ProxyTarget","$ProxyHandler","_visitAbstractValueConditional","condition","cf","feasibleT","feasibleF","savedPath","pathConditions","impliesT","implies","impliesF","impliesNot","visitedT","visitedF","visitAbstractValue","n","preProcessValue","_mark","postProcessValue","equivalentValue","equivalentReactElementValue","refuseSerialization","isIntrinsic","_isScopedTemplate","isLeaf","commonScope","createGeneratorVisitCallbacks","additionalFunctionInfo","callbacks","bind","visitGenerator","parent","isParent","canSkip","recordDeclaration","recordDelayedEntry","visit","visitModifiedObjectProperty","internalSlot","error","expressionLocation","handleError","visitModifiedBinding","modifiedBinding","funcInstance","instance","newValue","otherFunc","additionalFunctionOverridesValue","otherNameVal","_SafeGetDataPropertyValue","otherNameStr","funcNameVal","funNameStr","$Realm","modifiedBindings","visitBindingAssignment","additionalEffects","withCleanEquivalenceSet","prelude","effectsGenerator","visitRoots","moduleValue","initializedModules","someReactElement","_visitReactLibrary","_visitUntilFixpoint","referentialize","actionsByGenerator","reverse","a","scopedActions","withEffectsAppliedInGlobalEnv","visited","inner","reactLibraryObject","output","createElement","reactCreateElement"],"mappings":"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","file":"ResidualHeapVisitor.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { GlobalEnvironmentRecord, DeclarativeEnvironmentRecord, EnvironmentRecord } from \"../environment.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { Realm } from \"../realm.js\";\nimport { Path } from \"../singletons.js\";\nimport type { Descriptor, PropertyBinding, ObjectKind } from \"../types.js\";\nimport type { Binding } from \"../environment.js\";\nimport { HashSet, IsArray, Get } from \"../methods/index.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  BoundFunctionValue,\n  ConcreteValue,\n  ECMAScriptFunctionValue,\n  ECMAScriptSourceFunctionValue,\n  EmptyValue,\n  FunctionValue,\n  NativeFunctionValue,\n  ObjectValue,\n  ProxyValue,\n  StringValue,\n  SymbolValue,\n  Value,\n} from \"../values/index.js\";\nimport { describeLocation } from \"../intrinsics/ecma262/Error.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNodeBlockStatement } from \"babel-types\";\nimport { Generator } from \"../utils/generator.js\";\nimport type { GeneratorEntry, VisitEntryCallbacks } from \"../utils/generator.js\";\nimport traverse from \"babel-traverse\";\nimport invariant from \"../invariant.js\";\nimport type {\n  AdditionalFunctionEffects,\n  AdditionalFunctionInfo,\n  ClassMethodInstance,\n  FunctionInfo,\n  FunctionInstance,\n  ResidualFunctionBinding,\n  ReferentializationScope,\n} from \"./types.js\";\nimport { ClosureRefVisitor } from \"./visitors.js\";\nimport { Logger } from \"../utils/logger.js\";\nimport { Modules } from \"../utils/modules.js\";\nimport { ResidualHeapInspector } from \"./ResidualHeapInspector.js\";\nimport { Referentializer } from \"./Referentializer.js\";\nimport {\n  canIgnoreClassLengthProperty,\n  ClassPropertiesToIgnore,\n  getObjectPrototypeMetadata,\n  getOrDefault,\n  getSuggestedArrayLiteralLength,\n  withDescriptorValue,\n} from \"./utils.js\";\nimport { Environment, To } from \"../singletons.js\";\nimport { isReactElement, valueIsReactLibraryObject } from \"../react/utils.js\";\nimport { ResidualReactElementVisitor } from \"./ResidualReactElementVisitor.js\";\nimport { GeneratorDAG } from \"./GeneratorDAG.js\";\n\nexport type Scope = FunctionValue | Generator;\ntype BindingState = {|\n  capturedBindings: Set<ResidualFunctionBinding>,\n  capturingFunctions: Set<FunctionValue>,\n|};\n\n/* This class visits all values that are reachable in the residual heap.\n   In particular, this \"filters out\" values that are:\n   - captured by a DeclarativeEnvironmentRecord, but not actually used by any closure.\n   - Unmodified prototype objects\n   TODO #680: Figure out minimal set of values that need to be kept alive for WeakSet and WeakMap instances.\n*/\nexport class ResidualHeapVisitor {\n  constructor(\n    realm: Realm,\n    logger: Logger,\n    modules: Modules,\n    additionalFunctionValuesAndEffects: Map<FunctionValue, AdditionalFunctionEffects>,\n    // Referentializer is null if we're just checking what values exist\n    referentializer: Referentializer | \"NO_REFERENTIALIZE\"\n  ) {\n    invariant(realm.useAbstractInterpretation);\n    this.realm = realm;\n    this.logger = logger;\n    this.modules = modules;\n    this.referentializer = referentializer === \"NO_REFERENTIALIZE\" ? undefined : referentializer;\n\n    this.declarativeEnvironmentRecordsBindings = new Map();\n    this.globalBindings = new Map();\n    this.functionInfos = new Map();\n    this.classMethodInstances = new Map();\n    this.functionInstances = new Map();\n    this.values = new Map();\n    this.conditionalFeasibility = new Map();\n    let generator = this.realm.generator;\n    invariant(generator);\n    this.scope = this.globalGenerator = generator;\n    this.inspector = new ResidualHeapInspector(realm, logger);\n    this.referencedDeclaredValues = new Map();\n    this.delayedActions = [];\n    this.additionalFunctionValuesAndEffects = additionalFunctionValuesAndEffects;\n    this.equivalenceSet = new HashSet();\n    this.additionalFunctionValueInfos = new Map();\n    this.functionToCapturedScopes = new Map();\n    let environment = realm.$GlobalEnv.environmentRecord;\n    invariant(environment instanceof GlobalEnvironmentRecord);\n    this.globalEnvironmentRecord = environment;\n    this.additionalGeneratorRoots = new Map();\n    this.residualReactElementVisitor = new ResidualReactElementVisitor(this.realm, this);\n    this.generatorDAG = new GeneratorDAG();\n  }\n\n  realm: Realm;\n  logger: Logger;\n  modules: Modules;\n  referentializer: Referentializer | void;\n  globalGenerator: Generator;\n\n  // Caches that ensure one ResidualFunctionBinding exists per (record, name) pair\n  declarativeEnvironmentRecordsBindings: Map<DeclarativeEnvironmentRecord, Map<string, ResidualFunctionBinding>>;\n  globalBindings: Map<string, ResidualFunctionBinding>;\n\n  functionToCapturedScopes: Map<ReferentializationScope, Map<DeclarativeEnvironmentRecord, BindingState>>;\n  functionInfos: Map<BabelNodeBlockStatement, FunctionInfo>;\n  scope: Scope;\n  values: Map<Value, Set<Scope>>;\n\n  // For every abstract value of kind \"conditional\", this map keeps track of whether the consequent and/or alternate is feasible in any scope\n  conditionalFeasibility: Map<AbstractValue, { t: boolean, f: boolean }>;\n  inspector: ResidualHeapInspector;\n  referencedDeclaredValues: Map<AbstractValue | ConcreteValue, void | FunctionValue>;\n  delayedActions: Array<{| scope: Scope, action: () => void | boolean |}>;\n  additionalFunctionValuesAndEffects: Map<FunctionValue, AdditionalFunctionEffects>;\n  functionInstances: Map<FunctionValue, FunctionInstance>;\n  additionalFunctionValueInfos: Map<FunctionValue, AdditionalFunctionInfo>;\n  equivalenceSet: HashSet<AbstractValue>;\n  classMethodInstances: Map<FunctionValue, ClassMethodInstance>;\n  // Parents will always be a generator, optimized function value or \"GLOBAL\"\n  additionalGeneratorRoots: Map<Generator, Set<ObjectValue>>;\n  generatorDAG: GeneratorDAG;\n  globalEnvironmentRecord: GlobalEnvironmentRecord;\n  residualReactElementVisitor: ResidualReactElementVisitor;\n\n  // Going backwards from the current scope, find either the containing\n  // additional function, or if there isn't one, return the global generator.\n  _getCommonScope(): FunctionValue | Generator {\n    let s = this.scope;\n    while (true) {\n      if (s instanceof Generator) s = this.generatorDAG.getParent(s);\n      else if (s instanceof FunctionValue) {\n        // Did we find an additional function?\n        if (this.additionalFunctionValuesAndEffects.has(s)) return s;\n\n        // Did the function itself get created by a generator we can chase?\n        s = this.generatorDAG.getCreator(s) || \"GLOBAL\";\n      } else {\n        invariant(s === \"GLOBAL\");\n        let generator = this.globalGenerator;\n        invariant(generator);\n        return generator;\n      }\n    }\n    invariant(false);\n  }\n\n  // If the current scope has a containing additional function, retrieve it.\n  _getAdditionalFunctionOfScope(): FunctionValue | void {\n    let s = this._getCommonScope();\n    return s instanceof FunctionValue ? s : undefined;\n  }\n\n  // When a value has been created by some generator that is unrelated\n  // to the current common scope, visit the value in the scope it was\n  // created --- this causes the value later to be serialized in its\n  // creation scope, ensuring that the value has the right creation / life time.\n  _registerAdditionalRoot(value: ObjectValue) {\n    let creationGenerator = this.generatorDAG.getCreator(value) || this.globalGenerator;\n\n    let additionalFunction = this._getAdditionalFunctionOfScope() || \"GLOBAL\";\n    let targetAdditionalFunction;\n    if (creationGenerator === this.globalGenerator) {\n      targetAdditionalFunction = \"GLOBAL\";\n    } else {\n      let s = creationGenerator;\n      while (s instanceof Generator) {\n        s = this.generatorDAG.getParent(s);\n        invariant(s !== undefined);\n      }\n      invariant(s === \"GLOBAL\" || s instanceof FunctionValue);\n      targetAdditionalFunction = s;\n    }\n\n    let usageScope;\n    if (additionalFunction === targetAdditionalFunction) {\n      usageScope = this.scope;\n    } else {\n      // Object was created outside of current additional function scope\n      invariant(additionalFunction instanceof FunctionValue);\n      let additionalFVEffects = this.additionalFunctionValuesAndEffects.get(additionalFunction);\n      invariant(additionalFVEffects !== undefined);\n      additionalFVEffects.additionalRoots.add(value);\n\n      this._visitInUnrelatedScope(creationGenerator, value);\n      usageScope = this.generatorDAG.getCreator(value) || this.globalGenerator;\n    }\n\n    usageScope = this.scope;\n    if (usageScope instanceof Generator) {\n      // Also check if object is used in some nested generator scope that involved\n      // applying effects; if so, store additional information that the serializer\n      // can use to proactive serialize such objects from within the right generator\n      let anyRelevantEffects = false;\n      for (let g = usageScope; g instanceof Generator; g = this.generatorDAG.getParent(g)) {\n        if (g === creationGenerator) {\n          if (anyRelevantEffects) {\n            let s = this.additionalGeneratorRoots.get(g);\n            if (s === undefined) this.additionalGeneratorRoots.set(g, (s = new Set()));\n            if (!s.has(value)) {\n              s.add(value);\n              this._visitInUnrelatedScope(g, value);\n            }\n          }\n          break;\n        }\n        let effectsToApply = g.effectsToApply;\n        if (effectsToApply)\n          for (let pb of effectsToApply.modifiedProperties.keys())\n            if (pb.object === value) {\n              anyRelevantEffects = true;\n              break;\n            }\n      }\n    }\n  }\n\n  // Careful!\n  // Only use _withScope when you know that the currently applied effects makes sense for the given (nested) scope!\n  _withScope(scope: Scope, f: () => void) {\n    let oldScope = this.scope;\n    this.scope = scope;\n    try {\n      f();\n    } finally {\n      this.scope = oldScope;\n    }\n  }\n\n  // Queues up an action to be later processed in some arbitrary scope.\n  _enqueueWithUnrelatedScope(scope: Scope, action: () => void | boolean) {\n    this.delayedActions.push({ scope, action });\n  }\n\n  // Queues up visiting a value in some arbitrary scope.\n  _visitInUnrelatedScope(scope: Scope, val: Value) {\n    let scopes = this.values.get(val);\n    if (scopes !== undefined && scopes.has(scope)) return;\n    this._enqueueWithUnrelatedScope(scope, () => this.visitValue(val));\n  }\n\n  visitObjectProperty(binding: PropertyBinding) {\n    let desc = binding.descriptor;\n    let obj = binding.object;\n    invariant(binding.key !== undefined, \"Undefined keys should never make it here.\");\n    if (\n      obj instanceof AbstractObjectValue ||\n      !(typeof binding.key === \"string\" && this.inspector.canIgnoreProperty(obj, binding.key))\n    ) {\n      if (desc !== undefined) this.visitDescriptor(desc);\n    }\n    if (binding.key instanceof Value) this.visitValue(binding.key);\n  }\n\n  visitObjectProperties(obj: ObjectValue, kind?: ObjectKind): void {\n    let { skipPrototype, constructor } = getObjectPrototypeMetadata(this.realm, obj);\n    if (obj.temporalAlias !== undefined) return;\n\n    // visit properties\n    for (let [symbol, propertyBinding] of obj.symbols) {\n      invariant(propertyBinding);\n      let desc = propertyBinding.descriptor;\n      if (desc === undefined) continue; //deleted\n      this.visitDescriptor(desc);\n      this.visitValue(symbol);\n    }\n\n    // visit properties\n    for (let [propertyBindingKey, propertyBindingValue] of obj.properties) {\n      // we don't want to visit these as we handle the serialization ourselves\n      // via a different logic route for classes\n      let descriptor = propertyBindingValue.descriptor;\n      if (\n        obj instanceof ECMAScriptFunctionValue &&\n        obj.$FunctionKind === \"classConstructor\" &&\n        (ClassPropertiesToIgnore.has(propertyBindingKey) ||\n          (propertyBindingKey === \"length\" && canIgnoreClassLengthProperty(obj, descriptor, this.logger)))\n      ) {\n        continue;\n      }\n      if (propertyBindingValue.pathNode !== undefined) continue; // property is written to inside a loop\n      invariant(propertyBindingValue);\n      this.visitObjectProperty(propertyBindingValue);\n    }\n\n    // inject properties with computed names\n    if (obj.unknownProperty !== undefined) {\n      let desc = obj.unknownProperty.descriptor;\n      if (desc !== undefined) {\n        let val = desc.value;\n        invariant(val instanceof AbstractValue);\n        this.visitObjectPropertiesWithComputedNames(val);\n      }\n    }\n\n    // prototype\n    if (!skipPrototype) {\n      this.visitObjectPrototype(obj);\n    }\n    if (obj instanceof FunctionValue) {\n      this.visitConstructorPrototype(constructor ? constructor : obj);\n    } else if (obj instanceof ObjectValue && skipPrototype && constructor) {\n      this.visitValue(constructor);\n    }\n  }\n\n  visitObjectPrototype(obj: ObjectValue) {\n    let proto = obj.$Prototype;\n\n    let kind = obj.getKind();\n    if (proto === this.realm.intrinsics[kind + \"Prototype\"]) return;\n\n    if (!obj.$IsClassPrototype || proto !== this.realm.intrinsics.null) {\n      this.visitValue(proto);\n    }\n  }\n\n  visitConstructorPrototype(func: Value) {\n    // If the original prototype object was mutated,\n    // request its serialization here as this might be observable by\n    // residual code.\n    invariant(func instanceof FunctionValue);\n    let prototype = ResidualHeapInspector.getPropertyValue(func, \"prototype\");\n    if (\n      prototype instanceof ObjectValue &&\n      prototype.originalConstructor === func &&\n      !this.inspector.isDefaultPrototype(prototype)\n    ) {\n      this.visitValue(prototype);\n    }\n  }\n\n  visitObjectPropertiesWithComputedNames(absVal: AbstractValue): void {\n    if (absVal.kind === \"widened property\") return;\n    if (absVal.kind === \"template for prototype member expression\") return;\n    if (absVal.kind === \"conditional\") {\n      let cond = absVal.args[0];\n      invariant(cond instanceof AbstractValue);\n      if (cond.kind === \"template for property name condition\") {\n        let P = cond.args[0];\n        invariant(P instanceof AbstractValue);\n        let V = absVal.args[1];\n        let earlier_props = absVal.args[2];\n        if (earlier_props instanceof AbstractValue) this.visitObjectPropertiesWithComputedNames(earlier_props);\n        this.visitValue(P);\n        this.visitValue(V);\n      } else {\n        // conditional assignment\n        absVal.args[0] = this.visitEquivalentValue(cond);\n        let consequent = absVal.args[1];\n        if (consequent instanceof AbstractValue) {\n          this.visitObjectPropertiesWithComputedNames(consequent);\n        }\n        let alternate = absVal.args[2];\n        if (alternate instanceof AbstractValue) {\n          this.visitObjectPropertiesWithComputedNames(alternate);\n        }\n      }\n    } else {\n      this.visitValue(absVal);\n    }\n  }\n\n  visitDescriptor(desc: Descriptor): void {\n    invariant(desc.value === undefined || desc.value instanceof Value);\n    if (desc.joinCondition !== undefined) {\n      desc.joinCondition = this.visitEquivalentValue(desc.joinCondition);\n      if (desc.descriptor1 !== undefined) this.visitDescriptor(desc.descriptor1);\n      if (desc.descriptor2 !== undefined) this.visitDescriptor(desc.descriptor2);\n      return;\n    }\n    if (desc.value !== undefined) desc.value = this.visitEquivalentValue(desc.value);\n    if (desc.get !== undefined) this.visitValue(desc.get);\n    if (desc.set !== undefined) this.visitValue(desc.set);\n  }\n\n  visitValueArray(val: ObjectValue): void {\n    this._registerAdditionalRoot(val);\n\n    this.visitObjectProperties(val);\n    const realm = this.realm;\n    let lenProperty;\n    if (val.isHavocedObject()) {\n      lenProperty = this.realm.evaluateWithoutLeakLogic(() => Get(realm, val, \"length\"));\n    } else {\n      lenProperty = Get(realm, val, \"length\");\n    }\n    if (\n      lenProperty instanceof AbstractValue\n        ? lenProperty.kind !== \"widened property\"\n        : To.ToLength(realm, lenProperty) !== getSuggestedArrayLiteralLength(realm, val)\n    ) {\n      this.visitValue(lenProperty);\n    }\n  }\n\n  visitValueMap(val: ObjectValue): void {\n    invariant(val.getKind() === \"Map\");\n    let entries = val.$MapData;\n\n    invariant(entries !== undefined);\n    let len = entries.length;\n\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      let key = entry.$Key;\n      let value = entry.$Value;\n      if (key === undefined || value === undefined) continue;\n      this.visitValue(key);\n      this.visitValue(value);\n    }\n  }\n\n  visitValueWeakMap(val: ObjectValue): void {\n    invariant(val.getKind() === \"WeakMap\");\n    let entries = val.$WeakMapData;\n\n    invariant(entries !== undefined);\n    let len = entries.length;\n\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      let key = entry.$Key;\n      let value = entry.$Value;\n\n      if (key !== undefined && value !== undefined) {\n        let fixpoint_rerun = () => {\n          let progress;\n          if (this.values.has(key)) {\n            progress = true;\n            this.visitValue(key);\n            this.visitValue(value);\n          } else {\n            progress = false;\n            this._enqueueWithUnrelatedScope(this.scope, fixpoint_rerun);\n          }\n          return progress;\n        };\n        fixpoint_rerun();\n      }\n    }\n  }\n\n  visitValueSet(val: ObjectValue): void {\n    invariant(val.getKind() === \"Set\");\n\n    let entries = val.$SetData;\n    invariant(entries !== undefined);\n\n    let len = entries.length;\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      if (entry === undefined) continue;\n      this.visitValue(entry);\n    }\n  }\n\n  visitValueWeakSet(val: ObjectValue): void {\n    invariant(val.getKind() === \"WeakSet\");\n\n    let entries = val.$WeakSetData;\n    invariant(entries !== undefined);\n\n    let len = entries.length;\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      if (entry !== undefined) {\n        let fixpoint_rerun = () => {\n          let progress;\n          if (this.values.has(entry)) {\n            progress = true;\n            this.visitValue(entry);\n          } else {\n            progress = false;\n            this._enqueueWithUnrelatedScope(this.scope, fixpoint_rerun);\n          }\n          return progress;\n        };\n        fixpoint_rerun();\n      }\n    }\n  }\n\n  visitValueFunction(val: FunctionValue): void {\n    let isClass = false;\n\n    this._registerAdditionalRoot(val);\n    if (val instanceof ECMAScriptFunctionValue && val.$FunctionKind === \"classConstructor\") {\n      invariant(val instanceof ECMAScriptSourceFunctionValue);\n      let homeObject = val.$HomeObject;\n      if (homeObject instanceof ObjectValue && homeObject.$IsClassPrototype) {\n        isClass = true;\n      }\n    }\n    this.visitObjectProperties(val);\n\n    if (val instanceof BoundFunctionValue) {\n      this.visitValue(val.$BoundTargetFunction);\n      this.visitValue(val.$BoundThis);\n      for (let boundArg of val.$BoundArguments) this.visitValue(boundArg);\n      return;\n    }\n\n    invariant(!(val instanceof NativeFunctionValue), \"all native function values should be intrinsics\");\n\n    invariant(val instanceof ECMAScriptSourceFunctionValue);\n    invariant(val.constructor === ECMAScriptSourceFunctionValue);\n    let formalParameters = val.$FormalParameters;\n    let code = val.$ECMAScriptCode;\n\n    let functionInfo = this.functionInfos.get(code);\n    let residualFunctionBindings = new Map();\n    this.functionInstances.set(val, {\n      residualFunctionBindings,\n      initializationStatements: [],\n      functionValue: val,\n      scopeInstances: new Map(),\n    });\n\n    if (!functionInfo) {\n      functionInfo = {\n        depth: 0,\n        unbound: new Map(),\n        requireCalls: new Map(),\n        modified: new Set(),\n        usesArguments: false,\n        usesThis: false,\n      };\n      let state = {\n        functionInfo,\n        realm: this.realm,\n        getModuleIdIfNodeIsRequireFunction: this.modules.getGetModuleIdIfNodeIsRequireFunction(formalParameters, [val]),\n      };\n\n      traverse(\n        t.file(t.program([t.expressionStatement(t.functionExpression(null, formalParameters, code))])),\n        ClosureRefVisitor,\n        null,\n        state\n      );\n      traverse.clearCache();\n      this.functionInfos.set(code, functionInfo);\n\n      if (val.isResidual && functionInfo.unbound.size) {\n        if (!val.isUnsafeResidual) {\n          this.logger.logError(\n            val,\n            `residual function ${describeLocation(this.realm, val, undefined, code.loc) ||\n              \"(unknown)\"} refers to the following identifiers defined outside of the local scope: ${Object.keys(\n              functionInfo.unbound\n            ).join(\", \")}`\n          );\n        }\n      }\n    }\n\n    let additionalFunctionEffects = this.additionalFunctionValuesAndEffects.get(val);\n    if (additionalFunctionEffects) {\n      this._visitAdditionalFunction(val, additionalFunctionEffects);\n    } else {\n      this._enqueueWithUnrelatedScope(val, () => {\n        invariant(this.scope === val);\n        invariant(functionInfo);\n        for (let innerName of functionInfo.unbound.keys()) {\n          let environment = this.resolveBinding(val, innerName);\n          let residualBinding = this.getBinding(environment, innerName);\n          this.visitBinding(val, residualBinding);\n          residualFunctionBindings.set(innerName, residualBinding);\n          if (functionInfo.modified.has(innerName)) residualBinding.modified = true;\n        }\n      });\n    }\n    if (isClass && val.$HomeObject instanceof ObjectValue) {\n      this._visitClass(val, val.$HomeObject);\n    }\n  }\n\n  _visitBindingHelper(residualFunctionBinding: ResidualFunctionBinding) {\n    let environment = residualFunctionBinding.declarativeEnvironmentRecord;\n    invariant(environment !== null);\n    if (residualFunctionBinding.value === undefined) {\n      // The first time we visit, we need to initialize the value to its equivalent value\n      invariant(environment instanceof DeclarativeEnvironmentRecord);\n      let binding = environment.bindings[residualFunctionBinding.name];\n      invariant(binding !== undefined);\n      invariant(!binding.deletable);\n      let value = (binding.initialized && binding.value) || this.realm.intrinsics.undefined;\n      residualFunctionBinding.value = this.visitEquivalentValue(value);\n    } else {\n      // Subsequently, we just need to visit the value.\n      this.visitValue(residualFunctionBinding.value);\n    }\n  }\n\n  // Addresses the case:\n  // let x = [];\n  // let y = [];\n  // function a() { x.push(\"hi\"); }\n  // function b() { y.push(\"bye\"); }\n  // function c() { return x.length + y.length; }\n  // Here we need to make sure that a and b both initialize x and y because x and y will be in the same\n  // captured scope because c captures both x and y.\n  visitBinding(val: FunctionValue, residualFunctionBinding: ResidualFunctionBinding) {\n    let environment = residualFunctionBinding.declarativeEnvironmentRecord;\n    if (environment === null) return;\n    invariant(this.scope === val);\n\n    let refScope = this._getAdditionalFunctionOfScope() || \"GLOBAL\";\n    residualFunctionBinding.potentialReferentializationScopes.add(refScope);\n    invariant(!(refScope instanceof Generator));\n    let funcToScopes = getOrDefault(this.functionToCapturedScopes, refScope, () => new Map());\n    let envRec = residualFunctionBinding.declarativeEnvironmentRecord;\n    invariant(envRec !== null);\n    let bindingState = getOrDefault(funcToScopes, envRec, () => ({\n      capturedBindings: new Set(),\n      capturingFunctions: new Set(),\n    }));\n    // If the binding is new for this bindingState, have all functions capturing bindings from that scope visit it\n    if (!bindingState.capturedBindings.has(residualFunctionBinding)) {\n      for (let functionValue of bindingState.capturingFunctions) {\n        this._enqueueWithUnrelatedScope(functionValue, () => this._visitBindingHelper(residualFunctionBinding));\n      }\n      bindingState.capturedBindings.add(residualFunctionBinding);\n    }\n    // If the function is new for this bindingState, visit all existent bindings in this scope\n    if (!bindingState.capturingFunctions.has(val)) {\n      invariant(this.scope === val);\n      for (let residualBinding of bindingState.capturedBindings) this._visitBindingHelper(residualBinding);\n      bindingState.capturingFunctions.add(val);\n    }\n  }\n\n  resolveBinding(val: FunctionValue, name: string): EnvironmentRecord {\n    let doesNotMatter = true;\n    let reference = this.logger.tryQuery(\n      () => Environment.ResolveBinding(this.realm, name, doesNotMatter, val.$Environment),\n      undefined\n    );\n    if (\n      reference === undefined ||\n      Environment.IsUnresolvableReference(this.realm, reference) ||\n      reference.base === this.globalEnvironmentRecord ||\n      reference.base === this.globalEnvironmentRecord.$DeclarativeRecord\n    ) {\n      return this.globalEnvironmentRecord;\n    } else {\n      invariant(!Environment.IsUnresolvableReference(this.realm, reference));\n      let referencedBase = reference.base;\n      let referencedName: string = (reference.referencedName: any);\n      invariant(referencedName === name);\n      invariant(referencedBase instanceof DeclarativeEnvironmentRecord);\n      return referencedBase;\n    }\n  }\n\n  // Visits a binding, returns a ResidualFunctionBinding\n  getBinding(environment: EnvironmentRecord, name: string): ResidualFunctionBinding {\n    if (environment === this.globalEnvironmentRecord.$DeclarativeRecord) environment = this.globalEnvironmentRecord;\n\n    if (environment === this.globalEnvironmentRecord) {\n      // Global Binding\n      return getOrDefault(this.globalBindings, name, () => {\n        let residualFunctionBinding = {\n          name,\n          value: undefined,\n          modified: true,\n          declarativeEnvironmentRecord: null,\n          potentialReferentializationScopes: new Set(),\n        };\n        // Queue up visiting of global binding exactly once in the globalGenerator scope.\n        this._enqueueWithUnrelatedScope(this.globalGenerator, () => {\n          let value = this.realm.getGlobalLetBinding(name);\n          if (value !== undefined) residualFunctionBinding.value = this.visitEquivalentValue(value);\n        });\n        return residualFunctionBinding;\n      });\n    } else {\n      invariant(environment instanceof DeclarativeEnvironmentRecord);\n      // DeclarativeEnvironmentRecord binding\n      let residualFunctionBindings = getOrDefault(\n        this.declarativeEnvironmentRecordsBindings,\n        environment,\n        () => new Map()\n      );\n      return getOrDefault(residualFunctionBindings, name, (): ResidualFunctionBinding => {\n        invariant(environment instanceof DeclarativeEnvironmentRecord);\n        return {\n          name,\n          value: undefined,\n          modified: false,\n          declarativeEnvironmentRecord: environment,\n          potentialReferentializationScopes: new Set(),\n        };\n      });\n      // Note that we don't yet visit the binding (and its value) here,\n      // as that should be done by a call to visitBinding, in the right scope,\n      // if the binding's incoming value is relevant.\n    }\n  }\n\n  _visitClass(classFunc: ECMAScriptSourceFunctionValue, classPrototype: ObjectValue): void {\n    let visitClassMethod = (propertyNameOrSymbol, methodFunc, methodType, isStatic) => {\n      if (methodFunc instanceof ECMAScriptSourceFunctionValue) {\n        // if the method does not have a $HomeObject, it's not a class method\n        if (methodFunc.$HomeObject !== undefined) {\n          if (methodFunc !== classFunc) {\n            this._visitClassMethod(methodFunc, methodType, classPrototype, !!isStatic);\n          }\n        }\n      }\n    };\n    for (let [propertyName, method] of classPrototype.properties) {\n      withDescriptorValue(propertyName, method.descriptor, visitClassMethod);\n    }\n    for (let [symbol, method] of classPrototype.symbols) {\n      withDescriptorValue(symbol, method.descriptor, visitClassMethod);\n    }\n\n    // handle class inheritance\n    if (!(classFunc.$Prototype instanceof NativeFunctionValue)) {\n      this.visitValue(classFunc.$Prototype);\n    }\n\n    if (classPrototype.properties.has(\"constructor\")) {\n      let constructor = classPrototype.properties.get(\"constructor\");\n\n      invariant(constructor !== undefined);\n      // check if the constructor was deleted, as it can't really be deleted\n      // it just gets set to empty (the default again)\n      if (constructor.descriptor === undefined) {\n        classFunc.$HasEmptyConstructor = true;\n      } else {\n        let visitClassProperty = (propertyNameOrSymbol, methodFunc, methodType) => {\n          visitClassMethod(propertyNameOrSymbol, methodFunc, methodType, true);\n        };\n        // check if we have any static methods we need to include\n        let constructorFunc = Get(this.realm, classPrototype, \"constructor\");\n        invariant(constructorFunc instanceof ObjectValue);\n        for (let [propertyName, method] of constructorFunc.properties) {\n          if (\n            !ClassPropertiesToIgnore.has(propertyName) &&\n            method.descriptor !== undefined &&\n            !(\n              propertyName === \"length\" && canIgnoreClassLengthProperty(constructorFunc, method.descriptor, this.logger)\n            )\n          ) {\n            withDescriptorValue(propertyName, method.descriptor, visitClassProperty);\n          }\n        }\n      }\n    }\n    this.classMethodInstances.set(classFunc, {\n      classPrototype,\n      methodType: \"constructor\",\n      classSuperNode: undefined,\n      classMethodIsStatic: false,\n      classMethodKeyNode: undefined,\n      classMethodComputed: false,\n    });\n  }\n\n  _visitClassMethod(\n    methodFunc: ECMAScriptSourceFunctionValue,\n    methodType: \"get\" | \"set\" | \"value\",\n    classPrototype: ObjectValue,\n    isStatic: boolean\n  ): void {\n    this.classMethodInstances.set(methodFunc, {\n      classPrototype,\n      methodType: methodType === \"value\" ? \"method\" : methodType,\n      classSuperNode: undefined,\n      classMethodIsStatic: isStatic,\n      classMethodKeyNode: undefined,\n      classMethodComputed: !!methodFunc.$HasComputedName,\n    });\n  }\n\n  visitValueObject(val: ObjectValue): void {\n    this._registerAdditionalRoot(val);\n    if (isReactElement(val)) {\n      this.residualReactElementVisitor.visitReactElement(val);\n      return;\n    }\n    let kind = val.getKind();\n    this.visitObjectProperties(val, kind);\n\n    // If this object is a prototype object that was implicitly created by the runtime\n    // for a constructor, then we can obtain a reference to this object\n    // in a special way that's handled alongside function serialization.\n    let constructor = val.originalConstructor;\n    if (constructor !== undefined) {\n      this.visitValue(constructor);\n      return;\n    }\n\n    switch (kind) {\n      case \"RegExp\":\n      case \"Number\":\n      case \"String\":\n      case \"Boolean\":\n      case \"ArrayBuffer\":\n        return;\n      case \"Date\":\n        let dateValue = val.$DateValue;\n        invariant(dateValue !== undefined);\n        this.visitValue(dateValue);\n        return;\n      case \"Float32Array\":\n      case \"Float64Array\":\n      case \"Int8Array\":\n      case \"Int16Array\":\n      case \"Int32Array\":\n      case \"Uint8Array\":\n      case \"Uint16Array\":\n      case \"Uint32Array\":\n      case \"Uint8ClampedArray\":\n      case \"DataView\":\n        let buf = val.$ViewedArrayBuffer;\n        invariant(buf !== undefined);\n        this.visitValue(buf);\n        return;\n      case \"Map\":\n        this.visitValueMap(val);\n        return;\n      case \"WeakMap\":\n        this.visitValueWeakMap(val);\n        return;\n      case \"Set\":\n        this.visitValueSet(val);\n        return;\n      case \"WeakSet\":\n        this.visitValueWeakSet(val);\n        return;\n      default:\n        if (kind !== \"Object\") this.logger.logError(val, `Object of kind ${kind} is not supported in residual heap.`);\n        if (this.realm.react.enabled && valueIsReactLibraryObject(this.realm, val, this.logger)) {\n          this.realm.fbLibraries.react = val;\n        }\n        return;\n    }\n  }\n\n  visitValueSymbol(val: SymbolValue): void {\n    if (val.$Description) this.visitValue(val.$Description);\n  }\n\n  visitValueProxy(val: ProxyValue): void {\n    this._registerAdditionalRoot(val);\n\n    this.visitValue(val.$ProxyTarget);\n    this.visitValue(val.$ProxyHandler);\n  }\n\n  _visitAbstractValueConditional(val: AbstractValue): void {\n    let condition = val.args[0];\n    invariant(condition instanceof AbstractValue);\n\n    let cf = this.conditionalFeasibility.get(val);\n    if (cf === undefined) this.conditionalFeasibility.set(val, (cf = { t: false, f: false }));\n\n    let feasibleT, feasibleF;\n    let savedPath = this.realm.pathConditions;\n    try {\n      this.realm.pathConditions = this.scope instanceof Generator ? this.scope.pathConditions : [];\n\n      let impliesT = Path.implies(condition);\n      let impliesF = Path.impliesNot(condition);\n      invariant(!(impliesT && impliesF));\n\n      if (!impliesT && !impliesF) {\n        feasibleT = feasibleF = true;\n      } else {\n        feasibleT = impliesT;\n        feasibleF = impliesF;\n      }\n    } finally {\n      this.realm.pathConditions = savedPath;\n    }\n\n    let visitedT = false,\n      visitedF = false;\n\n    if (!cf.t && feasibleT) {\n      val.args[1] = this.visitEquivalentValue(val.args[1]);\n      cf.t = true;\n      if (cf.f) val.args[0] = this.visitEquivalentValue(val.args[0]);\n      visitedT = true;\n    }\n\n    if (!cf.f && feasibleF) {\n      val.args[2] = this.visitEquivalentValue(val.args[2]);\n      cf.f = true;\n      if (cf.t) val.args[0] = this.visitEquivalentValue(val.args[0]);\n      visitedF = true;\n    }\n\n    if (!visitedT || !visitedF) {\n      let fixpoint_rerun = () => {\n        let progress = false;\n        invariant(cf !== undefined);\n        if (cf.f && cf.t) {\n          invariant(!visitedT || !visitedF);\n          this.visitValue(val.args[0]);\n        }\n\n        if (cf.t && !visitedT) {\n          this.visitValue(val.args[1]);\n          progress = visitedT = true;\n        }\n        invariant(cf.t === visitedT);\n\n        if (cf.f && !visitedF) {\n          this.visitValue(val.args[2]);\n          progress = visitedF = true;\n        }\n        invariant(cf.f === visitedF);\n\n        // When not all possible outcomes are assumed to be feasible yet after visiting some scopes,\n        // it might be that they do become assumed to be feasible when later visiting some other scopes.\n        // In that case, we should also re-visit the corresponding cases in this scope.\n        // To this end, calling _enqueueWithUnrelatedScope enqueues this function for later re-execution if\n        // any other visiting progress was made.\n        if (!visitedT || !visitedF) this._enqueueWithUnrelatedScope(this.scope, fixpoint_rerun);\n\n        return progress;\n      };\n\n      fixpoint_rerun();\n    }\n  }\n\n  visitAbstractValue(val: AbstractValue): void {\n    if (val.kind === \"sentinel member expression\") {\n      this.logger.logError(val, \"expressions of type o[p] are not yet supported for partially known o and unknown p\");\n    } else if (val.kind === \"conditional\") {\n      this._visitAbstractValueConditional(val);\n      return;\n    }\n    for (let i = 0, n = val.args.length; i < n; i++) {\n      val.args[i] = this.visitEquivalentValue(val.args[i]);\n    }\n  }\n\n  // Overridable hook for pre-visiting the value.\n  // Return false will tell visitor to skip visiting children of this node.\n  preProcessValue(val: Value): boolean {\n    return this._mark(val);\n  }\n\n  // Overridable hook for post-visiting the value.\n  postProcessValue(val: Value) {}\n\n  _mark(val: Value): boolean {\n    let scopes = this.values.get(val);\n    if (scopes === undefined) this.values.set(val, (scopes = new Set()));\n    if (scopes.has(this.scope)) return false;\n    scopes.add(this.scope);\n    return true;\n  }\n\n  visitEquivalentValue<T: Value>(val: T): T {\n    if (val instanceof AbstractValue) {\n      let equivalentValue = this.equivalenceSet.add(val);\n      if (this.preProcessValue(equivalentValue)) this.visitAbstractValue(equivalentValue);\n      this.postProcessValue(equivalentValue);\n      return (equivalentValue: any);\n    }\n    if (val instanceof ObjectValue && isReactElement(val)) {\n      let equivalentReactElementValue = this.residualReactElementVisitor.equivalenceSet.add(val);\n      if (this._mark(equivalentReactElementValue)) this.visitValueObject(equivalentReactElementValue);\n      return (equivalentReactElementValue: any);\n    }\n    this.visitValue(val);\n    return val;\n  }\n\n  visitValue(val: Value): void {\n    invariant(val !== undefined);\n    invariant(!(val instanceof ObjectValue && val.refuseSerialization));\n    if (val instanceof AbstractValue) {\n      if (this.preProcessValue(val)) this.visitAbstractValue(val);\n      this.postProcessValue(val);\n    } else if (val.isIntrinsic()) {\n      // All intrinsic values exist from the beginning of time...\n      // ...except for a few that come into existence as templates for abstract objects via executable code.\n      if (val instanceof ObjectValue && val._isScopedTemplate) {\n        this.preProcessValue(val);\n        this.postProcessValue(val);\n      } else\n        this._enqueueWithUnrelatedScope(this._getCommonScope(), () => {\n          this.preProcessValue(val);\n          this.postProcessValue(val);\n        });\n    } else if (val instanceof EmptyValue) {\n      this.preProcessValue(val);\n      this.postProcessValue(val);\n    } else if (ResidualHeapInspector.isLeaf(val)) {\n      this.preProcessValue(val);\n      this.postProcessValue(val);\n    } else if (IsArray(this.realm, val)) {\n      invariant(val instanceof ObjectValue);\n      if (this.preProcessValue(val)) this.visitValueArray(val);\n      this.postProcessValue(val);\n    } else if (val instanceof ProxyValue) {\n      if (this.preProcessValue(val)) this.visitValueProxy(val);\n      this.postProcessValue(val);\n    } else if (val instanceof FunctionValue) {\n      let creationGenerator = this.generatorDAG.getCreator(val) || this.globalGenerator;\n\n      // 1. Visit function in its creation scope\n      this._enqueueWithUnrelatedScope(creationGenerator, () => {\n        invariant(val instanceof FunctionValue);\n        if (this.preProcessValue(val)) this.visitValueFunction(val);\n        this.postProcessValue(val);\n      });\n\n      // 2. If current scope is not related to creation scope,\n      //    and if this is not a recursive visit, mark the usage of this function\n      //    in the common scope as well.\n      let commonScope = this._getCommonScope();\n      if (commonScope !== creationGenerator && commonScope !== val) {\n        this._enqueueWithUnrelatedScope(commonScope, () => {\n          this.preProcessValue(val);\n          this.postProcessValue(val);\n        });\n      }\n    } else if (val instanceof SymbolValue) {\n      if (this.preProcessValue(val)) this.visitValueSymbol(val);\n      this.postProcessValue(val);\n    } else {\n      invariant(val instanceof ObjectValue);\n\n      if (this.preProcessValue(val)) this.visitValueObject(val);\n      this.postProcessValue(val);\n    }\n  }\n\n  createGeneratorVisitCallbacks(additionalFunctionInfo?: AdditionalFunctionInfo): VisitEntryCallbacks {\n    let callbacks = {\n      visitEquivalentValue: this.visitEquivalentValue.bind(this),\n      visitGenerator: (generator, parent) => {\n        invariant(this.generatorDAG.isParent(parent, generator));\n        this.visitGenerator(generator, additionalFunctionInfo);\n      },\n      canSkip: (value: AbstractValue | ConcreteValue): boolean => {\n        return !this.referencedDeclaredValues.has(value) && !this.values.has(value);\n      },\n      recordDeclaration: (value: AbstractValue | ConcreteValue) => {\n        this.referencedDeclaredValues.set(value, this._getAdditionalFunctionOfScope());\n      },\n      recordDelayedEntry: (generator, entry: GeneratorEntry) => {\n        this.delayedActions.push({\n          scope: generator,\n          action: () => entry.visit(callbacks, generator),\n        });\n      },\n      visitModifiedObjectProperty: (binding: PropertyBinding) => {\n        let fixpoint_rerun = () => {\n          if (this.values.has(binding.object)) {\n            if (binding.internalSlot) {\n              invariant(typeof binding.key === \"string\");\n              let error = new CompilerDiagnostic(\n                `Internal slot ${binding.key} modified in a nested context. This is not yet supported.`,\n                binding.object.expressionLocation,\n                \"PP1006\",\n                \"FatalError\"\n              );\n              this.realm.handleError(error) === \"Fail\";\n              throw new FatalError();\n            }\n            this.visitValue(binding.object);\n            if (binding.key instanceof Value) this.visitValue(binding.key);\n            this.visitObjectProperty(binding);\n            return true;\n          } else {\n            this._enqueueWithUnrelatedScope(this.scope, fixpoint_rerun);\n            return false;\n          }\n        };\n        fixpoint_rerun();\n      },\n      visitModifiedBinding: (modifiedBinding: Binding) => {\n        invariant(additionalFunctionInfo);\n        let { functionValue } = additionalFunctionInfo;\n        invariant(functionValue instanceof ECMAScriptSourceFunctionValue);\n        let residualBinding = this.getBinding(modifiedBinding.environment, modifiedBinding.name);\n        let funcInstance = additionalFunctionInfo.instance;\n        invariant(funcInstance !== undefined);\n        funcInstance.residualFunctionBindings.set(modifiedBinding.name, residualBinding);\n        let newValue = modifiedBinding.value;\n        invariant(newValue);\n        newValue = this.visitEquivalentValue(newValue);\n        residualBinding.modified = true;\n        let otherFunc = residualBinding.additionalFunctionOverridesValue;\n        if (otherFunc !== undefined && otherFunc !== functionValue) {\n          let otherNameVal = otherFunc._SafeGetDataPropertyValue(\"name\");\n          let otherNameStr = otherNameVal instanceof StringValue ? otherNameVal.value : \"unknown function\";\n          let funcNameVal = functionValue._SafeGetDataPropertyValue(\"name\");\n          let funNameStr = funcNameVal instanceof StringValue ? funcNameVal.value : \"unknown function\";\n          let error = new CompilerDiagnostic(\n            `Variable ${\n              modifiedBinding.name\n            } written to in optimized function ${funNameStr} conflicts with write in another optimized function ${otherNameStr}`,\n            funcNameVal.expressionLocation,\n            \"PP1001\",\n            \"RecoverableError\"\n          );\n          if (functionValue.$Realm.handleError(error) === \"Fail\") throw new FatalError();\n        }\n        residualBinding.additionalFunctionOverridesValue = functionValue;\n        additionalFunctionInfo.modifiedBindings.set(modifiedBinding, residualBinding);\n        // TODO nested optimized functions: revisit adding GLOBAL as outer optimized function\n        residualBinding.potentialReferentializationScopes.add(\"GLOBAL\");\n        return [residualBinding, newValue];\n      },\n      visitBindingAssignment: (binding: Binding, value: Value) => {\n        let residualBinding = this.getBinding(binding.environment, binding.name);\n        residualBinding.modified = true;\n        return this.visitEquivalentValue(value);\n      },\n    };\n    return callbacks;\n  }\n\n  visitGenerator(generator: Generator, additionalFunctionInfo?: AdditionalFunctionInfo): void {\n    this._withScope(generator, () => {\n      generator.visit(this.createGeneratorVisitCallbacks(additionalFunctionInfo));\n    });\n\n    // We don't bother purging created objects\n  }\n\n  // result -- serialized as a return statement\n  // Generator -- visit all entries\n  // Bindings -- (modifications to named variables) only need to serialize bindings if they're\n  //             captured by a residual function\n  //          -- need to apply them and maybe need to revisit functions in ancestors to make sure\n  //             we don't overwrite anything they capture\n  // PropertyBindings -- (property modifications) visit any property bindings to pre-existing objects\n  // CreatedObjects -- should take care of itself\n  _visitAdditionalFunction(functionValue: FunctionValue, additionalEffects: AdditionalFunctionEffects) {\n    // Get Instance + Info\n    invariant(functionValue instanceof ECMAScriptSourceFunctionValue);\n    let code = functionValue.$ECMAScriptCode;\n    let functionInfo = this.functionInfos.get(code);\n    invariant(functionInfo !== undefined);\n    let funcInstance = this.functionInstances.get(functionValue);\n    invariant(funcInstance !== undefined);\n\n    // Set Visitor state\n    // Allows us to emit function declarations etc. inside of this additional\n    // function instead of adding them at global scope\n    this.residualReactElementVisitor.withCleanEquivalenceSet(() => {\n      invariant(funcInstance !== undefined);\n      invariant(functionInfo !== undefined);\n      let additionalFunctionInfo = {\n        modifiedBindings: new Map(),\n        functionValue,\n        instance: funcInstance,\n        prelude: [],\n      };\n      this.additionalFunctionValueInfos.set(functionValue, additionalFunctionInfo);\n\n      let effectsGenerator = additionalEffects.generator;\n      this.generatorDAG.add(functionValue, effectsGenerator);\n      this.visitGenerator(effectsGenerator, additionalFunctionInfo);\n    });\n  }\n\n  visitRoots(): void {\n    this.generatorDAG.add(\"GLOBAL\", this.globalGenerator);\n    this.visitGenerator(this.globalGenerator);\n    for (let moduleValue of this.modules.initializedModules.values()) this.visitValue(moduleValue);\n\n    if (this.realm.react.enabled) {\n      let fixpoint_rerun = () => {\n        let progress;\n        if (this.residualReactElementVisitor.someReactElement !== undefined) {\n          this._visitReactLibrary(this.residualReactElementVisitor.someReactElement);\n          progress = true;\n        } else {\n          this._enqueueWithUnrelatedScope(this.globalGenerator, fixpoint_rerun);\n          progress = false;\n        }\n        return progress;\n      };\n      fixpoint_rerun();\n    }\n\n    this._visitUntilFixpoint();\n\n    let referentializer = this.referentializer;\n    if (referentializer !== undefined)\n      for (let instance of this.functionInstances.values()) referentializer.referentialize(instance);\n  }\n\n  _visitUntilFixpoint() {\n    // Do a fixpoint over all pure generator entries to make sure that we visit\n    // arguments of only BodyEntries that are required by some other residual value\n    let progress = true;\n    while (progress) {\n      // Let's partition the actions by their generators,\n      // as applying effects is expensive, and so we don't want to do it\n      // more often than necessary.\n      let actionsByGenerator = new Map();\n      for (let { scope, action } of this.delayedActions.reverse()) {\n        let generator;\n        if (scope instanceof FunctionValue) generator = this.generatorDAG.getCreator(scope) || this.globalGenerator;\n        else if (scope === \"GLOBAL\") generator = this.globalGenerator;\n        else {\n          invariant(scope instanceof Generator);\n          generator = scope;\n        }\n        let a = actionsByGenerator.get(generator);\n        if (a === undefined) actionsByGenerator.set(generator, (a = []));\n        a.push({ action, scope });\n      }\n      this.delayedActions = [];\n      progress = false;\n      for (let [generator, scopedActions] of actionsByGenerator) {\n        let withEffectsAppliedInGlobalEnv: (() => void) => void = f => f();\n        let s = generator;\n        let visited = new Set();\n        while (s !== \"GLOBAL\") {\n          invariant(!visited.has(s));\n          visited.add(s);\n          if (s instanceof Generator) {\n            let effectsToApply = s.effectsToApply;\n            if (effectsToApply) {\n              let inner = withEffectsAppliedInGlobalEnv;\n              withEffectsAppliedInGlobalEnv = f => {\n                this.realm.withEffectsAppliedInGlobalEnv(() => {\n                  inner(f);\n                  return null;\n                }, effectsToApply);\n              };\n            }\n            s = this.generatorDAG.getParent(s);\n          } else if (s instanceof FunctionValue) {\n            invariant(this.additionalFunctionValuesAndEffects.has(s));\n            s = this.generatorDAG.getCreator(s) || \"GLOBAL\";\n          }\n          invariant(s instanceof Generator || s instanceof FunctionValue || s === \"GLOBAL\");\n        }\n\n        withEffectsAppliedInGlobalEnv(() => {\n          for (let { action, scope } of scopedActions) {\n            this._withScope(scope, () => {\n              if (action() !== false) progress = true;\n            });\n          }\n        });\n      }\n    }\n  }\n\n  _visitReactLibrary(someReactElement: ObjectValue) {\n    // find and visit the React library\n    let reactLibraryObject = this.realm.fbLibraries.react;\n    if (this.realm.react.output === \"jsx\") {\n      // React might not be defined in scope, i.e. another library is using JSX\n      // we don't throw an error as we should support JSX stand-alone\n      if (reactLibraryObject !== undefined) {\n        this.visitValue(reactLibraryObject);\n      }\n    } else if (this.realm.react.output === \"create-element\") {\n      let logError = () => {\n        this.logger.logError(\n          someReactElement,\n          \"unable to visit createElement due to React not being referenced in scope\"\n        );\n      };\n      // createElement output needs React in scope\n      if (reactLibraryObject === undefined) {\n        logError();\n      } else {\n        invariant(reactLibraryObject instanceof ObjectValue);\n        let createElement = reactLibraryObject.properties.get(\"createElement\");\n        if (createElement === undefined || createElement.descriptor === undefined) {\n          logError();\n        } else {\n          let reactCreateElement = Get(this.realm, reactLibraryObject, \"createElement\");\n          this.visitValue(reactCreateElement);\n        }\n      }\n    }\n  }\n}\n"]}