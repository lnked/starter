{"version":3,"sources":["../../src/serializer/ResidualReactElementVisitor.js"],"names":["ResidualReactElementVisitor","constructor","realm","residualHeapVisitor","reactOutput","react","output","someReactElement","undefined","equivalenceSet","visitReactElement","reactElement","isReactFragment","visitType","typeValue","visitValue","visitKey","keyValue","visitRef","refValue","visitAbstractOrPartialProps","propsValue","visitConcreteProps","refuseSerialization","propName","binding","properties","descriptor","propValue","visitChildNode","childValue","withCleanEquivalenceSet","func","oldReactElementEquivalenceSet"],"mappings":";;;;;;;AAWA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;AAGO,MAAMA,2BAAN,CAAkC;AACvCC,cAAYC,KAAZ,EAA0BC,mBAA1B,EAAoE;AAClE,SAAKD,KAAL,GAAaA,KAAb;AACA,SAAKC,mBAAL,GAA2BA,mBAA3B;AACA,SAAKC,WAAL,GAAmBF,MAAMG,KAAN,CAAYC,MAAZ,IAAsB,gBAAzC;AACA,SAAKC,gBAAL,GAAwBC,SAAxB;AACA,SAAKC,cAAL,GAAsB,8BAAoBP,KAApB,EAA2BC,oBAAoBM,cAA/C,CAAtB;AACD;;AAQDC,oBAAkBC,YAAlB,EAAmD;AACjD,QAAIC,kBAAkB,KAAtB;;AAEA,wCAAqB,KAAKV,KAA1B,EAAiCS,YAAjC,EAA+C;AAC7CE,iBAAYC,SAAD,IAAsB;AAC/BF,0BACEE,2CAAoCA,cAAc,2BAAe,gBAAf,EAAiC,KAAKZ,KAAtC,CADpD;AAEA;AACA,YAAI,CAACU,eAAL,EAAsB;AACpB,eAAKT,mBAAL,CAAyBY,UAAzB,CAAoCD,SAApC;AACD;AACF,OAR4C;AAS7CE,gBAAWC,QAAD,IAAqB;AAC7B,aAAKd,mBAAL,CAAyBY,UAAzB,CAAoCE,QAApC;AACD,OAX4C;AAY7CC,gBAAWC,QAAD,IAAqB;AAC7B,aAAKhB,mBAAL,CAAyBY,UAAzB,CAAoCI,QAApC;AACD,OAd4C;AAe7CC,mCAA8BC,UAAD,IAA6C;AACxE,aAAKlB,mBAAL,CAAyBY,UAAzB,CAAoCM,UAApC;AACD,OAjB4C;AAkB7CC,0BAAqBD,UAAD,IAA6B;AAC/C;AACA;AACA;AACAA,mBAAWE,mBAAX,GAAiC,IAAjC;AACA,aAAK,IAAI,CAACC,QAAD,EAAWC,OAAX,CAAT,IAAgCJ,WAAWK,UAA3C,EAAuD;AACrD,cAAID,QAAQE,UAAR,KAAuBnB,SAAvB,IAAoCgB,aAAa,UAArD,EAAiE;AAC/D,gBAAII,YAAY,wBAAY,KAAK1B,KAAjB,EAAwBmB,UAAxB,EAAoCG,QAApC,CAAhB;AACA,iBAAKrB,mBAAL,CAAyBY,UAAzB,CAAoCa,SAApC;AACD;AACF;AACF,OA7B4C;AA8B7CC,sBAAiBC,UAAD,IAAuB;AACrC,aAAK3B,mBAAL,CAAyBY,UAAzB,CAAoCe,UAApC;AACD;AAhC4C,KAA/C;;AAmCA,QAAI,KAAK5B,KAAL,CAAWG,KAAX,CAAiBC,MAAjB,KAA4B,gBAA5B,IAAgDM,eAApD,EAAqE;AACnE,WAAKL,gBAAL,GAAwBI,YAAxB;AACD;AACD;AACA,uDAAoC,KAAKT,KAAzC,EAAgDS,YAAhD,EAA8D,KAAKR,mBAAnE;AACD;;AAED4B,0BAAwBC,IAAxB,EAA0C;AACxC,QAAIC,gCAAgC,KAAKxB,cAAzC;AACA,SAAKA,cAAL,GAAsB,8BAAoB,KAAKP,KAAzB,EAAgC,KAAKC,mBAAL,CAAyBM,cAAzD,CAAtB;AACAuB;AACA;AACA,SAAKvB,cAAL,GAAsBwB,6BAAtB;AACD;AAlEsC;QAA5BjC,2B,GAAAA,2B,EApBb","file":"ResidualReactElementVisitor.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm } from \"../realm.js\";\nimport { AbstractValue, ObjectValue, SymbolValue, Value } from \"../values/index.js\";\nimport { ResidualHeapVisitor } from \"./ResidualHeapVisitor.js\";\nimport { determineIfReactElementCanBeHoisted } from \"../react/hoisting.js\";\nimport { traverseReactElement } from \"../react/elements.js\";\nimport { getProperty, getReactSymbol } from \"../react/utils.js\";\nimport ReactElementSet from \"../react/ReactElementSet.js\";\nimport type { ReactOutputTypes } from \"../options.js\";\n\nexport class ResidualReactElementVisitor {\n  constructor(realm: Realm, residualHeapVisitor: ResidualHeapVisitor) {\n    this.realm = realm;\n    this.residualHeapVisitor = residualHeapVisitor;\n    this.reactOutput = realm.react.output || \"create-element\";\n    this.someReactElement = undefined;\n    this.equivalenceSet = new ReactElementSet(realm, residualHeapVisitor.equivalenceSet);\n  }\n\n  realm: Realm;\n  residualHeapVisitor: ResidualHeapVisitor;\n  reactOutput: ReactOutputTypes;\n  someReactElement: void | ObjectValue;\n  equivalenceSet: ReactElementSet;\n\n  visitReactElement(reactElement: ObjectValue): void {\n    let isReactFragment = false;\n\n    traverseReactElement(this.realm, reactElement, {\n      visitType: (typeValue: Value) => {\n        isReactFragment =\n          typeValue instanceof SymbolValue && typeValue === getReactSymbol(\"react.fragment\", this.realm);\n        // we don't want to visit fragments as they are internal values\n        if (!isReactFragment) {\n          this.residualHeapVisitor.visitValue(typeValue);\n        }\n      },\n      visitKey: (keyValue: Value) => {\n        this.residualHeapVisitor.visitValue(keyValue);\n      },\n      visitRef: (refValue: Value) => {\n        this.residualHeapVisitor.visitValue(refValue);\n      },\n      visitAbstractOrPartialProps: (propsValue: AbstractValue | ObjectValue) => {\n        this.residualHeapVisitor.visitValue(propsValue);\n      },\n      visitConcreteProps: (propsValue: ObjectValue) => {\n        // given that props is a concrete object, it should never be serialized\n        // as we'll be doing it directly with the ReactElementSerializer\n        // so we make the object as refusing serialization\n        propsValue.refuseSerialization = true;\n        for (let [propName, binding] of propsValue.properties) {\n          if (binding.descriptor !== undefined && propName !== \"children\") {\n            let propValue = getProperty(this.realm, propsValue, propName);\n            this.residualHeapVisitor.visitValue(propValue);\n          }\n        }\n      },\n      visitChildNode: (childValue: Value) => {\n        this.residualHeapVisitor.visitValue(childValue);\n      },\n    });\n\n    if (this.realm.react.output === \"create-element\" || isReactFragment) {\n      this.someReactElement = reactElement;\n    }\n    // determine if this ReactElement node tree is going to be hoistable\n    determineIfReactElementCanBeHoisted(this.realm, reactElement, this.residualHeapVisitor);\n  }\n\n  withCleanEquivalenceSet(func: () => void) {\n    let oldReactElementEquivalenceSet = this.equivalenceSet;\n    this.equivalenceSet = new ReactElementSet(this.realm, this.residualHeapVisitor.equivalenceSet);\n    func();\n    // Cleanup\n    this.equivalenceSet = oldReactElementEquivalenceSet;\n  }\n}\n"]}