{"version":3,"sources":["../../src/serializer/ResidualReactElementSerializer.js"],"names":["t","ResidualReactElementSerializer","constructor","realm","residualHeapSerializer","logger","reactOutput","react","output","_lazilyHoistedNodes","undefined","_createReactElement","value","attributes","children","declared","type","_createReactElementAttribute","expr","key","_createReactElementChild","_emitHoistedReactElement","id","reactElement","hoistedCreateElementIdentifier","originalCreateElementIdentifier","funcId","identifier","functionNameGenerator","generate","createElementIdentifier","nodes","statement","expressionStatement","logicalExpression","binaryExpression","unaryExpression","numericLiteral","callExpression","emitter","emit","Array","isArray","push","astNode","_getReactLibraryValue","reactLibraryObject","fbLibraries","_getReactCreateElementValue","_emitReactElement","typeValue","keyValue","refValue","propsValue","shouldHoist","isReferencedOnlyByAdditionalFunction","getSerializeObjectIdentifier","reactElementAstNode","dependencies","createElement","emitNowOrAfterWaitingForDependencies","_serializeReactElementToJSXElement","serializeValue","intrinsicNameGenerator","_serializeReactElementToCreateElement","assignmentExpression","variableDeclaration","variableDeclarator","getBody","_serializeNowOrAfterWaitingForDependencies","func","shouldSerialize","reason","getReasonToWaitForDependencies","serialize","emitAfterWaiting","_serializeReactFragmentType","memberExpression","serializeReactElement","val","visitType","residualHeapValueIdentifiers","incrementReferenceCount","visitKey","reactElementKey","visitRef","reactElementRef","visitAbstractOrPartialProps","reactElementSpread","visitConcreteProps","propName","binding","properties","descriptor","propValue","reactElementAttribute","visitChildNode","childValue","_serializeReactElementChild","_addSerializedValueToJSXAttriutes","prop","jSXSpreadAttribute","createElementArguments","length","astAttributes","attribute","spreadProperty","attributeKey","includes","stringLiteral","objectProperty","objectExpression","nullLiteral","astChildren","child","createElementCall","_addBailOutMessageToBabelNode","jsxTypeIdentifer","isStringLiteral","isNumericLiteral","jSXText","isJSXElement","jSXExpressionContainer","openingElement","jSXOpeningElement","closingElement","jSXClosingElement","jsxElement","jSXElement","node","$BailOutReason","leadingComments","reactElementChild","serializeLazyHoistedNodes","entries","functionExpression","blockStatement","map"],"mappings":"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","file":"ResidualReactElementSerializer.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm } from \"../realm.js\";\nimport { ResidualHeapSerializer } from \"./ResidualHeapSerializer.js\";\nimport { canHoistReactElement } from \"../react/hoisting.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNode, BabelNodeExpression } from \"babel-types\";\nimport { AbstractValue, ObjectValue, SymbolValue, Value } from \"../values/index.js\";\nimport { convertExpressionToJSXIdentifier, convertKeyValueToJSXAttribute } from \"../react/jsx.js\";\nimport { Logger } from \"../utils/logger.js\";\nimport invariant from \"../invariant.js\";\nimport { FatalError } from \"../errors\";\nimport { traverseReactElement } from \"../react/elements.js\";\nimport { getReactSymbol, getProperty } from \"../react/utils.js\";\nimport type { ReactOutputTypes } from \"../options.js\";\nimport type { LazilyHoistedNodes } from \"./types.js\";\n\ntype ReactElementAttributeType = \"SPREAD\" | \"PROPERTY\" | \"PENDING\";\ntype ReactElementChildType = \"NORMAL\" | \"PENDING\";\n\ntype ReactElementChild = {\n  expr: void | BabelNodeExpression,\n  type: ReactElementChildType,\n};\n\ntype ReactElementAttribute = {\n  expr: void | BabelNodeExpression,\n  key: void | string,\n  type: ReactElementAttributeType,\n};\n\ntype ReactElement = {\n  attributes: Array<ReactElementAttribute>,\n  children: Array<ReactElementChild>,\n  declared: boolean,\n  type: void | BabelNodeExpression,\n  value: ObjectValue,\n};\n\nexport class ResidualReactElementSerializer {\n  constructor(realm: Realm, residualHeapSerializer: ResidualHeapSerializer) {\n    this.realm = realm;\n    this.residualHeapSerializer = residualHeapSerializer;\n    this.logger = residualHeapSerializer.logger;\n    this.reactOutput = realm.react.output || \"create-element\";\n    this._lazilyHoistedNodes = undefined;\n  }\n\n  realm: Realm;\n  logger: Logger;\n  reactOutput: ReactOutputTypes;\n  residualHeapSerializer: ResidualHeapSerializer;\n  _lazilyHoistedNodes: void | LazilyHoistedNodes;\n\n  _createReactElement(value: ObjectValue): ReactElement {\n    return { attributes: [], children: [], declared: false, type: undefined, value };\n  }\n\n  _createReactElementAttribute(): ReactElementAttribute {\n    return { expr: undefined, key: undefined, type: \"PENDING\" };\n  }\n\n  _createReactElementChild(): ReactElementChild {\n    return { expr: undefined, type: \"PENDING\" };\n  }\n\n  _emitHoistedReactElement(\n    id: BabelNodeExpression,\n    reactElement: BabelNodeExpression,\n    hoistedCreateElementIdentifier: BabelNodeIdentifier,\n    originalCreateElementIdentifier: BabelNodeIdentifier\n  ) {\n    // if the currentHoistedReactElements is not defined, we create it an emit the function call\n    // this should only occur once per additional function\n    if (this._lazilyHoistedNodes === undefined) {\n      let funcId = t.identifier(this.residualHeapSerializer.functionNameGenerator.generate());\n      this._lazilyHoistedNodes = {\n        id: funcId,\n        createElementIdentifier: hoistedCreateElementIdentifier,\n        nodes: [],\n      };\n      let statement = t.expressionStatement(\n        t.logicalExpression(\n          \"&&\",\n          t.binaryExpression(\"===\", id, t.unaryExpression(\"void\", t.numericLiteral(0), true)),\n          // pass the createElementIdentifier if it's not null\n          t.callExpression(funcId, originalCreateElementIdentifier ? [originalCreateElementIdentifier] : [])\n        )\n      );\n      this.residualHeapSerializer.emitter.emit(statement);\n    }\n    // we then push the reactElement and its id into our list of elements to process after\n    // the current additional function has serialzied\n    invariant(this._lazilyHoistedNodes !== undefined);\n    invariant(Array.isArray(this._lazilyHoistedNodes.nodes));\n    this._lazilyHoistedNodes.nodes.push({ id, astNode: reactElement });\n  }\n\n  _getReactLibraryValue() {\n    let reactLibraryObject = this.realm.fbLibraries.react;\n    // if there is no React library, then we should throw and error\n    if (reactLibraryObject === undefined) {\n      throw new FatalError(\"unable to find React library reference in scope\");\n    }\n    return reactLibraryObject;\n  }\n\n  _getReactCreateElementValue() {\n    let reactLibraryObject = this._getReactLibraryValue();\n    return getProperty(this.realm, reactLibraryObject, \"createElement\");\n  }\n\n  _emitReactElement(reactElement: ReactElement): BabelNodeExpression {\n    let { value } = reactElement;\n    let typeValue = getProperty(this.realm, value, \"type\");\n    let keyValue = getProperty(this.realm, value, \"key\");\n    let refValue = getProperty(this.realm, value, \"ref\");\n    let propsValue = getProperty(this.realm, value, \"props\");\n\n    let shouldHoist =\n      this.residualHeapSerializer.isReferencedOnlyByAdditionalFunction(value) !== undefined &&\n      canHoistReactElement(this.realm, value);\n\n    let id = this.residualHeapSerializer.getSerializeObjectIdentifier(value);\n    // this identifier is used as the deafult, but also passed to the hoisted factory function\n    let originalCreateElementIdentifier = null;\n    // this name is used when hoisting, and is passed into the factory function, rather than the original\n    let hoistedCreateElementIdentifier = null;\n    let reactElementAstNode;\n    let dependencies = [typeValue, keyValue, refValue, propsValue, value];\n    let createElement;\n\n    if (this.reactOutput === \"create-element\") {\n      createElement = this._getReactCreateElementValue();\n      dependencies.push(createElement);\n    }\n\n    this.residualHeapSerializer.emitter.emitNowOrAfterWaitingForDependencies(\n      dependencies,\n      () => {\n        if (this.reactOutput === \"jsx\") {\n          reactElementAstNode = this._serializeReactElementToJSXElement(value, reactElement);\n        } else if (this.reactOutput === \"create-element\") {\n          originalCreateElementIdentifier = this.residualHeapSerializer.serializeValue(createElement);\n\n          if (shouldHoist) {\n            // if we haven't created a _lazilyHoistedNodes before, then this is the first time\n            // so we only create the hoisted identifier once\n            if (this._lazilyHoistedNodes === undefined) {\n              // create a new unique instance\n              hoistedCreateElementIdentifier = t.identifier(\n                this.residualHeapSerializer.intrinsicNameGenerator.generate()\n              );\n            } else {\n              hoistedCreateElementIdentifier = this._lazilyHoistedNodes.createElementIdentifier;\n            }\n          }\n\n          let createElementIdentifier = shouldHoist ? hoistedCreateElementIdentifier : originalCreateElementIdentifier;\n          reactElementAstNode = this._serializeReactElementToCreateElement(\n            value,\n            reactElement,\n            createElementIdentifier\n          );\n        } else {\n          invariant(false, \"Unknown reactOutput specified\");\n        }\n        // if we are hoisting this React element, put the assignment in the body\n        // also ensure we are in an additional function\n        if (shouldHoist) {\n          this._emitHoistedReactElement(\n            id,\n            reactElementAstNode,\n            hoistedCreateElementIdentifier,\n            originalCreateElementIdentifier\n          );\n        } else {\n          // Note: it can be expected that we assign to the same variable multiple times\n          // this is due to fact ReactElements are immutable objects and the fact that\n          // when we inline/fold logic, the same ReactElements are referenced at different\n          // points with different attributes. Given we can't mutate an immutable object,\n          // we instead create new objects and assign to the same binding\n          if (reactElement.declared) {\n            this.residualHeapSerializer.emitter.emit(\n              t.expressionStatement(t.assignmentExpression(\"=\", id, reactElementAstNode))\n            );\n          } else {\n            reactElement.declared = true;\n            this.residualHeapSerializer.emitter.emit(\n              t.variableDeclaration(\"var\", [t.variableDeclarator(id, reactElementAstNode)])\n            );\n          }\n        }\n      },\n      this.residualHeapSerializer.emitter.getBody()\n    );\n    return id;\n  }\n\n  _serializeNowOrAfterWaitingForDependencies(\n    value: Value,\n    reactElement: ReactElement,\n    func: () => void | BabelNode,\n    shouldSerialize?: boolean = true\n  ): void {\n    let reason = this.residualHeapSerializer.emitter.getReasonToWaitForDependencies(value);\n\n    const serialize = () => {\n      func();\n    };\n\n    if (reason) {\n      this.residualHeapSerializer.emitter.emitAfterWaiting(\n        reason,\n        [value],\n        () => {\n          serialize();\n          this._emitReactElement(reactElement);\n        },\n        this.residualHeapSerializer.emitter.getBody()\n      );\n    } else {\n      serialize();\n    }\n  }\n\n  _serializeReactFragmentType(typeValue: SymbolValue): BabelNodeExpression {\n    let reactLibraryObject = this._getReactLibraryValue();\n    return t.memberExpression(this.residualHeapSerializer.serializeValue(reactLibraryObject), t.identifier(\"Fragment\"));\n  }\n\n  serializeReactElement(val: ObjectValue): BabelNodeExpression {\n    let reactElement = this._createReactElement(val);\n\n    traverseReactElement(this.realm, reactElement.value, {\n      visitType: (typeValue: Value) => {\n        this._serializeNowOrAfterWaitingForDependencies(typeValue, reactElement, () => {\n          let expr;\n\n          if (typeValue instanceof SymbolValue && typeValue === getReactSymbol(\"react.fragment\", this.realm)) {\n            expr = this._serializeReactFragmentType(typeValue);\n          } else {\n            expr = this.residualHeapSerializer.serializeValue(typeValue);\n            // Increment ref count one more time to ensure that this object will be assigned a unique id.\n            // Abstract values that are emitted as first argument to JSX elements needs a proper id.\n            this.residualHeapSerializer.residualHeapValueIdentifiers.incrementReferenceCount(typeValue);\n          }\n          reactElement.type = expr;\n        });\n      },\n      visitKey: (keyValue: Value) => {\n        let reactElementKey = this._createReactElementAttribute();\n        this._serializeNowOrAfterWaitingForDependencies(keyValue, reactElement, () => {\n          let expr = this.residualHeapSerializer.serializeValue(keyValue);\n          reactElementKey.expr = expr;\n          reactElementKey.key = \"key\";\n          reactElementKey.type = \"PROPERTY\";\n        });\n        reactElement.attributes.push(reactElementKey);\n      },\n      visitRef: (refValue: Value) => {\n        let reactElementRef = this._createReactElementAttribute();\n        this._serializeNowOrAfterWaitingForDependencies(refValue, reactElement, () => {\n          let expr = this.residualHeapSerializer.serializeValue(refValue);\n          reactElementRef.expr = expr;\n          reactElementRef.key = \"ref\";\n          reactElementRef.type = \"PROPERTY\";\n        });\n        reactElement.attributes.push(reactElementRef);\n      },\n      visitAbstractOrPartialProps: (propsValue: AbstractValue | ObjectValue) => {\n        let reactElementSpread = this._createReactElementAttribute();\n        this._serializeNowOrAfterWaitingForDependencies(propsValue, reactElement, () => {\n          let expr = this.residualHeapSerializer.serializeValue(propsValue);\n          reactElementSpread.expr = expr;\n          reactElementSpread.type = \"SPREAD\";\n        });\n        reactElement.attributes.push(reactElementSpread);\n      },\n      visitConcreteProps: (propsValue: ObjectValue) => {\n        for (let [propName, binding] of propsValue.properties) {\n          if (binding.descriptor !== undefined && propName !== \"children\") {\n            invariant(propName !== \"key\" && propName !== \"ref\", `\"${propName}\" is a reserved prop name`);\n            let propValue = getProperty(this.realm, propsValue, propName);\n            let reactElementAttribute = this._createReactElementAttribute();\n\n            this._serializeNowOrAfterWaitingForDependencies(propValue, reactElement, () => {\n              let expr = this.residualHeapSerializer.serializeValue(propValue);\n              reactElementAttribute.expr = expr;\n              reactElementAttribute.key = propName;\n              reactElementAttribute.type = \"PROPERTY\";\n            });\n            reactElement.attributes.push(reactElementAttribute);\n          }\n        }\n      },\n      visitChildNode: (childValue: Value) => {\n        reactElement.children.push(this._serializeReactElementChild(childValue, reactElement));\n      },\n    });\n    return this._emitReactElement(reactElement);\n  }\n\n  _addSerializedValueToJSXAttriutes(prop: string | null, expr: any, attributes: Array<BabelNode>): void {\n    if (prop === null) {\n      attributes.push(t.jSXSpreadAttribute(expr));\n    } else {\n      attributes.push(convertKeyValueToJSXAttribute(prop, expr));\n    }\n  }\n\n  _serializeReactElementToCreateElement(\n    val: ObjectValue,\n    reactElement: ReactElement,\n    createElementIdentifier: BabelNodeIdentifier\n  ): BabelNodeExpression {\n    let { type, attributes, children } = reactElement;\n\n    let createElementArguments = [type];\n    // check if we need to add attributes\n    if (attributes.length !== 0) {\n      let astAttributes = [];\n      for (let attribute of attributes) {\n        let expr = ((attribute.expr: any): BabelNodeExpression);\n\n        if (attribute.type === \"SPREAD\") {\n          astAttributes.push(t.spreadProperty(expr));\n        } else if (attribute.type === \"PROPERTY\") {\n          let attributeKey = attribute.key;\n          let key;\n\n          invariant(typeof attributeKey === \"string\");\n          if (attributeKey.includes(\"-\")) {\n            key = t.stringLiteral(attributeKey);\n          } else {\n            key = t.identifier(attributeKey);\n          }\n          astAttributes.push(t.objectProperty(key, expr));\n        }\n      }\n      createElementArguments.push(t.objectExpression(astAttributes));\n    }\n    if (children.length !== 0) {\n      if (attributes.length === 0) {\n        createElementArguments.push(t.nullLiteral());\n      }\n      let astChildren = [];\n      for (let child of children) {\n        let expr = ((child.expr: any): BabelNodeExpression);\n\n        if (child.type === \"NORMAL\") {\n          astChildren.push(expr);\n        }\n      }\n      createElementArguments.push(...astChildren);\n    }\n    // cast to any for createElementArguments as casting it to BabelNodeExpresion[] isn't working\n    let createElementCall = t.callExpression(createElementIdentifier, (createElementArguments: any));\n    this._addBailOutMessageToBabelNode(val, createElementCall);\n    return createElementCall;\n  }\n\n  _serializeReactElementToJSXElement(val: ObjectValue, reactElement: ReactElement): BabelNodeExpression {\n    let { type, attributes, children } = reactElement;\n\n    let jsxTypeIdentifer = convertExpressionToJSXIdentifier(((type: any): BabelNodeIdentifier), true);\n    let astAttributes = [];\n    for (let attribute of attributes) {\n      let expr = ((attribute.expr: any): BabelNodeExpression);\n\n      if (attribute.type === \"SPREAD\") {\n        astAttributes.push(t.jSXSpreadAttribute(expr));\n      } else if (attribute.type === \"PROPERTY\") {\n        let attributeKey = attribute.key;\n        invariant(typeof attributeKey === \"string\");\n        astAttributes.push(convertKeyValueToJSXAttribute(attributeKey, expr));\n      }\n    }\n\n    let astChildren = [];\n    for (let child of children) {\n      let expr = ((child.expr: any): BabelNodeExpression);\n\n      if (child.type === \"NORMAL\") {\n        if (t.isStringLiteral(expr) || t.isNumericLiteral(expr)) {\n          astChildren.push(t.jSXText(((expr: any).value: string) + \"\"));\n        } else if (t.isJSXElement(expr)) {\n          astChildren.push(expr);\n        } else {\n          astChildren.push(t.jSXExpressionContainer(expr));\n        }\n      }\n    }\n\n    let openingElement = t.jSXOpeningElement(jsxTypeIdentifer, (astAttributes: any), astChildren.length === 0);\n    let closingElement = t.jSXClosingElement(jsxTypeIdentifer);\n    let jsxElement = t.jSXElement(openingElement, closingElement, astChildren, astChildren.length === 0);\n    this._addBailOutMessageToBabelNode(val, jsxElement);\n    return jsxElement;\n  }\n\n  _addBailOutMessageToBabelNode(val: ObjectValue, node: BabelNode): void {\n    // if there has been a bail-out, we create an inline BlockComment node before the JSX element\n    if (val.$BailOutReason !== undefined) {\n      // $BailOutReason contains an optional string of what to print out in the comment\n      node.leadingComments = [({ type: \"BlockComment\", value: `${val.$BailOutReason}` }: any)];\n    }\n  }\n\n  _serializeReactElementChild(child: Value, reactElement: ReactElement): ReactElementChild {\n    let reactElementChild = this._createReactElementChild();\n    this._serializeNowOrAfterWaitingForDependencies(child, reactElement, () => {\n      let expr = this.residualHeapSerializer.serializeValue(child);\n\n      reactElementChild.expr = expr;\n      reactElementChild.type = \"NORMAL\";\n    });\n    return reactElementChild;\n  }\n\n  serializeLazyHoistedNodes() {\n    const entries = [];\n    if (this._lazilyHoistedNodes !== undefined) {\n      let { id, nodes, createElementIdentifier } = this._lazilyHoistedNodes;\n      // create a function that initializes all the hoisted nodes\n      let func = t.functionExpression(\n        null,\n        // use createElementIdentifier if it's not null\n        createElementIdentifier ? [createElementIdentifier] : [],\n        t.blockStatement(nodes.map(node => t.expressionStatement(t.assignmentExpression(\"=\", node.id, node.astNode))))\n      );\n      // push it to the mainBody of the module\n      entries.push(t.variableDeclaration(\"var\", [t.variableDeclarator(id, func)]));\n      // output all the empty variable declarations that will hold the nodes lazily\n      entries.push(...nodes.map(node => t.variableDeclaration(\"var\", [t.variableDeclarator(node.id)])));\n      // reset the _lazilyHoistedNodes so other additional functions work\n      this._lazilyHoistedNodes = undefined;\n    }\n    return entries;\n  }\n}\n"]}