"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResidualReactElementVisitor = undefined;

var _realm = require("../realm.js");

var _index = require("../values/index.js");

var _ResidualHeapVisitor = require("./ResidualHeapVisitor.js");

var _hoisting = require("../react/hoisting.js");

var _elements = require("../react/elements.js");

var _utils = require("../react/utils.js");

var _ReactElementSet = require("../react/ReactElementSet.js");

var _ReactElementSet2 = _interopRequireDefault(_ReactElementSet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ResidualReactElementVisitor {
  constructor(realm, residualHeapVisitor) {
    this.realm = realm;
    this.residualHeapVisitor = residualHeapVisitor;
    this.reactOutput = realm.react.output || "create-element";
    this.someReactElement = undefined;
    this.equivalenceSet = new _ReactElementSet2.default(realm, residualHeapVisitor.equivalenceSet);
  }

  visitReactElement(reactElement) {
    let isReactFragment = false;

    (0, _elements.traverseReactElement)(this.realm, reactElement, {
      visitType: typeValue => {
        isReactFragment = typeValue instanceof _index.SymbolValue && typeValue === (0, _utils.getReactSymbol)("react.fragment", this.realm);
        // we don't want to visit fragments as they are internal values
        if (!isReactFragment) {
          this.residualHeapVisitor.visitValue(typeValue);
        }
      },
      visitKey: keyValue => {
        this.residualHeapVisitor.visitValue(keyValue);
      },
      visitRef: refValue => {
        this.residualHeapVisitor.visitValue(refValue);
      },
      visitAbstractOrPartialProps: propsValue => {
        this.residualHeapVisitor.visitValue(propsValue);
      },
      visitConcreteProps: propsValue => {
        // given that props is a concrete object, it should never be serialized
        // as we'll be doing it directly with the ReactElementSerializer
        // so we make the object as refusing serialization
        propsValue.refuseSerialization = true;
        for (let [propName, binding] of propsValue.properties) {
          if (binding.descriptor !== undefined && propName !== "children") {
            let propValue = (0, _utils.getProperty)(this.realm, propsValue, propName);
            this.residualHeapVisitor.visitValue(propValue);
          }
        }
      },
      visitChildNode: childValue => {
        this.residualHeapVisitor.visitValue(childValue);
      }
    });

    if (this.realm.react.output === "create-element" || isReactFragment) {
      this.someReactElement = reactElement;
    }
    // determine if this ReactElement node tree is going to be hoistable
    (0, _hoisting.determineIfReactElementCanBeHoisted)(this.realm, reactElement, this.residualHeapVisitor);
  }

  withCleanEquivalenceSet(func) {
    let oldReactElementEquivalenceSet = this.equivalenceSet;
    this.equivalenceSet = new _ReactElementSet2.default(this.realm, this.residualHeapVisitor.equivalenceSet);
    func();
    // Cleanup
    this.equivalenceSet = oldReactElementEquivalenceSet;
  }
}
exports.ResidualReactElementVisitor = ResidualReactElementVisitor; /**
                                                                    * Copyright (c) 2017-present, Facebook, Inc.
                                                                    * All rights reserved.
                                                                    *
                                                                    * This source code is licensed under the BSD-style license found in the
                                                                    * LICENSE file in the root directory of this source tree. An additional grant
                                                                    * of patent rights can be found in the PATENTS file in the same directory.
                                                                    */
//# sourceMappingURL=ResidualReactElementVisitor.js.map