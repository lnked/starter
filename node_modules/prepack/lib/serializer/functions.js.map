{"version":3,"sources":["../../src/serializer/functions.js"],"names":["t","Functions","constructor","realm","moduleTracer","writeEffects","Map","functionExpressions","_noopFunction","undefined","__optimizedFunctionEntryOfValue","value","config","rootComponent","validConfig","intrinsics","validRootComponent","location","expressionLocation","start","line","column","end","handleError","__generateInitialAdditionalFunctions","globalKey","recordedAdditionalFunctions","globalRecordedAdditionalFunctionsMap","modules","logger","tryQuery","$GlobalObject","funcId","getOwnPropertyKeysArray","property","properties","get","descriptor","entry","push","optimizeReactComponentTreeRoots","statistics","reactSerializerState","environmentRecordIdAfterGlobalCode","recordedReactRootValues","react","verbose","logInformation","length","componentRoot","_callOfFunction","funcValue","call","$Call","numArgs","getLength","args","params","$FormalParameters","parameterId","isIdentifier","createAbstractArgument","name","thisArg","bind","checkThatFunctionsAreIndependent","additionalFunctionsToProcess","additionalFunctionStack","additionalFunctions","Set","map","optimizedFunctionsObject","getDeclaringAdditionalFunction","functionValue","additionalFunctionValue","additionalEffects","createdObjects","effects","has","getEffectsFromAdditionalFunctionAndNestedFunctions","evaluatePure","evaluateForEffectsInGlobalEnv","additionalFunctionEffects","set","modifiedProperties","withEffectsAppliedInGlobalEnv","propertyBinding","object","newValue","newEntry","add","pop","shift","conflicts","fun1","fun1Name","intrinsicName","e1","result","error","fun2","reportFn","reportWriteConflicts","fun2Effects","parentAdditionalFunction","parentEffects","size","diagnostic","values","getAdditionalFunctionValuesToEffects","fname","pbs","call2","reportConflict","writtenObjects","forEach","val","key","m","oldReportObjectGetOwnProperties","reportObjectGetOwnProperties","ob","currentLocation","oldReportPropertyAccess","reportPropertyAccess","pb","refuseSerialization"],"mappings":"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","file":"functions.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelNodeSourceLocation } from \"babel-types\";\nimport { Completion, PossiblyNormalCompletion } from \"../completions.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport invariant from \"../invariant.js\";\nimport { type Effects, type PropertyBindings, Realm } from \"../realm.js\";\nimport type { PropertyBinding, ReactComponentTreeConfig } from \"../types.js\";\nimport { ignoreErrorsIn } from \"../utils/errors.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  ECMAScriptSourceFunctionValue,\n  FunctionValue,\n  ObjectValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport { Get } from \"../methods/index.js\";\nimport { ModuleTracer } from \"../utils/modules.js\";\nimport { createAdditionalEffects } from \"./utils.js\";\nimport { ReactStatistics } from \"./types\";\nimport type { AdditionalFunctionEffects, ReactSerializerState, WriteEffects } from \"./types\";\nimport { convertConfigObjectToReactComponentTreeConfig, valueIsKnownReactAbstraction } from \"../react/utils.js\";\nimport { applyOptimizedReactComponents, optimizeReactComponentTreeRoot } from \"../react/optimizing.js\";\nimport * as t from \"babel-types\";\n\ntype AdditionalFunctionEntry = {\n  value: ECMAScriptSourceFunctionValue | AbstractValue,\n  config?: ReactComponentTreeConfig,\n};\n\nexport class Functions {\n  constructor(realm: Realm, moduleTracer: ModuleTracer) {\n    this.realm = realm;\n    this.moduleTracer = moduleTracer;\n    this.writeEffects = new Map();\n    this.functionExpressions = new Map();\n    this._noopFunction = undefined;\n  }\n\n  realm: Realm;\n  // maps back from FunctionValue to the expression string\n  functionExpressions: Map<FunctionValue, string>;\n  moduleTracer: ModuleTracer;\n  writeEffects: WriteEffects;\n  _noopFunction: void | ECMAScriptSourceFunctionValue;\n\n  __optimizedFunctionEntryOfValue(value: Value): AdditionalFunctionEntry | void {\n    let realm = this.realm;\n    if (value instanceof ECMAScriptSourceFunctionValue) {\n      // additional function logic\n      return { value };\n    } else if (value instanceof ObjectValue) {\n      // React component tree logic\n      let config = Get(realm, value, \"config\");\n      let rootComponent = Get(realm, value, \"rootComponent\");\n      let validConfig = config instanceof ObjectValue || config === realm.intrinsics.undefined;\n      let validRootComponent =\n        rootComponent instanceof ECMAScriptSourceFunctionValue ||\n        (rootComponent instanceof AbstractValue && valueIsKnownReactAbstraction(this.realm, rootComponent));\n\n      if (validConfig && validRootComponent) {\n        return {\n          value: ((rootComponent: any): AbstractValue | ECMAScriptSourceFunctionValue),\n          config: convertConfigObjectToReactComponentTreeConfig(realm, ((config: any): ObjectValue | UndefinedValue)),\n        };\n      }\n    }\n\n    let location = value.expressionLocation\n      ? `${value.expressionLocation.start.line}:${value.expressionLocation.start.column} ` +\n        `${value.expressionLocation.end.line}:${value.expressionLocation.end.line}`\n      : \"location unknown\";\n    realm.handleError(\n      new CompilerDiagnostic(\n        `Optimized Function Value ${location} is an not a function or react element`,\n        undefined,\n        \"PP0033\",\n        \"FatalError\"\n      )\n    );\n    throw new FatalError(\"Optimized Function Values must be functions or react elements\");\n  }\n\n  __generateInitialAdditionalFunctions(globalKey: string) {\n    let recordedAdditionalFunctions: Array<AdditionalFunctionEntry> = [];\n    let realm = this.realm;\n    let globalRecordedAdditionalFunctionsMap = this.moduleTracer.modules.logger.tryQuery(\n      () => Get(realm, realm.$GlobalObject, globalKey),\n      realm.intrinsics.undefined\n    );\n    invariant(globalRecordedAdditionalFunctionsMap instanceof ObjectValue);\n    for (let funcId of globalRecordedAdditionalFunctionsMap.getOwnPropertyKeysArray()) {\n      let property = globalRecordedAdditionalFunctionsMap.properties.get(funcId);\n      if (property) {\n        let value = property.descriptor && property.descriptor.value;\n        invariant(value !== undefined);\n        invariant(value instanceof Value);\n        let entry = this.__optimizedFunctionEntryOfValue(value);\n        if (entry) recordedAdditionalFunctions.push(entry);\n      }\n    }\n    return recordedAdditionalFunctions;\n  }\n\n  optimizeReactComponentTreeRoots(\n    statistics: ReactStatistics,\n    reactSerializerState: ReactSerializerState,\n    environmentRecordIdAfterGlobalCode: number\n  ): void {\n    let logger = this.moduleTracer.modules.logger;\n    let recordedReactRootValues = this.__generateInitialAdditionalFunctions(\"__reactComponentTrees\");\n    // Get write effects of the components\n    if (this.realm.react.verbose) {\n      logger.logInformation(`Evaluating ${recordedReactRootValues.length} React component tree roots...`);\n    }\n    for (let { value: componentRoot, config } of recordedReactRootValues) {\n      invariant(config);\n      optimizeReactComponentTreeRoot(\n        this.realm,\n        componentRoot,\n        config,\n        this.writeEffects,\n        environmentRecordIdAfterGlobalCode,\n        logger,\n        statistics,\n        reactSerializerState\n      );\n    }\n    applyOptimizedReactComponents(this.realm, this.writeEffects, environmentRecordIdAfterGlobalCode);\n  }\n\n  _callOfFunction(funcValue: FunctionValue): void => Value {\n    let call = funcValue.$Call;\n    invariant(call);\n    let numArgs = funcValue.getLength();\n    let args = [];\n    invariant(funcValue instanceof ECMAScriptSourceFunctionValue);\n    let params = funcValue.$FormalParameters;\n    if (numArgs && numArgs > 0 && params) {\n      for (let parameterId of params) {\n        if (t.isIdentifier(parameterId)) {\n          // Create an AbstractValue similar to __abstract being called\n          args.push(\n            AbstractValue.createAbstractArgument(\n              this.realm,\n              ((parameterId: any): BabelNodeIdentifier).name,\n              funcValue.expressionLocation\n            )\n          );\n        } else {\n          this.realm.handleError(\n            new CompilerDiagnostic(\n              \"Non-identifier args to additional functions unsupported\",\n              funcValue.expressionLocation,\n              \"PP1005\",\n              \"FatalError\"\n            )\n          );\n          throw new FatalError(\"Non-identifier args to additional functions unsupported\");\n        }\n      }\n    }\n\n    let thisArg = AbstractValue.createAbstractArgument(this.realm, \"this\", funcValue.expressionLocation, ObjectValue);\n    return call.bind(this, thisArg, args);\n  }\n\n  checkThatFunctionsAreIndependent(environmentRecordIdAfterGlobalCode: number) {\n    let additionalFunctionsToProcess = this.__generateInitialAdditionalFunctions(\"__optimizedFunctions\");\n    // When we find declarations of nested optimized functions, we need to apply the parent\n    // effects.\n    let additionalFunctionStack = [];\n    let additionalFunctions = new Set(additionalFunctionsToProcess.map(entry => entry.value));\n    let optimizedFunctionsObject = this.moduleTracer.modules.logger.tryQuery(\n      () => Get(this.realm, this.realm.$GlobalObject, \"__optimizedFunctions\"),\n      this.realm.intrinsics.undefined\n    );\n    invariant(optimizedFunctionsObject instanceof ObjectValue);\n\n    // If there's an additional function that delcared functionValue, it must be\n    // have already been evaluated for the __optimize call to have happened, so\n    // this should always return either the defining additional function or void\n    let getDeclaringAdditionalFunction = functionValue => {\n      for (let [additionalFunctionValue, additionalEffects] of this.writeEffects) {\n        // CreatedObjects is all objects created by this additional function but not\n        // nested additional functions.\n        let createdObjects = additionalEffects.effects.createdObjects;\n        if (createdObjects.has(functionValue)) return additionalFunctionValue;\n      }\n    };\n\n    let getEffectsFromAdditionalFunctionAndNestedFunctions = functionValue => {\n      additionalFunctionStack.push(functionValue);\n      invariant(functionValue instanceof ECMAScriptSourceFunctionValue);\n      let call = this._callOfFunction(functionValue);\n      let effects: Effects = this.realm.evaluatePure(() =>\n        this.realm.evaluateForEffectsInGlobalEnv(call, undefined, \"additional function\")\n      );\n      invariant(effects);\n      let additionalFunctionEffects = createAdditionalEffects(\n        this.realm,\n        effects,\n        true,\n        \"AdditionalFunctionEffects\",\n        environmentRecordIdAfterGlobalCode,\n        getDeclaringAdditionalFunction(functionValue)\n      );\n      invariant(additionalFunctionEffects);\n      effects = additionalFunctionEffects.effects;\n      this.writeEffects.set(functionValue, additionalFunctionEffects);\n\n      // look for newly registered optimized functions\n      let modifiedProperties = additionalFunctionEffects.effects.modifiedProperties;\n      // Conceptually this will ensure that the nested additional function is defined\n      // although for later cases, we'll apply the effects of the parents only.\n      this.realm.withEffectsAppliedInGlobalEnv(() => {\n        for (let [propertyBinding] of modifiedProperties) {\n          let descriptor = propertyBinding.descriptor;\n          if (descriptor && propertyBinding.object === optimizedFunctionsObject) {\n            let newValue = descriptor.value;\n            invariant(newValue instanceof Value); //todo: this does not seem invariantly true\n            let newEntry = this.__optimizedFunctionEntryOfValue(newValue);\n            if (newEntry) {\n              additionalFunctions.add(newEntry.value);\n              getEffectsFromAdditionalFunctionAndNestedFunctions(newEntry.value);\n              // Now we have to rember the stack of effects that need to be applied to deal with\n              // this additional function.\n            }\n          }\n        }\n        return null;\n      }, additionalFunctionEffects.effects);\n      invariant(additionalFunctionStack.pop() === functionValue);\n    };\n\n    while (additionalFunctionsToProcess.length > 0) {\n      let funcValue = additionalFunctionsToProcess.shift().value;\n      getEffectsFromAdditionalFunctionAndNestedFunctions(funcValue);\n    }\n    invariant(additionalFunctionStack.length === 0);\n\n    // check that functions are independent\n    let conflicts: Map<BabelNodeSourceLocation, CompilerDiagnostic> = new Map();\n    for (let fun1 of additionalFunctions) {\n      invariant(fun1 instanceof FunctionValue);\n      let fun1Name = this.functionExpressions.get(fun1) || fun1.intrinsicName || \"(unknown function)\";\n      // Also do argument validation here\n      let additionalFunctionEffects = this.writeEffects.get(fun1);\n      invariant(additionalFunctionEffects !== undefined);\n      let e1 = additionalFunctionEffects.effects;\n      invariant(e1 !== undefined);\n      if (e1.result instanceof Completion && !e1.result instanceof PossiblyNormalCompletion) {\n        let error = new CompilerDiagnostic(\n          `Additional function ${fun1Name} may terminate abruptly`,\n          e1.result.location,\n          \"PP1002\",\n          \"FatalError\"\n        );\n        this.realm.handleError(error);\n        throw new FatalError();\n      }\n      for (let fun2 of additionalFunctions) {\n        if (fun1 === fun2) continue;\n        invariant(fun2 instanceof FunctionValue);\n        let reportFn = () => {\n          this.reportWriteConflicts(fun1Name, conflicts, e1.modifiedProperties, this._callOfFunction(fun2));\n          return null;\n        };\n        let fun2Effects = this.writeEffects.get(fun2);\n        invariant(fun2Effects);\n        if (fun2Effects.parentAdditionalFunction) {\n          let parentEffects = this.writeEffects.get(fun2Effects.parentAdditionalFunction);\n          invariant(parentEffects);\n          this.realm.withEffectsAppliedInGlobalEnv(reportFn, parentEffects.effects);\n        } else {\n          reportFn();\n        }\n      }\n    }\n    if (conflicts.size > 0) {\n      for (let diagnostic of conflicts.values()) this.realm.handleError(diagnostic);\n      throw new FatalError();\n    }\n  }\n\n  getAdditionalFunctionValuesToEffects(): Map<FunctionValue, AdditionalFunctionEffects> {\n    return this.writeEffects;\n  }\n\n  reportWriteConflicts(\n    fname: string,\n    conflicts: Map<BabelNodeSourceLocation, CompilerDiagnostic>,\n    pbs: PropertyBindings,\n    call2: void => Value\n  ) {\n    let reportConflict = (location: BabelNodeSourceLocation) => {\n      let error = new CompilerDiagnostic(\n        `Property access conflicts with write in optimized function ${fname}`,\n        location,\n        \"PP1003\",\n        \"FatalError\"\n      );\n      conflicts.set(location, error);\n    };\n    let writtenObjects: Set<ObjectValue | AbstractObjectValue> = new Set();\n    pbs.forEach((val, key, m) => {\n      writtenObjects.add(key.object);\n    });\n    let oldReportObjectGetOwnProperties = this.realm.reportObjectGetOwnProperties;\n    this.realm.reportObjectGetOwnProperties = (ob: ObjectValue) => {\n      let location = this.realm.currentLocation;\n      invariant(location);\n      if (writtenObjects.has(ob) && !conflicts.has(location)) reportConflict(location);\n    };\n    let oldReportPropertyAccess = this.realm.reportPropertyAccess;\n    this.realm.reportPropertyAccess = (pb: PropertyBinding) => {\n      if (pb.object.refuseSerialization) return;\n      let location = this.realm.currentLocation;\n      if (!location) return; // happens only when accessing an additional function property\n      if (pbs.has(pb) && !conflicts.has(location)) reportConflict(location);\n    };\n    try {\n      ignoreErrorsIn(this.realm, () => this.realm.evaluateForEffectsInGlobalEnv(call2));\n    } finally {\n      this.realm.reportPropertyAccess = oldReportPropertyAccess;\n      this.realm.reportObjectGetOwnProperties = oldReportObjectGetOwnProperties;\n    }\n  }\n}\n"]}