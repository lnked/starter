{"version":3,"sources":["../../src/serializer/ResidualHeapSerializer.js"],"names":["t","commentStatement","text","s","emptyStatement","leadingComments","type","value","CountingSemaphore","constructor","action","initialCount","count","acquireOne","releaseOne","ResidualHeapSerializer","realm","logger","modules","residualHeapValueIdentifiers","residualHeapInspector","residualValues","residualFunctionInstances","residualClassMethodInstances","residualFunctionInfos","options","referencedDeclaredValues","additionalFunctionValuesAndEffects","additionalFunctionValueInfos","declarativeEnvironmentRecordsBindings","react","referentializer","generatorDAG","conditionalFeasibility","additionalGeneratorRoots","realmGenerator","generator","realmPreludeGenerator","preludeGenerator","prelude","_descriptors","Map","needsEmptyVar","needsAuxiliaryConstructor","descriptorNameGenerator","createNameGenerator","factoryNameGenerator","intrinsicNameGenerator","functionNameGenerator","initializeConditionNameGenerator","initializerNameGenerator","requireReturns","serializedValues","Set","_serializedValueWithIdentifiers","additionalFunctionValueNestedFunctions","residualReactElementSerializer","residualFunctions","getContainingAdditionalFunction","functionValue","instance","get","undefined","containingAdditionalFunction","getLocation","getSerializeObjectIdentifier","createLocation","location","identifier","generate","declar","variableDeclaration","variableDeclarator","_getPrelude","push","createFunction","statements","id","functionDeclaration","blockStatement","emitter","derivedIds","mainBody","getBody","_options","activeGeneratorBodies","rewrittenAdditionalFunctions","additionalFunctionGenerators","declaredGlobalLets","_objectSemaphores","getStatistics","statistics","_acquireOneObjectSemaphore","object","semaphore","_emitObjectProperties","obj","properties","objectPrototypeAlreadyEstablished","cleanupDummyProperties","skipPrototype","symbol","propertyBinding","symbols","desc","descriptor","emitNowOrAfterWaitingForDependencies","_getDescriptorValues","concat","_emitProperty","key","pathNode","canIgnoreProperty","body","has","unknownProperty","val","_getNestedValuesFromAbstract","_emitPropertiesWithComputedNames","_emitObjectPrototype","_emitConstructorPrototype","objects","objectProperties","size","kind","getKind","proto","$Prototype","invariantLevel","serializedProto","serializeValue","uid","fetchedPrototype","isCompatibleWith","MOBILE_JSC_VERSION","memberExpression","callExpression","memoizeReference","condition","binaryExpression","consequent","getErrorStatement","stringLiteral","emit","ifStatement","intrinsics","expressionStatement","assignmentExpression","func","prototype","getPropertyValue","absVal","values","args","length","cond","P","V","W","alternate","earlier_props","serializedP","serializedV","serializedCond","valuesToProcess","consequentStatement","alternateStatement","oldBody","beginEmitting","parentBody","entries","done","consequentBody","endEmitting","alternateBody","unaryExpression","processValues","getIdentifierAndIncrementReferenceCount","deleteIfMightHaveBeenDeleted","locationFunction","serializedKey","getAsPropertyNameExpression","computed","isIdentifier","_deleteProperty","emitDefinePropertyBody","joinCondition","trueBody","falseBody","descriptor1","descriptor2","_canEmbedProperty","descValue","getReasonToWaitForDependencies","mightHaveBeenDeleted","_getPropertyAssignment","descProps","boolKeys","valKeys","set","descriptorsKey","boolKey","b","objectProperty","booleanLiteral","toString","join","descriptorId","objectExpression","descKey","sequenceExpression","_serializeDeclarativeEnvironmentRecordBinding","residualFunctionBinding","serializedValue","declarativeEnvironmentRecord","modified","referentializeBinding","mightBeObject","incrementReferenceCount","_getReferencingGenerators","initialGenerators","functionValues","referencingOnlyAdditionalFunction","result","activeFunctions","slice","visitedFunctions","f","pop","add","g","scopes","scope","Array","from","isReferencedOnlyByAdditionalFunction","additionalFunction","getParent","_getActiveBodyOfGenerator","_getTarget","trace","_logScopes","generators","delayInitializations","includes","residualFunctionInitializers","registerValueOnlyReferencedByResidualFunctions","usedOnlyByResidualFunctions","description","console","log","filter","getGeneratorParent","commonAncestor","reduce","x","y","getName","notYetDoneBodies","dependenciesVisitor","onArrayWithWidenedNumericProperty","dependency","intrinsicName","emittingToAdditionalFunction","declarationBody","getDeclarationBody","onAbstractValueWithIdentifier","scopeBody","nestingLevel","_getValueDebugName","name","getIdentifier","serializeBinding","binding","record","environment","residualFunctionBindings","residualBinding","serializedUnscopedLocation","additionalFunctionPreludes","_declare","emittingToResidualFunction","bindingType","init","assignment","referenceOnly","refuseSerialization","_serializeAbstractValueHelper","classMethodInstance","methodType","error","$ECMAScriptCode","loc","handleError","isLeaf","res","_serializeValue","target","debugIdentifiers","needsIdentifier","debugScopes","scopeList","map","comment","valueIds","delayedValues","deleteIdentifier","valuesInlined","_serializeValueIntrinsic","intrinsicNameGenerated","convertStringToMember","_assignProperty","locationFn","valueFn","_serializeEmptyValue","deletion","_serializeArrayIndexProperties","array","indexPropertyLength","remainingProperties","elems","i","elem","elemVal","delayReason","getReasonToWaitForActiveValue","delete","_serializeArrayLengthIfNeeded","numberOfIndexProperties","lenProperty","isHavocedObject","evaluateWithoutLeakLogic","ToLength","_serializeValueArray","initProperties","arrayExpression","_serializeValueMap","omitDeadEntries","$MapData","$WeakMapData","len","mapConstructorDoesntTakeArguments","entry","$Key","$Value","emitAfterWaiting","newExpression","_serializeValueSet","$SetData","$WeakSetData","setConstructorDoesntTakeArguments","_serializeValueTypedArrayOrDataView","buf","$ViewedArrayBuffer","outlinedArrayBuffer","_serializeValueArrayBuffer","$ArrayBufferByteLength","db","$ArrayBufferData","allzero","numericLiteral","arrayValue","consExpr","_serializeValueFunction","$BoundTargetFunction","$BoundThis","$BoundArguments","boundArg","residualBindings","inAdditionalFunction","bindingsEmittedSemaphore","insertionPoint","getBodyReference","boundName","referencedValues","serializeBindingFunc","_serializeGlobalBinding","$FunctionKind","homeObject","$HomeObject","$IsClassPrototype","_serializeClass","additionalFVEffects","additionalEffects","_serializeAdditionalFunction","classFunc","classPrototype","classProtoId","hasSerializedClassProtoId","propertiesToSerialize","classSuperNode","serializeClassPrototypeId","classId","serializeClassMethodOrProperty","propertyNameOrSymbol","methodFuncOrProperty","serializeNameAndId","methodFuncOrPropertyId","_serializeClassMethod","prototypeId","serializeClassProperty","propertyValue","prop","propertyName","method","classMethodKeyNode","methodFunc","classMethodComputed","targetDescriptor","getTargetIntegrityDescriptor","writable","configurable","enumerable","_findLastObjectPrototype","_serializeValueRegExpObject","source","$OriginalSource","flags","$OriginalFlags","RegExp","regExpLiteral","serializeValueRawObject","emitIntegrityCommand","dummyProperties","props","temporalAlias","propValue","_serializeValueObjectViaConstructor","classConstructor","serializeValueObject","originalConstructor","setFunctionPrototype","numberData","$NumberData","throwIfNotConcreteNumber","stringData","$StringData","throwIfNotConcreteString","booleanData","$BooleanData","throwIfNotConcreteBoolean","dateValue","$DateValue","serializedDateValue","serializeReactElement","_constructor","createViaAuxiliaryConstructor","ObjectPrototype","_serializeValueSymbol","$Description","serializedArg","globalReg","globalSymbolRegistry","find","e","$Symbol","_serializeValueProxy","$ProxyTarget","$ProxyHandler","serializedArgs","abstractArg","abstractIndex","findIndex","v","ob","buildNode","cannotDeclare","hasBeenDeclared","_serializeAbstractValue","cf","hasIdentifier","reason","isIntrinsic","valueToNode","serialize","_serializeValueObjectBase","objectSemaphore","targetCommand","getTargetIntegrityCommand","referentialized","_annotateGeneratorStatements","parent","beginComments","effects","effectsToApply","valueToString","keyToString","createdObjects","modifiedBindings","modifiedProperties","keys","unshift","_withGeneratorScope","callback","isChildOverride","newBody","isChild","_getContext","context","bind","serializeGenerator","initGenerator","activeGeneratorBody","finalizeGenerator","finalizeCurrentBody","statement","canOmit","declare","emitPropertyModification","dependencies","_shouldBeWrapped","item","_serializeAdditionalFunctionGeneratorAndEffects","effectsGenerator","withEffectsAppliedInGlobalEnv","lazyHoistedReactNodes","serializeLazyHoistedNodes","additionalFunctionValue","transforms","additionalRoots","additionalRoot","nestedFunctions","forEach","transform","prepareAdditionalFunctionValues","postGeneratorSerialization","declaredCount","moduleId","moduleValue","initializedModules","apply","resolveInitializedModules","finalize","factorifyInitializers","unstrictFunctionBodies","strictFunctionBodies","spliceFunctions","strictDirective","directive","directiveLiteral","globalDirectives","isStrict","funcLoop","node","isFunctionExpression","directives","functionExpression","ast_body","declaredGlobals","globalExpression","thisExpression","usesThis","every","_logSerializedResidualMismatches","cleanInstance","program_directives","file","program","__originalName","JSON","stringify","expressionLocation","logValue"],"mappings":"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","file":"ResidualHeapSerializer.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm } from \"../realm.js\";\nimport type { Descriptor, PropertyBinding } from \"../types.js\";\nimport { IsArray, Get } from \"../methods/index.js\";\nimport {\n  AbstractValue,\n  BooleanValue,\n  BoundFunctionValue,\n  ConcreteValue,\n  ECMAScriptSourceFunctionValue,\n  EmptyValue,\n  FunctionValue,\n  NativeFunctionValue,\n  NumberValue,\n  ObjectValue,\n  ProxyValue,\n  StringValue,\n  SymbolValue,\n  Value,\n  UndefinedValue,\n} from \"../values/index.js\";\nimport * as t from \"babel-types\";\nimport type {\n  BabelNodeExpression,\n  BabelNodeStatement,\n  BabelNodeIdentifier,\n  BabelNodeBlockStatement,\n  BabelNodeLVal,\n  BabelNodeMemberExpression,\n  BabelVariableKind,\n  BabelNodeFile,\n  BabelNodeFunctionExpression,\n} from \"babel-types\";\nimport { Generator, PreludeGenerator, NameGenerator } from \"../utils/generator.js\";\nimport type { SerializationContext } from \"../utils/generator.js\";\nimport invariant from \"../invariant.js\";\nimport type {\n  ResidualFunctionBinding,\n  FunctionInfo,\n  FunctionInstance,\n  AdditionalFunctionInfo,\n  ReactSerializerState,\n  SerializedBody,\n  ClassMethodInstance,\n  AdditionalFunctionEffects,\n} from \"./types.js\";\nimport type { SerializerOptions } from \"../options.js\";\nimport { BodyReference } from \"./types.js\";\nimport { SerializerStatistics } from \"./statistics.js\";\nimport { Logger } from \"../utils/logger.js\";\nimport { Modules } from \"../utils/modules.js\";\nimport { ResidualHeapInspector } from \"./ResidualHeapInspector.js\";\nimport { ResidualFunctions } from \"./ResidualFunctions.js\";\nimport type { Scope } from \"./ResidualHeapVisitor.js\";\nimport { factorifyObjects } from \"./factorify.js\";\nimport { voidExpression, emptyExpression, constructorExpression, protoExpression } from \"../utils/internalizer.js\";\nimport { Emitter } from \"./Emitter.js\";\nimport { ResidualHeapValueIdentifiers } from \"./ResidualHeapValueIdentifiers.js\";\nimport {\n  commonAncestorOf,\n  getSuggestedArrayLiteralLength,\n  withDescriptorValue,\n  ClassPropertiesToIgnore,\n  canIgnoreClassLengthProperty,\n  getObjectPrototypeMetadata,\n} from \"./utils.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { canHoistFunction } from \"../react/hoisting.js\";\nimport { To } from \"../singletons.js\";\nimport { ResidualReactElementSerializer } from \"./ResidualReactElementSerializer.js\";\nimport type { Binding } from \"../environment.js\";\nimport { DeclarativeEnvironmentRecord } from \"../environment.js\";\nimport type { Referentializer } from \"./Referentializer.js\";\nimport { GeneratorDAG } from \"./GeneratorDAG.js\";\nimport { type Replacement, getReplacement } from \"./ResidualFunctionInstantiator\";\nimport { describeValue } from \"../utils.js\";\n\nfunction commentStatement(text: string) {\n  let s = t.emptyStatement();\n  s.leadingComments = [({ type: \"BlockComment\", value: text }: any)];\n  return s;\n}\n\nclass CountingSemaphore {\n  count: number;\n  action: () => void;\n  constructor(action: () => void, initialCount: number = 1) {\n    invariant(initialCount >= 1);\n    this.count = initialCount;\n    this.action = action;\n  }\n  acquireOne() {\n    this.count++;\n  }\n  releaseOne() {\n    invariant(this.count > 0);\n    if (--this.count === 0) this.action();\n  }\n}\n\nexport class ResidualHeapSerializer {\n  constructor(\n    realm: Realm,\n    logger: Logger,\n    modules: Modules,\n    residualHeapValueIdentifiers: ResidualHeapValueIdentifiers,\n    residualHeapInspector: ResidualHeapInspector,\n    residualValues: Map<Value, Set<Scope>>,\n    residualFunctionInstances: Map<FunctionValue, FunctionInstance>,\n    residualClassMethodInstances: Map<FunctionValue, ClassMethodInstance>,\n    residualFunctionInfos: Map<BabelNodeBlockStatement, FunctionInfo>,\n    options: SerializerOptions,\n    referencedDeclaredValues: Map<AbstractValue | ConcreteValue, void | FunctionValue>,\n    additionalFunctionValuesAndEffects: Map<FunctionValue, AdditionalFunctionEffects> | void,\n    additionalFunctionValueInfos: Map<FunctionValue, AdditionalFunctionInfo>,\n    declarativeEnvironmentRecordsBindings: Map<DeclarativeEnvironmentRecord, Map<string, ResidualFunctionBinding>>,\n    react: ReactSerializerState,\n    referentializer: Referentializer,\n    generatorDAG: GeneratorDAG,\n    conditionalFeasibility: Map<AbstractValue, { t: boolean, f: boolean }>,\n    additionalGeneratorRoots: Map<Generator, Set<ObjectValue>>\n  ) {\n    this.realm = realm;\n    this.logger = logger;\n    this.modules = modules;\n    this.residualHeapValueIdentifiers = residualHeapValueIdentifiers;\n    this.react = react;\n    this.referentializer = referentializer;\n\n    let realmGenerator = this.realm.generator;\n    invariant(realmGenerator);\n    this.generator = realmGenerator;\n    let realmPreludeGenerator = this.realm.preludeGenerator;\n    invariant(realmPreludeGenerator);\n    this.preludeGenerator = realmPreludeGenerator;\n\n    this.prelude = [];\n    this._descriptors = new Map();\n    this.needsEmptyVar = false;\n    this.needsAuxiliaryConstructor = false;\n    this.descriptorNameGenerator = this.preludeGenerator.createNameGenerator(\"$$\");\n    this.factoryNameGenerator = this.preludeGenerator.createNameGenerator(\"$_\");\n    this.intrinsicNameGenerator = this.preludeGenerator.createNameGenerator(\"$i_\");\n    this.functionNameGenerator = this.preludeGenerator.createNameGenerator(\"$f_\");\n    this.initializeConditionNameGenerator = this.preludeGenerator.createNameGenerator(\"_initialized\");\n    this.initializerNameGenerator = this.preludeGenerator.createNameGenerator(\"__init_\");\n    this.requireReturns = new Map();\n    this.serializedValues = new Set();\n    this._serializedValueWithIdentifiers = new Set();\n    this.additionalFunctionValueNestedFunctions = new Set();\n    this.residualReactElementSerializer = new ResidualReactElementSerializer(this.realm, this);\n    this.residualFunctions = new ResidualFunctions(\n      this.realm,\n      options,\n      this.modules,\n      this.requireReturns,\n      {\n        getContainingAdditionalFunction: functionValue => {\n          let instance = this.residualFunctionInstances.get(functionValue);\n          invariant(instance !== undefined);\n          return instance.containingAdditionalFunction;\n        },\n        getLocation: value => this.getSerializeObjectIdentifier(value),\n        createLocation: containingAdditionalFunction => {\n          let location = t.identifier(this.initializeConditionNameGenerator.generate());\n          let declar = t.variableDeclaration(\"var\", [t.variableDeclarator(location)]);\n          this._getPrelude(containingAdditionalFunction).push(declar);\n          return location;\n        },\n        createFunction: (containingAdditionalFunction, statements) => {\n          let id = t.identifier(this.initializerNameGenerator.generate());\n          this._getPrelude(containingAdditionalFunction).push(\n            t.functionDeclaration(id, [], t.blockStatement(statements))\n          );\n          return id;\n        },\n      },\n      this.prelude,\n      this.factoryNameGenerator,\n      residualFunctionInfos,\n      residualFunctionInstances,\n      residualClassMethodInstances,\n      additionalFunctionValueInfos,\n      this.additionalFunctionValueNestedFunctions,\n      referentializer\n    );\n    this.emitter = new Emitter(\n      this.residualFunctions,\n      referencedDeclaredValues,\n      conditionalFeasibility,\n      this.preludeGenerator.derivedIds\n    );\n    this.mainBody = this.emitter.getBody();\n    this.residualHeapInspector = residualHeapInspector;\n    this.residualValues = residualValues;\n    this.residualFunctionInstances = residualFunctionInstances;\n    this.residualClassMethodInstances = residualClassMethodInstances;\n    this.residualFunctionInfos = residualFunctionInfos;\n    this._options = options;\n    this.referencedDeclaredValues = referencedDeclaredValues;\n    this.activeGeneratorBodies = new Map();\n    this.additionalFunctionValuesAndEffects = additionalFunctionValuesAndEffects;\n    this.additionalFunctionValueInfos = additionalFunctionValueInfos;\n    this.rewrittenAdditionalFunctions = new Map();\n    this.declarativeEnvironmentRecordsBindings = declarativeEnvironmentRecordsBindings;\n    this.generatorDAG = generatorDAG;\n    this.conditionalFeasibility = conditionalFeasibility;\n    this.additionalFunctionGenerators = new Map();\n    this.declaredGlobalLets = new Map();\n    this._objectSemaphores = new Map();\n    this.additionalGeneratorRoots = additionalGeneratorRoots;\n  }\n\n  emitter: Emitter;\n  functions: Map<BabelNodeBlockStatement, Array<FunctionInstance>>;\n  functionInstances: Array<FunctionInstance>;\n  prelude: Array<BabelNodeStatement>;\n  body: Array<BabelNodeStatement>;\n  mainBody: SerializedBody;\n  realm: Realm;\n  preludeGenerator: PreludeGenerator;\n  generator: Generator;\n  _descriptors: Map<string, BabelNodeIdentifier>;\n  needsEmptyVar: boolean;\n  needsAuxiliaryConstructor: boolean;\n  descriptorNameGenerator: NameGenerator;\n  factoryNameGenerator: NameGenerator;\n  intrinsicNameGenerator: NameGenerator;\n  functionNameGenerator: NameGenerator;\n  initializeConditionNameGenerator: NameGenerator;\n  initializerNameGenerator: NameGenerator;\n  logger: Logger;\n  modules: Modules;\n  residualHeapValueIdentifiers: ResidualHeapValueIdentifiers;\n  requireReturns: Map<number | string, Replacement>;\n  residualHeapInspector: ResidualHeapInspector;\n  residualValues: Map<Value, Set<Scope>>;\n  residualFunctionInstances: Map<FunctionValue, FunctionInstance>;\n  residualClassMethodInstances: Map<FunctionValue, ClassMethodInstance>;\n  residualFunctionInfos: Map<BabelNodeBlockStatement, FunctionInfo>;\n  serializedValues: Set<Value>;\n  _serializedValueWithIdentifiers: Set<Value>;\n  residualFunctions: ResidualFunctions;\n  _options: SerializerOptions;\n  referencedDeclaredValues: Map<AbstractValue | ConcreteValue, void | FunctionValue>;\n  activeGeneratorBodies: Map<Generator, SerializedBody>;\n  additionalFunctionValuesAndEffects: Map<FunctionValue, AdditionalFunctionEffects> | void;\n  additionalFunctionValueInfos: Map<FunctionValue, AdditionalFunctionInfo>;\n  rewrittenAdditionalFunctions: Map<FunctionValue, Array<BabelNodeStatement>>;\n  declarativeEnvironmentRecordsBindings: Map<DeclarativeEnvironmentRecord, Map<string, ResidualFunctionBinding>>;\n  react: ReactSerializerState;\n  residualReactElementSerializer: ResidualReactElementSerializer;\n  referentializer: Referentializer;\n  additionalFunctionGenerators: Map<FunctionValue, Generator>;\n\n  // function values nested in additional functions can't delay initializations\n  // TODO: revisit this and fix additional functions to be capable of delaying initializations\n  additionalFunctionValueNestedFunctions: Set<FunctionValue>;\n\n  generatorDAG: GeneratorDAG;\n  conditionalFeasibility: Map<AbstractValue, { t: boolean, f: boolean }>;\n  additionalGeneratorRoots: Map<Generator, Set<ObjectValue>>;\n\n  declaredGlobalLets: Map<string, Value>;\n\n  getStatistics(): SerializerStatistics {\n    invariant(this.realm.statistics instanceof SerializerStatistics, \"serialization requires SerializerStatistics\");\n    return this.realm.statistics;\n  }\n\n  _objectSemaphores: Map<ObjectValue, CountingSemaphore>;\n\n  _acquireOneObjectSemaphore(object: ObjectValue): void | CountingSemaphore {\n    let semaphore = this._objectSemaphores.get(object);\n    if (semaphore !== undefined) semaphore.acquireOne();\n    return semaphore;\n  }\n\n  // Configures all mutable aspects of an object, in particular:\n  // symbols, properties, prototype.\n  // For every created object that corresponds to a value,\n  // this function should be invoked once.\n  // Thus, as a side effect, we gather statistics here on all emitted objects.\n  _emitObjectProperties(\n    obj: ObjectValue,\n    properties: Map<string, PropertyBinding> = obj.properties,\n    objectPrototypeAlreadyEstablished: boolean = false,\n    cleanupDummyProperties: ?Set<string>,\n    skipPrototype: boolean = false\n  ) {\n    //inject symbols\n    for (let [symbol, propertyBinding] of obj.symbols) {\n      invariant(propertyBinding);\n      let desc = propertyBinding.descriptor;\n      if (desc === undefined) continue; //deleted\n      let semaphore = this._acquireOneObjectSemaphore(obj);\n      this.emitter.emitNowOrAfterWaitingForDependencies(\n        this._getDescriptorValues(desc).concat([symbol, obj]),\n        () => {\n          invariant(desc !== undefined);\n          this._emitProperty(obj, symbol, desc);\n          if (semaphore !== undefined) semaphore.releaseOne();\n        },\n        this.emitter.getBody()\n      );\n    }\n\n    // inject properties\n    for (let [key, propertyBinding] of properties) {\n      invariant(propertyBinding);\n      if (propertyBinding.pathNode !== undefined) continue; // Property is assigned to inside loop\n      let desc = propertyBinding.descriptor;\n      if (desc === undefined) continue; //deleted\n      if (this.residualHeapInspector.canIgnoreProperty(obj, key)) continue;\n      invariant(desc !== undefined);\n      let semaphore = this._acquireOneObjectSemaphore(obj);\n      let body = this.emitter.getBody();\n      this.emitter.emitNowOrAfterWaitingForDependencies(\n        this._getDescriptorValues(desc).concat(obj),\n        () => {\n          invariant(desc !== undefined);\n          this._emitProperty(obj, key, desc, cleanupDummyProperties != null && cleanupDummyProperties.has(key));\n          if (semaphore !== undefined) semaphore.releaseOne();\n        },\n        body\n      );\n    }\n\n    // inject properties with computed names\n    if (obj.unknownProperty !== undefined) {\n      let desc = obj.unknownProperty.descriptor;\n      if (desc !== undefined) {\n        let val = desc.value;\n        invariant(val instanceof AbstractValue);\n        let semaphore = this._acquireOneObjectSemaphore(obj);\n        this.emitter.emitNowOrAfterWaitingForDependencies(\n          this._getNestedValuesFromAbstract(val, [obj]),\n          () => {\n            invariant(val instanceof AbstractValue);\n            this._emitPropertiesWithComputedNames(obj, val);\n            if (semaphore !== undefined) semaphore.releaseOne();\n          },\n          this.emitter.getBody()\n        );\n      }\n    }\n\n    // prototype\n    if (!skipPrototype) {\n      this._emitObjectPrototype(obj, objectPrototypeAlreadyEstablished);\n      if (obj instanceof FunctionValue) this._emitConstructorPrototype(obj);\n    }\n\n    this.getStatistics().objects++;\n    this.getStatistics().objectProperties += obj.properties.size;\n  }\n\n  _emitObjectPrototype(obj: ObjectValue, objectPrototypeAlreadyEstablished: boolean) {\n    let kind = obj.getKind();\n    let proto = obj.$Prototype;\n    if (objectPrototypeAlreadyEstablished) {\n      if (this.realm.invariantLevel >= 3) {\n        this.emitter.emitNowOrAfterWaitingForDependencies(\n          [proto, obj],\n          () => {\n            invariant(proto);\n            let serializedProto = this.serializeValue(proto);\n            let uid = this.getSerializeObjectIdentifier(obj);\n            const fetchedPrototype =\n              this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION) || this.realm.isCompatibleWith(\"mobile\")\n                ? t.memberExpression(uid, protoExpression)\n                : t.callExpression(this.preludeGenerator.memoizeReference(\"Object.getPrototypeOf\"), [uid]);\n            let condition = t.binaryExpression(\"!==\", fetchedPrototype, serializedProto);\n            let consequent = this.generator.getErrorStatement(t.stringLiteral(\"unexpected prototype\"));\n            this.emitter.emit(t.ifStatement(condition, consequent));\n          },\n          this.emitter.getBody()\n        );\n      }\n      return;\n    }\n    if (proto === this.realm.intrinsics[kind + \"Prototype\"]) return;\n\n    let semaphore = this._acquireOneObjectSemaphore(obj);\n    this.emitter.emitNowOrAfterWaitingForDependencies(\n      [proto, obj],\n      () => {\n        invariant(proto);\n        let serializedProto = this.serializeValue(proto);\n        let uid = this.getSerializeObjectIdentifier(obj);\n        if (!this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION) && !this.realm.isCompatibleWith(\"mobile\"))\n          this.emitter.emit(\n            t.expressionStatement(\n              t.callExpression(this.preludeGenerator.memoizeReference(\"Object.setPrototypeOf\"), [uid, serializedProto])\n            )\n          );\n        else {\n          this.emitter.emit(\n            t.expressionStatement(\n              t.assignmentExpression(\"=\", t.memberExpression(uid, protoExpression), serializedProto)\n            )\n          );\n        }\n        if (semaphore !== undefined) semaphore.releaseOne();\n      },\n      this.emitter.getBody()\n    );\n  }\n\n  _emitConstructorPrototype(func: FunctionValue) {\n    // If the original prototype object was mutated,\n    // request its serialization here as this might be observable by\n    // residual code.\n    let prototype = ResidualHeapInspector.getPropertyValue(func, \"prototype\");\n    if (prototype instanceof ObjectValue && this.residualValues.has(prototype)) {\n      this.emitter.emitNowOrAfterWaitingForDependencies(\n        [func],\n        () => {\n          invariant(prototype instanceof Value);\n          this.serializeValue(prototype);\n        },\n        this.emitter.getBody()\n      );\n    }\n  }\n\n  _getNestedValuesFromAbstract(absVal: AbstractValue, values: Array<Value>): Array<Value> {\n    if (absVal.kind === \"widened property\") return values;\n    if (absVal.kind === \"template for prototype member expression\") return values;\n    invariant(absVal.args.length === 3);\n    let cond = absVal.args[0];\n    invariant(cond instanceof AbstractValue);\n    if (cond.kind === \"template for property name condition\") {\n      let P = cond.args[0];\n      values.push(P);\n      let V = absVal.args[1];\n      values.push(V);\n      let W = absVal.args[2];\n      if (W instanceof AbstractValue) this._getNestedValuesFromAbstract(W, values);\n      else values.push(W);\n    } else {\n      // conditional assignment\n      values.push(cond);\n      let consequent = absVal.args[1];\n      if (consequent instanceof AbstractValue) {\n        this._getNestedValuesFromAbstract(consequent, values);\n      } else {\n        values.push(consequent);\n      }\n      let alternate = absVal.args[2];\n      if (alternate instanceof AbstractValue) {\n        this._getNestedValuesFromAbstract(alternate, values);\n      } else {\n        values.push(alternate);\n      }\n    }\n    return values;\n  }\n\n  _emitPropertiesWithComputedNames(obj: ObjectValue, absVal: AbstractValue) {\n    if (absVal.kind === \"widened property\") return;\n    if (absVal.kind === \"template for prototype member expression\") return;\n    invariant(absVal.args.length === 3);\n    let cond = absVal.args[0];\n    invariant(cond instanceof AbstractValue);\n    if (cond.kind === \"template for property name condition\") {\n      let P = cond.args[0];\n      invariant(P instanceof AbstractValue);\n      let V = absVal.args[1];\n      let earlier_props = absVal.args[2];\n      if (earlier_props instanceof AbstractValue) this._emitPropertiesWithComputedNames(obj, earlier_props);\n      let uid = this.getSerializeObjectIdentifier(obj);\n      let serializedP = this.serializeValue(P);\n      let serializedV = this.serializeValue(V);\n      this.emitter.emit(\n        t.expressionStatement(t.assignmentExpression(\"=\", t.memberExpression(uid, serializedP, true), serializedV))\n      );\n    } else {\n      // conditional assignment\n      let serializedCond = this.serializeValue(cond);\n      let consequent = absVal.args[1];\n      let valuesToProcess = new Set();\n      let consequentStatement;\n      let alternateStatement;\n\n      if (consequent instanceof AbstractValue) {\n        let oldBody = this.emitter.beginEmitting(\n          \"consequent\",\n          {\n            type: \"ConditionalAssignmentBranch\",\n            parentBody: undefined,\n            entries: [],\n            done: false,\n          },\n          /*isChild*/ true\n        );\n        this._emitPropertiesWithComputedNames(obj, consequent);\n        let consequentBody = this.emitter.endEmitting(\"consequent\", oldBody, valuesToProcess, /*isChild*/ true);\n        consequentStatement = t.blockStatement(consequentBody.entries);\n      }\n      let alternate = absVal.args[2];\n      if (alternate instanceof AbstractValue) {\n        let oldBody = this.emitter.beginEmitting(\n          \"alternate\",\n          {\n            type: \"ConditionalAssignmentBranch\",\n            parentBody: undefined,\n            entries: [],\n            done: false,\n          },\n          /*isChild*/ true\n        );\n        this._emitPropertiesWithComputedNames(obj, alternate);\n        let alternateBody = this.emitter.endEmitting(\"alternate\", oldBody, valuesToProcess, /*isChild*/ true);\n        alternateStatement = t.blockStatement(alternateBody.entries);\n      }\n      if (consequentStatement) {\n        this.emitter.emit(t.ifStatement(serializedCond, consequentStatement, alternateStatement));\n      } else if (alternateStatement) {\n        this.emitter.emit(t.ifStatement(t.unaryExpression(\"!\", serializedCond), alternateStatement));\n      }\n      this.emitter.processValues(valuesToProcess);\n    }\n  }\n\n  // Overridable.\n  getSerializeObjectIdentifier(val: Value) {\n    return this.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCount(val);\n  }\n\n  _emitProperty(\n    val: ObjectValue,\n    key: string | SymbolValue | AbstractValue,\n    desc: Descriptor | void,\n    deleteIfMightHaveBeenDeleted: boolean = false\n  ): void {\n    // Location for the property to be assigned to\n    let locationFunction = () => {\n      let serializedKey =\n        key instanceof SymbolValue || key instanceof AbstractValue\n          ? this.serializeValue(key)\n          : this.generator.getAsPropertyNameExpression(key);\n      let computed = key instanceof SymbolValue || key instanceof AbstractValue || !t.isIdentifier(serializedKey);\n      return t.memberExpression(this.getSerializeObjectIdentifier(val), serializedKey, computed);\n    };\n    if (desc === undefined) {\n      this._deleteProperty(locationFunction());\n    } else {\n      this.emitter.emit(this.emitDefinePropertyBody(deleteIfMightHaveBeenDeleted, locationFunction, val, key, desc));\n    }\n  }\n\n  emitDefinePropertyBody(\n    deleteIfMightHaveBeenDeleted: boolean,\n    locationFunction: void | (() => BabelNodeLVal),\n    val: ObjectValue,\n    key: string | SymbolValue | AbstractValue,\n    desc: Descriptor\n  ): BabelNodeStatement {\n    if (desc.joinCondition) {\n      let cond = this.serializeValue(desc.joinCondition);\n      invariant(cond !== undefined);\n      let trueBody;\n      let falseBody;\n      if (desc.descriptor1)\n        trueBody = this.emitDefinePropertyBody(\n          deleteIfMightHaveBeenDeleted,\n          locationFunction,\n          val,\n          key,\n          desc.descriptor1\n        );\n      if (desc.descriptor2)\n        falseBody = this.emitDefinePropertyBody(\n          deleteIfMightHaveBeenDeleted,\n          locationFunction,\n          val,\n          key,\n          desc.descriptor2\n        );\n      if (trueBody && falseBody) return t.ifStatement(cond, trueBody, falseBody);\n      if (trueBody) return t.ifStatement(cond, trueBody);\n      if (falseBody) return t.ifStatement(t.unaryExpression(\"!\", cond), falseBody);\n      invariant(false);\n    }\n    if (locationFunction !== undefined && this._canEmbedProperty(val, key, desc)) {\n      let descValue = desc.value;\n      invariant(descValue instanceof Value);\n      invariant(!this.emitter.getReasonToWaitForDependencies([descValue, val]), \"precondition of _emitProperty\");\n      let mightHaveBeenDeleted = descValue.mightHaveBeenDeleted();\n      // The only case we do not need to remove the dummy property is array index property.\n      return this._getPropertyAssignment(\n        locationFunction,\n        () => {\n          invariant(descValue instanceof Value);\n          return this.serializeValue(descValue);\n        },\n        mightHaveBeenDeleted,\n        deleteIfMightHaveBeenDeleted\n      );\n    }\n    let body = [];\n    let descProps = [];\n    let boolKeys = [\"enumerable\", \"configurable\"];\n    let valKeys = [];\n\n    if (!desc.get && !desc.set) {\n      boolKeys.push(\"writable\");\n      valKeys.push(\"value\");\n    } else {\n      valKeys.push(\"set\", \"get\");\n    }\n\n    let descriptorsKey = [];\n    for (let boolKey of boolKeys) {\n      if (boolKey in desc) {\n        let b = desc[boolKey];\n        invariant(b !== undefined);\n        descProps.push(t.objectProperty(t.identifier(boolKey), t.booleanLiteral(b)));\n        descriptorsKey.push(`${boolKey}:${b.toString()}`);\n      }\n    }\n\n    descriptorsKey = descriptorsKey.join(\",\");\n    let descriptorId = this._descriptors.get(descriptorsKey);\n    if (descriptorId === undefined) {\n      descriptorId = t.identifier(this.descriptorNameGenerator.generate(descriptorsKey));\n      let declar = t.variableDeclaration(\"var\", [t.variableDeclarator(descriptorId, t.objectExpression(descProps))]);\n      // The descriptors are used across all scopes, and thus must be declared in the prelude.\n      this.prelude.push(declar);\n      this._descriptors.set(descriptorsKey, descriptorId);\n    }\n    invariant(descriptorId !== undefined);\n\n    for (let descKey of valKeys) {\n      if (descKey in desc) {\n        let descValue = desc[descKey];\n        invariant(descValue instanceof Value);\n        if (descValue instanceof UndefinedValue) {\n          this.serializeValue(descValue);\n          continue;\n        }\n        invariant(!this.emitter.getReasonToWaitForDependencies([descValue]), \"precondition of _emitProperty\");\n        body.push(\n          t.assignmentExpression(\n            \"=\",\n            t.memberExpression(descriptorId, t.identifier(descKey)),\n            this.serializeValue(descValue)\n          )\n        );\n      }\n    }\n    let serializedKey =\n      key instanceof SymbolValue || key instanceof AbstractValue\n        ? this.serializeValue(key)\n        : this.generator.getAsPropertyNameExpression(key, /*canBeIdentifier*/ false);\n    invariant(!this.emitter.getReasonToWaitForDependencies([val]), \"precondition of _emitProperty\");\n    body.push(\n      t.callExpression(this.preludeGenerator.memoizeReference(\"Object.defineProperty\"), [\n        this.getSerializeObjectIdentifier(val),\n        serializedKey,\n        descriptorId,\n      ])\n    );\n    return t.expressionStatement(t.sequenceExpression(body));\n  }\n\n  _serializeDeclarativeEnvironmentRecordBinding(residualFunctionBinding: ResidualFunctionBinding) {\n    if (!residualFunctionBinding.serializedValue) {\n      let value = residualFunctionBinding.value;\n      invariant(residualFunctionBinding.declarativeEnvironmentRecord);\n\n      residualFunctionBinding.serializedValue = value !== undefined ? this.serializeValue(value) : voidExpression;\n      if (residualFunctionBinding.modified) {\n        this.referentializer.referentializeBinding(residualFunctionBinding);\n      }\n      if (value !== undefined && value.mightBeObject()) {\n        // Increment ref count one more time to ensure that this object will be assigned a unique id.\n        // This ensures that only once instance is created across all possible residual function invocations.\n        this.residualHeapValueIdentifiers.incrementReferenceCount(value);\n      }\n    }\n  }\n\n  // Augments an initial set of generators with all generators from\n  // which any of a given set of function values is referenced.\n  _getReferencingGenerators(\n    initialGenerators: Array<Generator>,\n    functionValues: Array<FunctionValue>,\n    referencingOnlyAdditionalFunction: void | FunctionValue\n  ): Array<Generator> {\n    let result = new Set(initialGenerators);\n    let activeFunctions = functionValues.slice();\n    let visitedFunctions = new Set();\n    while (activeFunctions.length > 0) {\n      let f = activeFunctions.pop();\n      if (visitedFunctions.has(f)) continue;\n      visitedFunctions.add(f);\n      if (f === referencingOnlyAdditionalFunction) {\n        let g = this.additionalFunctionGenerators.get(f);\n        invariant(g !== undefined);\n        result.add(g);\n      } else {\n        let scopes = this.residualValues.get(f);\n        invariant(scopes);\n        for (let scope of scopes)\n          if (scope instanceof FunctionValue) {\n            activeFunctions.push(scope);\n          } else {\n            invariant(scope instanceof Generator);\n            result.add(scope);\n          }\n      }\n    }\n    return Array.from(result);\n  }\n\n  // Determine if a value is effectively referenced by a single additional function.\n  isReferencedOnlyByAdditionalFunction(val: Value): void | FunctionValue {\n    let scopes = this.residualValues.get(val);\n    invariant(scopes !== undefined);\n    let additionalFunction;\n    for (let scope of scopes) {\n      let s = scope;\n      while (s instanceof Generator) {\n        s = this.generatorDAG.getParent(s);\n      }\n      if (s === \"GLOBAL\") return undefined;\n      invariant(s instanceof FunctionValue);\n      if (this.additionalFunctionGenerators.has(s)) {\n        if (additionalFunction !== undefined && additionalFunction !== s) return undefined;\n        additionalFunction = s;\n      } else {\n        let f = this.isReferencedOnlyByAdditionalFunction(s);\n        if (f === undefined) return undefined;\n        if (additionalFunction !== undefined && additionalFunction !== f) return undefined;\n        additionalFunction = f;\n      }\n    }\n    return additionalFunction;\n  }\n\n  _getActiveBodyOfGenerator(generator: Generator): void | SerializedBody {\n    return generator === this.generator ? this.mainBody : this.activeGeneratorBodies.get(generator);\n  }\n\n  // Determine whether initialization code for a value should go into the main body, or a more specific initialization body.\n  _getTarget(\n    val: Value,\n    trace?: true\n  ): {\n    body: SerializedBody,\n    usedOnlyByResidualFunctions?: true,\n    referencingOnlyAdditionalFunction?: void | FunctionValue,\n    commonAncestor?: Scope,\n    description?: string,\n  } {\n    let scopes = this.residualValues.get(val);\n    invariant(scopes !== undefined, \"value must have been visited\");\n\n    // All relevant values were visited in at least one scope.\n    invariant(scopes.size >= 1);\n    if (trace) this._logScopes(scopes);\n\n    // If a value is used in more than one scope, prevent inlining as it might be an additional root with a particular creation scope\n    if (scopes.size > 1) this.residualHeapValueIdentifiers.incrementReferenceCount(val);\n\n    // First, let's figure out from which function and generator scopes this value is referenced.\n    let functionValues = [];\n    let generators = [];\n    for (let scope of scopes) {\n      if (scope instanceof FunctionValue) {\n        functionValues.push(scope);\n      } else {\n        invariant(scope instanceof Generator, \"scope must be either function value or generator\");\n        generators.push(scope);\n      }\n    }\n\n    let referencingOnlyAdditionalFunction = this.isReferencedOnlyByAdditionalFunction(val);\n    if (generators.length === 0) {\n      // This value is only referenced from residual functions.\n      if (\n        this._options.delayInitializations &&\n        (referencingOnlyAdditionalFunction === undefined || !functionValues.includes(referencingOnlyAdditionalFunction))\n      ) {\n        // We can delay the initialization, and move it into a conditional code block in the residual functions!\n        let body = this.residualFunctions.residualFunctionInitializers.registerValueOnlyReferencedByResidualFunctions(\n          functionValues,\n          val\n        );\n\n        return {\n          body,\n          usedOnlyByResidualFunctions: true,\n          referencingOnlyAdditionalFunction,\n          description: \"delay_initializer\",\n        };\n      }\n    }\n\n    if (trace)\n      console.log(\n        `  is referenced only by additional function? ${referencingOnlyAdditionalFunction !== undefined ? \"yes\" : \"no\"}`\n      );\n\n    // flatten all function values into the scopes that use them\n    generators = this._getReferencingGenerators(generators, functionValues, referencingOnlyAdditionalFunction);\n\n    if (referencingOnlyAdditionalFunction === undefined) {\n      // Remove all generators rooted in additional functions,\n      // since we know that there's at least one root that's not in an additional function\n      // which requires the value to be emitted outside of the additional function.\n      generators = generators.filter(generator => {\n        let s = generator;\n        while (s instanceof Generator) {\n          s = this.generatorDAG.getParent(s);\n        }\n        return s === \"GLOBAL\";\n      });\n      if (generators.length === 0) {\n        // This means that the value was referenced by multiple additional functions, and thus it must have existed at the end of global code execution.\n        // TODO: Emit to the end, not somewhere in the middle of the mainBody.\n        // TODO: Revisit for nested additional functions\n        return { body: this.mainBody };\n      }\n    }\n\n    const getGeneratorParent = g => {\n      let s = this.generatorDAG.getParent(g);\n      return s instanceof Generator ? s : undefined;\n    };\n    // This value is referenced from more than one generator.\n    // Let's find the body associated with their common ancestor.\n    let commonAncestor = Array.from(generators).reduce(\n      (x, y) => commonAncestorOf(x, y, getGeneratorParent),\n      generators[0]\n    );\n    invariant(commonAncestor !== undefined, \"there must always be a common generator ancestor\");\n    if (trace) console.log(`  common ancestor: ${commonAncestor.getName()}`);\n\n    let body;\n    while (true) {\n      body = this._getActiveBodyOfGenerator(commonAncestor);\n      if (body !== undefined) break;\n      commonAncestor = getGeneratorParent(commonAncestor);\n      invariant(commonAncestor !== undefined, \"there must always be an active body for the common generator ancestor\");\n    }\n\n    // So we have a (common ancestor) body now.\n    invariant(body !== undefined, \"there must always be an active body\");\n\n    // However, there's a potential problem: That body might belong to a generator\n    // which has nested generators that are currently being processed (they are not \"done\" yet).\n    // This becomes a problem when the value for which we are trying to determine the target body\n    // depends on other values which are only declared in such not-yet-done nested generator!\n    // So we find all such not-yet-done bodies here, and pick a most nested one\n    // which is related to one of the scopes this value is used by.\n    let notYetDoneBodies = new Set();\n    this.emitter.dependenciesVisitor(val, {\n      onArrayWithWidenedNumericProperty: dependency => {\n        if (trace) {\n          console.log(\n            `  depending on unknown array with numeric properties and an identifier ${dependency.intrinsicName || \"?\"}`\n          );\n        }\n        invariant(\n          referencingOnlyAdditionalFunction === undefined || this.emitter.emittingToAdditionalFunction(),\n          \"additional function inconsistency\"\n        );\n        let declarationBody = this.emitter.getDeclarationBody(dependency);\n        if (declarationBody !== undefined) {\n          if (trace) console.log(`    has declaration body`);\n          for (let b = declarationBody; b !== undefined; b = b.parentBody) {\n            if (notYetDoneBodies.has(b)) break;\n            notYetDoneBodies.add(b);\n          }\n        }\n      },\n      onAbstractValueWithIdentifier: dependency => {\n        if (trace) console.log(`  depending on abstract value with identifier ${dependency.intrinsicName || \"?\"}`);\n        invariant(\n          referencingOnlyAdditionalFunction === undefined || this.emitter.emittingToAdditionalFunction(),\n          \"additional function inconsistency\"\n        );\n        let declarationBody = this.emitter.getDeclarationBody(dependency);\n        if (declarationBody !== undefined) {\n          if (trace) console.log(`    has declaration body`);\n          for (let b = declarationBody; b !== undefined; b = b.parentBody) {\n            if (notYetDoneBodies.has(b)) break;\n            notYetDoneBodies.add(b);\n          }\n        }\n      },\n    });\n    if (trace) console.log(`  got ${notYetDoneBodies.size} not yet done bodies`);\n    for (let s of generators)\n      for (let g = s; g !== undefined; g = getGeneratorParent(g)) {\n        let scopeBody = this._getActiveBodyOfGenerator(g);\n        if (\n          scopeBody !== undefined &&\n          (scopeBody.nestingLevel || 0) > (body.nestingLevel || 0) &&\n          notYetDoneBodies.has(scopeBody)\n        ) {\n          // TODO: If there are multiple such scopeBody's, why is it okay to pick an arbitrary one?\n          body = scopeBody;\n          break;\n        }\n      }\n\n    return { body, commonAncestor };\n  }\n\n  _getValueDebugName(val: Value) {\n    let name;\n    if (val instanceof FunctionValue) {\n      name = val.getName();\n    } else {\n      const id = this.residualHeapValueIdentifiers.getIdentifier(val);\n      invariant(id);\n      name = id.name;\n    }\n    return name;\n  }\n\n  serializeBinding(binding: Binding): BabelNodeIdentifier | BabelNodeMemberExpression {\n    let record = binding.environment;\n    invariant(record instanceof DeclarativeEnvironmentRecord, \"only declarative environments has bindings\");\n\n    let residualFunctionBindings = this.declarativeEnvironmentRecordsBindings.get(record);\n    invariant(\n      residualFunctionBindings,\n      \"all bindings that create abstract values must have at least one call emitted to the generator so the function environment should have been visited\"\n    );\n    let residualBinding = residualFunctionBindings.get(binding.name);\n    invariant(residualBinding, \"any referenced residual binding should have been visited\");\n\n    this._serializeDeclarativeEnvironmentRecordBinding(residualBinding);\n\n    let location = residualBinding.serializedUnscopedLocation;\n    invariant(location !== undefined);\n    return location;\n  }\n\n  _getPrelude(additionalFunction: void | FunctionValue): Array<BabelNodeStatement> {\n    if (additionalFunction !== undefined) {\n      let body = this.residualFunctions.additionalFunctionPreludes.get(additionalFunction);\n      invariant(body !== undefined);\n      return body;\n    } else {\n      return this.prelude;\n    }\n  }\n\n  _declare(\n    emittingToResidualFunction: boolean,\n    referencingOnlyAdditionalFunction: void | FunctionValue,\n    bindingType: BabelVariableKind,\n    id: BabelNodeLVal,\n    init: BabelNodeExpression\n  ) {\n    if (emittingToResidualFunction) {\n      let declar = t.variableDeclaration(bindingType, [t.variableDeclarator(id)]);\n      this._getPrelude(referencingOnlyAdditionalFunction).push(declar);\n      let assignment = t.expressionStatement(t.assignmentExpression(\"=\", id, init));\n      this.emitter.emit(assignment);\n    } else {\n      let declar = t.variableDeclaration(bindingType, [t.variableDeclarator(id, init)]);\n      this.emitter.emit(declar);\n    }\n  }\n\n  serializeValue(val: Value, referenceOnly?: boolean, bindingType?: BabelVariableKind): BabelNodeExpression {\n    invariant(!(val instanceof ObjectValue && val.refuseSerialization));\n    if (val instanceof AbstractValue) {\n      if (val.kind === \"widened\") {\n        this.serializedValues.add(val);\n        let name = val.intrinsicName;\n        invariant(name !== undefined);\n        return t.identifier(name);\n      } else if (val.kind === \"widened property\") {\n        this.serializedValues.add(val);\n        return this._serializeAbstractValueHelper(val);\n      }\n    }\n\n    // make sure we're not serializing a class method here\n    if (val instanceof ECMAScriptSourceFunctionValue && this.residualClassMethodInstances.has(val)) {\n      let classMethodInstance = this.residualClassMethodInstances.get(val);\n      invariant(classMethodInstance);\n      // anything other than a class constructor should never go through serializeValue()\n      // so we need to log a nice error message to the user\n      if (classMethodInstance.methodType !== \"constructor\") {\n        let error = new CompilerDiagnostic(\n          \"a class method incorrectly went through the serializeValue() code path\",\n          val.$ECMAScriptCode.loc,\n          \"PP0022\",\n          \"FatalError\"\n        );\n        this.realm.handleError(error);\n        throw new FatalError();\n      }\n    }\n\n    if (this._serializedValueWithIdentifiers.has(val)) {\n      return this.getSerializeObjectIdentifier(val);\n    }\n\n    this.serializedValues.add(val);\n    if (!referenceOnly && ResidualHeapInspector.isLeaf(val)) {\n      let res = this._serializeValue(val);\n      invariant(res !== undefined);\n      return res;\n    }\n    this._serializedValueWithIdentifiers.add(val);\n\n    let target = this._getTarget(val);\n    let oldBody = this.emitter.beginEmitting(val, target.body);\n    let init = this._serializeValue(val);\n\n    let id = this.residualHeapValueIdentifiers.getIdentifier(val);\n    if (this._options.debugIdentifiers !== undefined && this._options.debugIdentifiers.includes(id.name)) {\n      console.log(`Tracing value with identifier ${id.name} (${val.constructor.name}) targetting ${target.body.type}`);\n      this._getTarget(val, true);\n    }\n    let result = id;\n    this.residualHeapValueIdentifiers.incrementReferenceCount(val);\n\n    if (this.residualHeapValueIdentifiers.needsIdentifier(val)) {\n      if (init) {\n        if (this._options.debugScopes) {\n          let scopes = this.residualValues.get(val);\n          invariant(scopes !== undefined);\n          const scopeList = Array.from(scopes)\n            .map(s => `\"${s.getName()}\"`)\n            .join(\",\");\n          let comment = `${this._getValueDebugName(val)} referenced from scopes [${scopeList}]`;\n          if (target.commonAncestor !== undefined)\n            comment = `${comment} with common ancestor: ${target.commonAncestor.getName()}`;\n          if (target.description !== undefined) comment = `${comment} => ${target.description} `;\n          this.emitter.emit(commentStatement(comment));\n        }\n        if (init !== id) {\n          this._declare(\n            !!target.usedOnlyByResidualFunctions,\n            target.referencingOnlyAdditionalFunction,\n            bindingType || \"var\",\n            id,\n            init\n          );\n        }\n        this.getStatistics().valueIds++;\n        if (target.usedOnlyByResidualFunctions) this.getStatistics().delayedValues++;\n      }\n    } else {\n      if (init) {\n        this.residualHeapValueIdentifiers.deleteIdentifier(val);\n        result = init;\n        this.getStatistics().valuesInlined++;\n      }\n    }\n\n    this.emitter.endEmitting(val, oldBody);\n    return result;\n  }\n\n  _serializeValueIntrinsic(val: Value): BabelNodeExpression {\n    let intrinsicName = val.intrinsicName;\n    invariant(intrinsicName);\n    if (val instanceof ObjectValue && val.intrinsicNameGenerated) {\n      // The intrinsic was generated at a particular point in time.\n      return this.preludeGenerator.convertStringToMember(intrinsicName);\n    } else {\n      // The intrinsic conceptually exists ahead of time.\n      invariant(\n        this.emitter.getBody().type === \"MainGenerator\" ||\n          this.emitter.getBody().type === \"AdditionalFunction\" ||\n          this.emitter.getBody().type === \"DelayInitializations\"\n      );\n      return this.preludeGenerator.memoizeReference(intrinsicName);\n    }\n  }\n\n  _getDescriptorValues(desc: Descriptor): Array<Value> {\n    if (desc.joinCondition !== undefined) return [desc.joinCondition];\n    invariant(desc.value === undefined || desc.value instanceof Value);\n    if (desc.value !== undefined) return [desc.value];\n    invariant(desc.get !== undefined);\n    invariant(desc.set !== undefined);\n    return [desc.get, desc.set];\n  }\n\n  _deleteProperty(location: BabelNodeLVal) {\n    invariant(location.type === \"MemberExpression\");\n    this.emitter.emit(\n      t.expressionStatement(t.unaryExpression(\"delete\", ((location: any): BabelNodeMemberExpression), true))\n    );\n  }\n\n  _assignProperty(\n    locationFn: () => BabelNodeLVal,\n    valueFn: () => BabelNodeExpression,\n    mightHaveBeenDeleted: boolean,\n    deleteIfMightHaveBeenDeleted: boolean = false\n  ) {\n    this.emitter.emit(\n      this._getPropertyAssignment(locationFn, valueFn, mightHaveBeenDeleted, deleteIfMightHaveBeenDeleted)\n    );\n  }\n\n  _getPropertyAssignment(\n    locationFn: () => BabelNodeLVal,\n    valueFn: () => BabelNodeExpression,\n    mightHaveBeenDeleted: boolean,\n    deleteIfMightHaveBeenDeleted: boolean = false\n  ) {\n    let location = locationFn();\n    let value = valueFn();\n    let assignment = t.expressionStatement(t.assignmentExpression(\"=\", location, value));\n    if (mightHaveBeenDeleted) {\n      let condition = t.binaryExpression(\"!==\", value, this._serializeEmptyValue());\n      let deletion = null;\n      if (deleteIfMightHaveBeenDeleted) {\n        invariant(location.type === \"MemberExpression\");\n        deletion = t.expressionStatement(\n          t.unaryExpression(\"delete\", ((location: any): BabelNodeMemberExpression), true)\n        );\n      }\n      return t.ifStatement(condition, assignment, deletion);\n    } else {\n      return assignment;\n    }\n  }\n\n  _serializeArrayIndexProperties(\n    array: ObjectValue,\n    indexPropertyLength: number,\n    remainingProperties: Map<string, PropertyBinding>\n  ) {\n    let elems = [];\n    for (let i = 0; i < indexPropertyLength; i++) {\n      let key = i + \"\";\n      let propertyBinding = remainingProperties.get(key);\n      let elem = null;\n      // \"propertyBinding === undefined\" means array has a hole in the middle.\n      if (propertyBinding !== undefined) {\n        let descriptor = propertyBinding.descriptor;\n        // \"descriptor === undefined\" means this array item has been deleted.\n        if (\n          descriptor !== undefined &&\n          descriptor.value !== undefined &&\n          this._canEmbedProperty(array, key, descriptor)\n        ) {\n          let elemVal = descriptor.value;\n          invariant(elemVal instanceof Value);\n          let mightHaveBeenDeleted = elemVal.mightHaveBeenDeleted();\n          let delayReason =\n            this.emitter.getReasonToWaitForDependencies(elemVal) ||\n            this.emitter.getReasonToWaitForActiveValue(array, mightHaveBeenDeleted);\n          if (!delayReason) {\n            elem = this.serializeValue(elemVal);\n            remainingProperties.delete(key);\n          }\n        }\n      }\n      elems.push(elem);\n    }\n    return elems;\n  }\n\n  _serializeArrayLengthIfNeeded(\n    val: ObjectValue,\n    numberOfIndexProperties: number,\n    remainingProperties: Map<string, PropertyBinding>\n  ): void {\n    const realm = this.realm;\n    let lenProperty;\n    if (val.isHavocedObject()) {\n      lenProperty = this.realm.evaluateWithoutLeakLogic(() => Get(realm, val, \"length\"));\n    } else {\n      lenProperty = Get(realm, val, \"length\");\n    }\n    // Need to serialize length property if:\n    // 1. array length is abstract.\n    // 2. array length is concrete, but different from number of index properties\n    //  we put into initialization list.\n    if (lenProperty instanceof AbstractValue || To.ToLength(realm, lenProperty) !== numberOfIndexProperties) {\n      if (!(lenProperty instanceof AbstractValue) || lenProperty.kind !== \"widened property\") {\n        let semaphore = this._acquireOneObjectSemaphore(val);\n        this.emitter.emitNowOrAfterWaitingForDependencies(\n          [val, lenProperty],\n          () => {\n            this._assignProperty(\n              () => t.memberExpression(this.getSerializeObjectIdentifier(val), t.identifier(\"length\")),\n              () => this.serializeValue(lenProperty),\n              false /*mightHaveBeenDeleted*/\n            );\n            if (semaphore !== undefined) semaphore.releaseOne();\n          },\n          this.emitter.getBody()\n        );\n      }\n      remainingProperties.delete(\"length\");\n    }\n  }\n\n  _serializeValueArray(val: ObjectValue): BabelNodeExpression {\n    let remainingProperties = new Map(val.properties);\n\n    const indexPropertyLength = getSuggestedArrayLiteralLength(this.realm, val);\n    // Use the serialized index properties as array initialization list.\n    const initProperties = this._serializeArrayIndexProperties(val, indexPropertyLength, remainingProperties);\n    this._serializeArrayLengthIfNeeded(val, indexPropertyLength, remainingProperties);\n    this._emitObjectProperties(val, remainingProperties);\n    return t.arrayExpression(initProperties);\n  }\n\n  _serializeValueMap(val: ObjectValue): BabelNodeExpression {\n    let kind = val.getKind();\n    let elems = [];\n\n    let entries;\n    let omitDeadEntries;\n\n    if (kind === \"Map\") {\n      entries = val.$MapData;\n      omitDeadEntries = false;\n    } else {\n      invariant(kind === \"WeakMap\");\n      entries = val.$WeakMapData;\n      omitDeadEntries = true;\n    }\n    invariant(entries !== undefined);\n    let len = entries.length;\n    let mapConstructorDoesntTakeArguments = this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION);\n\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      let key = entry.$Key;\n      let value = entry.$Value;\n      if (key === undefined || value === undefined || (omitDeadEntries && !this.residualValues.has(key))) continue;\n      let mightHaveBeenDeleted = key.mightHaveBeenDeleted();\n      let delayReason =\n        this.emitter.getReasonToWaitForDependencies(key) ||\n        this.emitter.getReasonToWaitForDependencies(value) ||\n        this.emitter.getReasonToWaitForActiveValue(val, mightHaveBeenDeleted || mapConstructorDoesntTakeArguments);\n      if (delayReason) {\n        this.emitter.emitAfterWaiting(\n          delayReason,\n          [key, value, val],\n          () => {\n            invariant(key !== undefined);\n            invariant(value !== undefined);\n            this.emitter.emit(\n              t.expressionStatement(\n                t.callExpression(\n                  t.memberExpression(\n                    this.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCount(val),\n                    t.identifier(\"set\")\n                  ),\n                  [this.serializeValue(key), this.serializeValue(value)]\n                )\n              )\n            );\n          },\n          this.emitter.getBody()\n        );\n      } else {\n        let serializedKey = this.serializeValue(key);\n        let serializedValue = this.serializeValue(value);\n        let elem = t.arrayExpression([serializedKey, serializedValue]);\n        elems.push(elem);\n      }\n    }\n\n    this._emitObjectProperties(val);\n    let args = elems.length > 0 ? [t.arrayExpression(elems)] : [];\n    return t.newExpression(this.preludeGenerator.memoizeReference(kind), args);\n  }\n\n  _serializeValueSet(val: ObjectValue): BabelNodeExpression {\n    let kind = val.getKind();\n    let elems = [];\n\n    let entries;\n    let omitDeadEntries;\n\n    if (kind === \"Set\") {\n      entries = val.$SetData;\n      omitDeadEntries = false;\n    } else {\n      invariant(kind === \"WeakSet\");\n      entries = val.$WeakSetData;\n      omitDeadEntries = true;\n    }\n\n    invariant(entries !== undefined);\n    let len = entries.length;\n    let setConstructorDoesntTakeArguments = this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION);\n\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      if (entry === undefined || (omitDeadEntries && !this.residualValues.has(entry))) continue;\n      let mightHaveBeenDeleted = entry.mightHaveBeenDeleted();\n      let delayReason =\n        this.emitter.getReasonToWaitForDependencies(entry) ||\n        this.emitter.getReasonToWaitForActiveValue(val, mightHaveBeenDeleted || setConstructorDoesntTakeArguments);\n      if (delayReason) {\n        this.emitter.emitAfterWaiting(\n          delayReason,\n          [entry, val],\n          () => {\n            invariant(entry !== undefined);\n            this.emitter.emit(\n              t.expressionStatement(\n                t.callExpression(\n                  t.memberExpression(\n                    this.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCount(val),\n                    t.identifier(\"add\")\n                  ),\n                  [this.serializeValue(entry)]\n                )\n              )\n            );\n          },\n          this.emitter.getBody()\n        );\n      } else {\n        let elem = this.serializeValue(entry);\n        elems.push(elem);\n      }\n    }\n\n    this._emitObjectProperties(val);\n    let args = elems.length > 0 ? [t.arrayExpression(elems)] : [];\n    return t.newExpression(this.preludeGenerator.memoizeReference(kind), args);\n  }\n\n  _serializeValueTypedArrayOrDataView(val: ObjectValue): BabelNodeExpression {\n    let buf = val.$ViewedArrayBuffer;\n    invariant(buf !== undefined);\n    let outlinedArrayBuffer = this.serializeValue(buf, true);\n    this._emitObjectProperties(val);\n    return t.newExpression(this.preludeGenerator.memoizeReference(val.getKind()), [outlinedArrayBuffer]);\n  }\n\n  _serializeValueArrayBuffer(val: ObjectValue): BabelNodeExpression {\n    let elems = [];\n\n    let len = val.$ArrayBufferByteLength;\n    let db = val.$ArrayBufferData;\n    invariant(len !== undefined);\n    invariant(db);\n    let allzero = true;\n    for (let i = 0; i < len; i++) {\n      if (db[i] !== 0) {\n        allzero = false;\n      }\n      let elem = t.numericLiteral(db[i]);\n      elems.push(elem);\n    }\n\n    this._emitObjectProperties(val);\n    if (allzero) {\n      // if they're all zero, just emit the array buffer constructor\n      return t.newExpression(this.preludeGenerator.memoizeReference(val.getKind()), [t.numericLiteral(len)]);\n    } else {\n      // initialize from a byte array otherwise\n      let arrayValue = t.arrayExpression(elems);\n      let consExpr = t.newExpression(this.preludeGenerator.memoizeReference(\"Uint8Array\"), [arrayValue]);\n      // access the Uint8Array.buffer property to extract the created buffer\n      return t.memberExpression(consExpr, t.identifier(\"buffer\"));\n    }\n  }\n\n  _serializeValueFunction(val: FunctionValue): void | BabelNodeExpression {\n    if (val instanceof BoundFunctionValue) {\n      this._emitObjectProperties(val);\n      return t.callExpression(\n        t.memberExpression(this.serializeValue(val.$BoundTargetFunction), t.identifier(\"bind\")),\n        [].concat(\n          this.serializeValue(val.$BoundThis),\n          val.$BoundArguments.map((boundArg, i) => this.serializeValue(boundArg))\n        )\n      );\n    }\n\n    invariant(!(val instanceof NativeFunctionValue), \"all native function values should be intrinsics\");\n    invariant(val instanceof ECMAScriptSourceFunctionValue);\n\n    let instance = this.residualFunctionInstances.get(val);\n    invariant(instance !== undefined);\n    let residualBindings = instance.residualFunctionBindings;\n\n    let inAdditionalFunction = this.isReferencedOnlyByAdditionalFunction(val);\n    if (inAdditionalFunction !== undefined) instance.containingAdditionalFunction = inAdditionalFunction;\n    let bindingsEmittedSemaphore = new CountingSemaphore(() => {\n      invariant(instance);\n      // hoist if we are in an additionalFunction\n      if (inAdditionalFunction !== undefined && canHoistFunction(this.realm, val, undefined, new Set())) {\n        instance.insertionPoint = new BodyReference(this.mainBody, this.mainBody.entries.length);\n        instance.containingAdditionalFunction = undefined;\n      } else {\n        instance.insertionPoint = this.emitter.getBodyReference();\n      }\n    });\n\n    for (let [boundName, residualBinding] of residualBindings) {\n      let referencedValues = [];\n      let serializeBindingFunc;\n      if (!residualBinding.declarativeEnvironmentRecord) {\n        serializeBindingFunc = () => this._serializeGlobalBinding(boundName, residualBinding);\n      } else {\n        serializeBindingFunc = () => this._serializeDeclarativeEnvironmentRecordBinding(residualBinding);\n        if (residualBinding.value !== undefined) referencedValues.push(residualBinding.value);\n      }\n      bindingsEmittedSemaphore.acquireOne();\n      this.emitter.emitNowOrAfterWaitingForDependencies(\n        referencedValues,\n        () => {\n          serializeBindingFunc();\n          bindingsEmittedSemaphore.releaseOne();\n        },\n        this.emitter.getBody()\n      );\n    }\n    if (val.$FunctionKind === \"classConstructor\") {\n      let homeObject = val.$HomeObject;\n      if (homeObject instanceof ObjectValue && homeObject.$IsClassPrototype) {\n        this._serializeClass(val, homeObject, bindingsEmittedSemaphore);\n        return;\n      }\n    }\n    bindingsEmittedSemaphore.releaseOne();\n    this._emitObjectProperties(val);\n    let additionalFVEffects = this.additionalFunctionValuesAndEffects;\n    let additionalEffects = additionalFVEffects && additionalFVEffects.get(val);\n    if (additionalEffects) this._serializeAdditionalFunction(val, additionalEffects);\n  }\n\n  _serializeClass(\n    classFunc: ECMAScriptSourceFunctionValue,\n    classPrototype: ObjectValue,\n    bindingsEmittedSemaphore: CountingSemaphore\n  ): void {\n    let classMethodInstance = this.residualClassMethodInstances.get(classFunc);\n\n    invariant(classMethodInstance !== undefined);\n\n    let classProtoId;\n    let hasSerializedClassProtoId = false;\n    let propertiesToSerialize = new Map();\n\n    // handle class inheritance\n    if (!(classFunc.$Prototype instanceof NativeFunctionValue)) {\n      classMethodInstance.classSuperNode = this.serializeValue(classFunc.$Prototype);\n    }\n\n    let serializeClassPrototypeId = () => {\n      if (!hasSerializedClassProtoId) {\n        let classId = this.getSerializeObjectIdentifier(classFunc);\n        classProtoId = t.identifier(this.intrinsicNameGenerator.generate());\n        hasSerializedClassProtoId = true;\n        this.emitter.emit(\n          t.variableDeclaration(\"var\", [\n            t.variableDeclarator(classProtoId, t.memberExpression(classId, t.identifier(\"prototype\"))),\n          ])\n        );\n      }\n    };\n\n    let serializeClassMethodOrProperty = (propertyNameOrSymbol, methodFuncOrProperty) => {\n      const serializeNameAndId = () => {\n        let methodFuncOrPropertyId = this.serializeValue(methodFuncOrProperty);\n        let name;\n\n        if (typeof propertyNameOrSymbol === \"string\") {\n          name = t.identifier(propertyNameOrSymbol);\n        } else {\n          name = this.serializeValue(propertyNameOrSymbol);\n        }\n        return { name, methodFuncOrPropertyId };\n      };\n\n      if (methodFuncOrProperty instanceof ECMAScriptSourceFunctionValue) {\n        if (methodFuncOrProperty !== classFunc) {\n          // if the method does not have a $HomeObject, it's not a class method\n          if (methodFuncOrProperty.$HomeObject !== undefined) {\n            this.serializedValues.add(methodFuncOrProperty);\n            this._serializeClassMethod(propertyNameOrSymbol, methodFuncOrProperty);\n          } else {\n            // if the method is not part of the class, we have to assign it to the prototype\n            // we can't serialize via emitting the properties as that will emit all\n            // the prototype and we only want to mutate the prototype here\n            serializeClassPrototypeId();\n            invariant(classProtoId !== undefined);\n            let { name, methodFuncOrPropertyId } = serializeNameAndId();\n            this.emitter.emit(\n              t.expressionStatement(\n                t.assignmentExpression(\"=\", t.memberExpression(classProtoId, name), methodFuncOrPropertyId)\n              )\n            );\n          }\n        }\n      } else {\n        let prototypeId = t.memberExpression(this.getSerializeObjectIdentifier(classFunc), t.identifier(\"prototype\"));\n        let { name, methodFuncOrPropertyId } = serializeNameAndId();\n        this.emitter.emit(\n          t.expressionStatement(\n            t.assignmentExpression(\"=\", t.memberExpression(prototypeId, name), methodFuncOrPropertyId)\n          )\n        );\n      }\n    };\n\n    let serializeClassProperty = (propertyNameOrSymbol, propertyValue) => {\n      // we handle the prototype via class syntax\n      if (propertyNameOrSymbol === \"prototype\") {\n        this.serializedValues.add(propertyValue);\n      } else if (propertyValue instanceof ECMAScriptSourceFunctionValue && propertyValue.$HomeObject === classFunc) {\n        serializeClassMethodOrProperty(propertyNameOrSymbol, propertyValue);\n      } else {\n        let prop = classFunc.properties.get(propertyNameOrSymbol);\n        invariant(prop);\n        propertiesToSerialize.set(propertyNameOrSymbol, prop);\n      }\n    };\n\n    // find the all the properties on the class that we need to serialize\n    for (let [propertyName, method] of classFunc.properties) {\n      if (\n        !this.residualHeapInspector.canIgnoreProperty(classFunc, propertyName) &&\n        !ClassPropertiesToIgnore.has(propertyName) &&\n        method.descriptor !== undefined &&\n        !(propertyName === \"length\" && canIgnoreClassLengthProperty(classFunc, method.descriptor, this.logger))\n      ) {\n        withDescriptorValue(propertyName, method.descriptor, serializeClassProperty);\n      }\n    }\n    // pass in the properties and set it so we don't serialize the prototype\n    bindingsEmittedSemaphore.releaseOne();\n    this._emitObjectProperties(classFunc, propertiesToSerialize, undefined, undefined, true);\n\n    // handle non-symbol properties\n    for (let [propertyName, method] of classPrototype.properties) {\n      withDescriptorValue(propertyName, method.descriptor, serializeClassMethodOrProperty);\n    }\n    // handle symbol properties\n    for (let [symbol, method] of classPrototype.symbols) {\n      withDescriptorValue(symbol, method.descriptor, serializeClassMethodOrProperty);\n    }\n    // assign the AST method key node for the \"constructor\"\n    classMethodInstance.classMethodKeyNode = t.identifier(\"constructor\");\n  }\n\n  _serializeClassMethod(key: string | SymbolValue, methodFunc: ECMAScriptSourceFunctionValue): void {\n    let classMethodInstance = this.residualClassMethodInstances.get(methodFunc);\n\n    invariant(classMethodInstance !== undefined);\n    if (typeof key === \"string\") {\n      classMethodInstance.classMethodKeyNode = t.identifier(key);\n      // as we know the method name is a string again, we can remove the computed status\n      classMethodInstance.classMethodComputed = false;\n    } else if (key instanceof SymbolValue) {\n      classMethodInstance.classMethodKeyNode = this.serializeValue(key);\n    } else {\n      invariant(false, \"Unknown method key type\");\n    }\n    this._serializeValueFunction(methodFunc);\n  }\n\n  // Checks whether a property can be defined via simple assignment, or using object literal syntax.\n  _canEmbedProperty(obj: ObjectValue, key: string | SymbolValue | AbstractValue, prop: Descriptor): boolean {\n    if (prop.joinCondition !== undefined) return false;\n\n    let targetDescriptor = this.residualHeapInspector.getTargetIntegrityDescriptor(obj);\n\n    if ((obj instanceof FunctionValue && key === \"prototype\") || (obj.getKind() === \"RegExp\" && key === \"lastIndex\"))\n      return (\n        prop.writable === targetDescriptor.writable && !prop.configurable && !prop.enumerable && !prop.set && !prop.get\n      );\n    else if (\n      prop.writable === targetDescriptor.writable &&\n      prop.configurable === targetDescriptor.configurable &&\n      !!prop.enumerable &&\n      !prop.set &&\n      !prop.get\n    ) {\n      return !(prop.value instanceof AbstractValue && prop.value.kind === \"widened property\");\n    } else {\n      return false;\n    }\n  }\n\n  _findLastObjectPrototype(obj: ObjectValue): ObjectValue {\n    while (obj.$Prototype instanceof ObjectValue) obj = obj.$Prototype;\n    return obj;\n  }\n\n  _serializeValueRegExpObject(val: ObjectValue): BabelNodeExpression {\n    let source = val.$OriginalSource;\n    let flags = val.$OriginalFlags;\n    invariant(typeof source === \"string\");\n    invariant(typeof flags === \"string\");\n    this._emitObjectProperties(val);\n    source = new RegExp(source).source; // add escapes as per 21.2.3.2.4\n    return t.regExpLiteral(source, flags);\n  }\n\n  // Overridable.\n  serializeValueRawObject(\n    val: ObjectValue,\n    skipPrototype: boolean,\n    emitIntegrityCommand: void | (SerializedBody => void)\n  ): BabelNodeExpression {\n    let remainingProperties = new Map(val.properties);\n    const dummyProperties = new Set();\n    let props = [];\n    if (val.temporalAlias !== undefined) {\n      return t.objectExpression(props);\n    } else {\n      for (let [key, propertyBinding] of val.properties) {\n        if (propertyBinding.pathNode !== undefined) continue; // written to inside loop\n        let descriptor = propertyBinding.descriptor;\n        if (descriptor === undefined || descriptor.value === undefined) continue; // deleted\n        if (this._canEmbedProperty(val, key, descriptor)) {\n          let propValue = descriptor.value;\n          invariant(propValue instanceof Value);\n          if (this.residualHeapInspector.canIgnoreProperty(val, key)) continue;\n          let mightHaveBeenDeleted = propValue.mightHaveBeenDeleted();\n          let serializedKey = this.generator.getAsPropertyNameExpression(key);\n          let delayReason =\n            this.emitter.getReasonToWaitForDependencies(propValue) ||\n            this.emitter.getReasonToWaitForActiveValue(val, mightHaveBeenDeleted);\n          // Although the property needs to be delayed, we still want to emit dummy \"undefined\"\n          // value as part of the object literal to ensure a consistent property ordering.\n          let serializedValue = voidExpression;\n          if (delayReason) {\n            // May need to be cleaned up later.\n            dummyProperties.add(key);\n          } else {\n            remainingProperties.delete(key);\n            serializedValue = this.serializeValue(propValue);\n          }\n          props.push(t.objectProperty(serializedKey, serializedValue));\n        } else if (descriptor.value instanceof Value && descriptor.value.mightHaveBeenDeleted()) {\n          dummyProperties.add(key);\n          let serializedKey = this.generator.getAsPropertyNameExpression(key);\n          props.push(t.objectProperty(serializedKey, voidExpression));\n        }\n      }\n    }\n    this._emitObjectProperties(\n      val,\n      remainingProperties,\n      /*objectPrototypeAlreadyEstablished*/ false,\n      dummyProperties,\n      skipPrototype\n    );\n    return t.objectExpression(props);\n  }\n\n  _serializeValueObjectViaConstructor(val: ObjectValue, skipPrototype: boolean, classConstructor?: Value) {\n    let proto = val.$Prototype;\n    this._emitObjectProperties(\n      val,\n      val.properties,\n      /*objectPrototypeAlreadyEstablished*/ true,\n      undefined,\n      skipPrototype\n    );\n    let serializedProto = this.serializeValue(classConstructor ? classConstructor : proto);\n    if (val.temporalAlias === undefined) {\n      this.needsAuxiliaryConstructor = true;\n      return t.sequenceExpression([\n        t.assignmentExpression(\n          \"=\",\n          t.memberExpression(constructorExpression, t.identifier(\"prototype\")),\n          classConstructor ? t.memberExpression(serializedProto, t.identifier(\"prototype\")) : serializedProto\n        ),\n        t.newExpression(constructorExpression, []),\n      ]);\n    } else {\n      this.emitter.emitAfterWaiting(\n        val.temporalAlias,\n        [],\n        () => {\n          invariant(val.temporalAlias !== undefined);\n          let uid = this.serializeValue(val.temporalAlias);\n          this.emitter.emit(\n            t.expressionStatement(\n              t.callExpression(this.preludeGenerator.memoizeReference(\"Object.setPrototypeOf\"), [uid, serializedProto])\n            )\n          );\n        },\n        this.emitter.getBody()\n      );\n      return t.objectExpression([]);\n    }\n  }\n\n  serializeValueObject(\n    val: ObjectValue,\n    emitIntegrityCommand: void | (SerializedBody => void)\n  ): BabelNodeExpression | void {\n    // If this object is a prototype object that was implicitly created by the runtime\n    // for a constructor, then we can obtain a reference to this object\n    // in a special way that's handled alongside function serialization.\n    let constructor = val.originalConstructor;\n    if (constructor !== undefined) {\n      let prototypeId = this.residualHeapValueIdentifiers.getIdentifier(val);\n      this.emitter.emitNowOrAfterWaitingForDependencies(\n        [constructor],\n        () => {\n          invariant(constructor !== undefined);\n          invariant(prototypeId !== undefined);\n          this.serializeValue(constructor);\n          this._emitObjectProperties(val);\n          invariant(prototypeId.type === \"Identifier\");\n          this.residualFunctions.setFunctionPrototype(constructor, prototypeId);\n        },\n        this.emitter.getBody()\n      );\n      return prototypeId;\n    }\n\n    let kind = val.getKind();\n    switch (kind) {\n      case \"RegExp\":\n        return this._serializeValueRegExpObject(val);\n      case \"Number\":\n        let numberData = val.$NumberData;\n        invariant(numberData !== undefined);\n        numberData.throwIfNotConcreteNumber();\n        invariant(numberData instanceof NumberValue, \"expected number data internal slot to be a number value\");\n        this._emitObjectProperties(val);\n        return t.newExpression(this.preludeGenerator.memoizeReference(\"Number\"), [t.numericLiteral(numberData.value)]);\n      case \"String\":\n        let stringData = val.$StringData;\n        invariant(stringData !== undefined);\n        stringData.throwIfNotConcreteString();\n        invariant(stringData instanceof StringValue, \"expected string data internal slot to be a string value\");\n        this._emitObjectProperties(val);\n        return t.newExpression(this.preludeGenerator.memoizeReference(\"String\"), [t.stringLiteral(stringData.value)]);\n      case \"Boolean\":\n        let booleanData = val.$BooleanData;\n        invariant(booleanData !== undefined);\n        booleanData.throwIfNotConcreteBoolean();\n        invariant(booleanData instanceof BooleanValue, \"expected boolean data internal slot to be a boolean value\");\n        this._emitObjectProperties(val);\n        return t.newExpression(this.preludeGenerator.memoizeReference(\"Boolean\"), [\n          t.booleanLiteral(booleanData.value),\n        ]);\n      case \"Date\":\n        let dateValue = val.$DateValue;\n        invariant(dateValue !== undefined);\n        let serializedDateValue = this.serializeValue(dateValue);\n        this._emitObjectProperties(val);\n        return t.newExpression(this.preludeGenerator.memoizeReference(\"Date\"), [serializedDateValue]);\n      case \"Float32Array\":\n      case \"Float64Array\":\n      case \"Int8Array\":\n      case \"Int16Array\":\n      case \"Int32Array\":\n      case \"Uint8Array\":\n      case \"Uint16Array\":\n      case \"Uint32Array\":\n      case \"Uint8ClampedArray\":\n      case \"DataView\":\n        return this._serializeValueTypedArrayOrDataView(val);\n      case \"ArrayBuffer\":\n        return this._serializeValueArrayBuffer(val);\n      case \"ReactElement\":\n        this.residualReactElementSerializer.serializeReactElement(val);\n        return;\n      case \"Map\":\n      case \"WeakMap\":\n        return this._serializeValueMap(val);\n      case \"Set\":\n      case \"WeakSet\":\n        return this._serializeValueSet(val);\n      default:\n        invariant(kind === \"Object\", \"invariant established by visitor\");\n\n        let proto = val.$Prototype;\n        let { skipPrototype, constructor: _constructor } = getObjectPrototypeMetadata(this.realm, val);\n        let createViaAuxiliaryConstructor =\n          val.temporalAlias === undefined &&\n          proto !== this.realm.intrinsics.ObjectPrototype &&\n          this._findLastObjectPrototype(val) === this.realm.intrinsics.ObjectPrototype &&\n          proto instanceof ObjectValue &&\n          !skipPrototype;\n\n        return createViaAuxiliaryConstructor || _constructor\n          ? this._serializeValueObjectViaConstructor(val, skipPrototype, _constructor)\n          : this.serializeValueRawObject(val, skipPrototype, emitIntegrityCommand);\n    }\n  }\n\n  _serializeValueSymbol(val: SymbolValue): BabelNodeExpression {\n    let args = [];\n    if (val.$Description instanceof Value) {\n      let serializedArg = this.serializeValue(val.$Description);\n      invariant(serializedArg);\n      args.push(serializedArg);\n    }\n    // check if symbol value exists in the global symbol map, in that case we emit an invocation of System.for\n    // to look it up\n    let globalReg = this.realm.globalSymbolRegistry.find(e => e.$Symbol === val) !== undefined;\n    if (globalReg) {\n      return t.callExpression(this.preludeGenerator.memoizeReference(\"Symbol.for\"), args);\n    } else {\n      return t.callExpression(this.preludeGenerator.memoizeReference(\"Symbol\"), args);\n    }\n  }\n\n  _serializeValueProxy(val: ProxyValue): BabelNodeExpression {\n    return t.newExpression(this.preludeGenerator.memoizeReference(\"Proxy\"), [\n      this.serializeValue(val.$ProxyTarget),\n      this.serializeValue(val.$ProxyHandler),\n    ]);\n  }\n\n  _serializeAbstractValueHelper(val: AbstractValue): BabelNodeExpression {\n    let serializedArgs = val.args.map((abstractArg, i) => this.serializeValue(abstractArg));\n    if (val.kind === \"abstractConcreteUnion\") {\n      let abstractIndex = val.args.findIndex(v => v instanceof AbstractValue);\n      invariant(abstractIndex >= 0 && abstractIndex < val.args.length);\n      return serializedArgs[abstractIndex];\n    }\n    if (val.kind === \"explicit conversion to object\") {\n      let ob = serializedArgs[0];\n      invariant(ob !== undefined);\n      return t.callExpression(this.preludeGenerator.memoizeReference(\"Object.assign\"), [ob]);\n    } else if (val.kind === \"template for prototype member expression\") {\n      let obj = this.serializeValue(val.args[0]);\n      let prop = this.serializeValue(val.args[1]);\n      return t.memberExpression(obj, prop, true);\n    }\n    let serializedValue = val.buildNode(serializedArgs);\n    if (serializedValue.type === \"Identifier\") {\n      let id = ((serializedValue: any): BabelNodeIdentifier);\n      invariant(\n        !this.preludeGenerator.derivedIds.has(id.name) ||\n          this.emitter.cannotDeclare() ||\n          this.emitter.hasBeenDeclared(val) ||\n          (this.emitter.emittingToAdditionalFunction() && this.referencedDeclaredValues.get(val) === undefined),\n        `an abstract value with an identifier \"${id.name}\" was referenced before being declared`\n      );\n    }\n    return serializedValue;\n  }\n\n  _serializeAbstractValue(val: AbstractValue): void | BabelNodeExpression {\n    invariant(val.kind !== \"sentinel member expression\", \"invariant established by visitor\");\n    if (val.kind === \"conditional\") {\n      let cf = this.conditionalFeasibility.get(val);\n      invariant(cf !== undefined);\n      if (cf.t && !cf.f) return this.serializeValue(val.args[1]);\n      else if (!cf.t && cf.f) return this.serializeValue(val.args[2]);\n      else invariant(cf.t && cf.f);\n    }\n\n    if (val.hasIdentifier()) {\n      return this._serializeAbstractValueHelper(val);\n    } else {\n      // This abstract value's dependencies should all be declared\n      // but still need to check them again in case their serialized bodies are in different generator scope.\n      let reason = this.emitter.getReasonToWaitForDependencies(val.args);\n      if (reason === undefined) {\n        return this._serializeAbstractValueHelper(val);\n      } else {\n        this.emitter.emitAfterWaiting(\n          reason,\n          val.args,\n          () => {\n            const serializedValue = this._serializeAbstractValueHelper(val);\n            let uid = this.getSerializeObjectIdentifier(val);\n            this._declare(this.emitter.cannotDeclare(), undefined, \"var\", uid, serializedValue);\n          },\n          this.emitter.getBody()\n        );\n      }\n    }\n  }\n\n  _serializeEmptyValue(): BabelNodeExpression {\n    this.needsEmptyVar = true;\n    return emptyExpression;\n  }\n\n  _serializeValue(val: Value): void | BabelNodeExpression {\n    if (val instanceof AbstractValue) {\n      return this._serializeAbstractValue(val);\n    } else if (val.isIntrinsic()) {\n      return this._serializeValueIntrinsic(val);\n    } else if (val instanceof EmptyValue) {\n      return this._serializeEmptyValue();\n    } else if (val instanceof UndefinedValue) {\n      return voidExpression;\n    } else if (ResidualHeapInspector.isLeaf(val)) {\n      return t.valueToNode(val.serialize());\n    } else if (val instanceof ObjectValue) {\n      return this._serializeValueObjectBase(val);\n    } else {\n      invariant(val instanceof SymbolValue);\n      return this._serializeValueSymbol(val);\n    }\n  }\n\n  _serializeValueObjectBase(obj: ObjectValue) {\n    if (obj instanceof ProxyValue) {\n      return this._serializeValueProxy(obj);\n    }\n\n    let objectSemaphore;\n    let targetCommand = this.residualHeapInspector.getTargetIntegrityCommand(obj);\n    let emitIntegrityCommand;\n    if (targetCommand) {\n      let body = this.emitter.getBody();\n      objectSemaphore = new CountingSemaphore(() => {\n        this.emitter.emitNowOrAfterWaitingForDependencies(\n          [obj],\n          () => {\n            let uid = this.getSerializeObjectIdentifier(obj);\n            this.emitter.emit(\n              t.expressionStatement(\n                t.callExpression(this.preludeGenerator.memoizeReference(\"Object.\" + targetCommand), [uid])\n              )\n            );\n          },\n          body\n        );\n      });\n      this._objectSemaphores.set(obj, objectSemaphore);\n      emitIntegrityCommand = alternateBody => {\n        if (objectSemaphore !== undefined) {\n          if (alternateBody !== undefined) body = alternateBody;\n          objectSemaphore.releaseOne();\n          this._objectSemaphores.delete(obj);\n        }\n        objectSemaphore = undefined;\n      };\n    }\n    let res;\n    if (IsArray(this.realm, obj)) {\n      res = this._serializeValueArray(obj);\n    } else if (obj instanceof FunctionValue) {\n      res = this._serializeValueFunction(obj);\n    } else {\n      res = this.serializeValueObject(obj, emitIntegrityCommand);\n    }\n    if (emitIntegrityCommand !== undefined) emitIntegrityCommand();\n    return res;\n  }\n\n  _serializeGlobalBinding(boundName: string, binding: ResidualFunctionBinding) {\n    invariant(!binding.declarativeEnvironmentRecord);\n    if (!binding.serializedValue) {\n      binding.referentialized = true;\n      if (boundName === \"undefined\") {\n        binding.serializedValue = voidExpression;\n      } else if (binding.value !== undefined) {\n        binding.serializedValue = t.identifier(boundName);\n        invariant(binding.value !== undefined);\n        this.declaredGlobalLets.set(boundName, binding.value);\n      }\n    }\n  }\n\n  _annotateGeneratorStatements(generator: Generator, statements: Array<BabelNodeStatement>) {\n    let comment = `generator \"${generator.getName()}\"`;\n    let parent = this.generatorDAG.getParent(generator);\n    if (parent instanceof Generator) {\n      comment = `${comment} with parent \"${parent.getName()}\"`;\n    } else if (parent instanceof FunctionValue) {\n      comment = `${comment} with function parent`;\n    } else {\n      invariant(parent === \"GLOBAL\");\n      comment = `${comment} with global parent`;\n    }\n    let beginComments = [commentStatement(\"begin \" + comment)];\n    let effects = generator.effectsToApply;\n    if (effects) {\n      let valueToString = value =>\n        this.residualHeapValueIdentifiers.hasIdentifier(value)\n          ? this.residualHeapValueIdentifiers.getIdentifier(value).name\n          : \"?\";\n      let keyToString = key => (typeof key === \"string\" ? key : key instanceof Value ? valueToString(key) : \"?\");\n\n      beginComments.push(\n        commentStatement(\n          `  has effects: ${effects.createdObjects.size} created objects, ${\n            effects.modifiedBindings.size\n          } modified bindings, ${effects.modifiedProperties.size} modified properties`\n        )\n      );\n      if (effects.createdObjects.size > 0)\n        beginComments.push(\n          commentStatement(\n            `    created objects: ${Array.from(effects.createdObjects)\n              .map(valueToString)\n              .join(\", \")}`\n          )\n        );\n      if (effects.modifiedBindings.size > 0)\n        beginComments.push(\n          commentStatement(\n            `    modified bindings: ${Array.from(effects.modifiedBindings.keys())\n              .map(b => b.name)\n              .join(\", \")}`\n          )\n        );\n      if (effects.modifiedProperties.size > 0)\n        beginComments.push(\n          commentStatement(\n            `    modified properties: ${Array.from(effects.modifiedProperties.keys())\n              .map(b => `${valueToString(b.object)}.${keyToString(b.key)}`)\n              .join(\", \")}`\n          )\n        );\n    }\n    statements.unshift(...beginComments);\n    statements.push(commentStatement(\"end \" + comment));\n  }\n\n  _withGeneratorScope(\n    type: \"Generator\" | \"AdditionalFunction\",\n    generator: Generator,\n    valuesToProcess: void | Set<AbstractValue | ConcreteValue>,\n    callback: SerializedBody => void,\n    isChildOverride?: boolean\n  ): Array<BabelNodeStatement> {\n    let newBody = { type, parentBody: undefined, entries: [], done: false };\n    let isChild = isChildOverride || type === \"Generator\";\n    let oldBody = this.emitter.beginEmitting(generator, newBody, /*isChild*/ isChild);\n    invariant(!this.activeGeneratorBodies.has(generator));\n    this.activeGeneratorBodies.set(generator, newBody);\n    callback(newBody);\n    invariant(this.activeGeneratorBodies.has(generator));\n    this.activeGeneratorBodies.delete(generator);\n    const statements = this.emitter.endEmitting(generator, oldBody, valuesToProcess, /*isChild*/ isChild).entries;\n    if (this._options.debugScopes) this._annotateGeneratorStatements(generator, statements);\n    this.getStatistics().generators++;\n    return statements;\n  }\n\n  _getContext(): SerializationContext {\n    // TODO #482: Values serialized by nested generators would currently only get defined\n    // along the code of the nested generator; their definitions need to get hoisted\n    // or repeated so that they are accessible and defined from all using scopes\n    let context = {\n      serializeValue: this.serializeValue.bind(this),\n      serializeBinding: this.serializeBinding.bind(this),\n      serializeGenerator: (\n        generator: Generator,\n        valuesToProcess: Set<AbstractValue | ConcreteValue>\n      ): Array<BabelNodeStatement> =>\n        this._withGeneratorScope(\"Generator\", generator, valuesToProcess, () => generator.serialize(context)),\n      initGenerator: (generator: Generator) => {\n        let activeGeneratorBody = this._getActiveBodyOfGenerator(generator);\n        invariant(activeGeneratorBody === this.emitter.getBody(), \"generator to init must be current emitter body\");\n        let s = this.additionalGeneratorRoots.get(generator);\n        if (s !== undefined) for (let value of s) this.serializeValue(value);\n      },\n      finalizeGenerator: (generator: Generator) => {\n        let activeGeneratorBody = this._getActiveBodyOfGenerator(generator);\n        invariant(activeGeneratorBody === this.emitter.getBody(), \"generator to finalize must be current emitter body\");\n        this.emitter.finalizeCurrentBody();\n      },\n      emit: (statement: BabelNodeStatement) => {\n        this.emitter.emit(statement);\n      },\n      processValues: (valuesToProcess: Set<AbstractValue | ConcreteValue>) => {\n        this.emitter.processValues(valuesToProcess);\n      },\n      emitDefinePropertyBody: this.emitDefinePropertyBody.bind(this, false, undefined),\n      canOmit: (value: AbstractValue | ConcreteValue) => {\n        return !this.referencedDeclaredValues.has(value);\n      },\n      declare: (value: AbstractValue | ConcreteValue) => {\n        this.emitter.declare(value);\n      },\n      emitPropertyModification: (propertyBinding: PropertyBinding) => {\n        let desc = propertyBinding.descriptor;\n        let object = propertyBinding.object;\n        invariant(object instanceof ObjectValue);\n        if (this.residualValues.has(object)) {\n          let key = propertyBinding.key;\n          invariant(key !== undefined, \"established by visitor\");\n          let dependencies = [];\n          if (desc !== undefined) dependencies.push(...this._getDescriptorValues(desc));\n          dependencies.push(object);\n          if (key instanceof Value) dependencies.push(key);\n          this.emitter.emitNowOrAfterWaitingForDependencies(\n            dependencies,\n            () => {\n              // separate serialize object, as _emitProperty assumes that this already happened\n              this.serializeValue(object);\n              this._emitProperty(object, key, desc, true);\n            },\n            this.emitter.getBody()\n          );\n        }\n      },\n      options: this._options,\n    };\n    return context;\n  }\n\n  _shouldBeWrapped(body: Array<any>) {\n    for (let i = 0; i < body.length; i++) {\n      let item = body[i];\n      if (item.type === \"ExpressionStatement\") {\n        continue;\n      } else if (item.type === \"VariableDeclaration\" || item.type === \"FunctionDeclaration\") {\n        return true;\n      } else if (item.type === \"BlockStatement\") {\n        if (this._shouldBeWrapped(item.body)) {\n          return true;\n        }\n      } else if (item.type === \"IfStatement\") {\n        if (item.alternate) {\n          if (this._shouldBeWrapped(item.alternate.body)) {\n            return true;\n          }\n        }\n        if (item.consequent) {\n          if (this._shouldBeWrapped(item.consequent.body)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  _serializeAdditionalFunctionGeneratorAndEffects(\n    generator: Generator,\n    functionValue: FunctionValue,\n    additionalEffects: AdditionalFunctionEffects\n  ) {\n    let inAdditionalFunction = this.isReferencedOnlyByAdditionalFunction(functionValue);\n    return this._withGeneratorScope(\n      \"AdditionalFunction\",\n      generator,\n      /*valuesToProcess*/ undefined,\n      newBody => {\n        let effectsGenerator = additionalEffects.generator;\n        invariant(effectsGenerator === generator);\n        effectsGenerator.serialize(this._getContext());\n        this.realm.withEffectsAppliedInGlobalEnv(() => {\n          const lazyHoistedReactNodes = this.residualReactElementSerializer.serializeLazyHoistedNodes();\n          this.mainBody.entries.push(...lazyHoistedReactNodes);\n          return null;\n        }, additionalEffects.effects);\n      },\n      !!inAdditionalFunction\n    );\n  }\n\n  // result -- serialize it, a return statement will be generated later, must be a Value\n  // Generator -- visit all entries\n  // Bindings -- only need to serialize bindings if they're captured by some nested function?\n  //          -- need to apply them and maybe need to revisit functions in ancestors to make sure\n  //          -- we don't overwrite anything they capture\n  // PropertyBindings -- visit any property bindings that aren't to createdobjects\n  // CreatedObjects -- should take care of itself\n  _serializeAdditionalFunction(additionalFunctionValue: FunctionValue, additionalEffects: AdditionalFunctionEffects) {\n    let { effects, transforms, generator, additionalRoots } = additionalEffects;\n    // No function info means the function is dead code, also break recursive cycles where we've already started\n    // serializing this value\n    if (\n      !this.additionalFunctionValueInfos.has(additionalFunctionValue) ||\n      this.rewrittenAdditionalFunctions.has(additionalFunctionValue)\n    ) {\n      return;\n    }\n    this.rewrittenAdditionalFunctions.set(additionalFunctionValue, []);\n\n    // visit all additional roots before going into the additional functions;\n    // this ensures that those potentially stateful additional roots will get\n    // initially serialized with the right initial effects applied.\n    for (let additionalRoot of additionalRoots) this.serializeValue(additionalRoot);\n\n    let createdObjects = effects.createdObjects;\n    let nestedFunctions = new Set([...createdObjects].filter(object => object instanceof FunctionValue));\n    // Allows us to emit function declarations etc. inside of this additional\n    // function instead of adding them at global scope\n    // TODO: make sure this generator isn't getting mutated oddly\n    ((nestedFunctions: any): Set<FunctionValue>).forEach(val => this.additionalFunctionValueNestedFunctions.add(val));\n    let body = this._serializeAdditionalFunctionGeneratorAndEffects(\n      generator,\n      additionalFunctionValue,\n      additionalEffects\n    );\n    invariant(additionalFunctionValue instanceof ECMAScriptSourceFunctionValue);\n    for (let transform of transforms) {\n      transform(body);\n    }\n    this.rewrittenAdditionalFunctions.set(additionalFunctionValue, body);\n  }\n\n  prepareAdditionalFunctionValues() {\n    let additionalFVEffects = this.additionalFunctionValuesAndEffects;\n    if (additionalFVEffects)\n      for (let [additionalFunctionValue, { generator }] of additionalFVEffects.entries()) {\n        invariant(!this.additionalFunctionGenerators.has(additionalFunctionValue));\n        this.additionalFunctionGenerators.set(additionalFunctionValue, generator);\n      }\n  }\n\n  // Hook point for any serialization needs to be done after generator serialization is complete.\n  postGeneratorSerialization(): void {\n    // For overriding only.\n  }\n\n  serialize(): BabelNodeFile {\n    this.prepareAdditionalFunctionValues();\n\n    this.generator.serialize(this._getContext());\n    this.getStatistics().generators++;\n    invariant(this.emitter.declaredCount() <= this.preludeGenerator.derivedIds.size);\n\n    // TODO #20: add timers\n\n    // TODO #21: add event listeners\n\n    for (let [moduleId, moduleValue] of this.modules.initializedModules)\n      this.requireReturns.set(moduleId, getReplacement(this.serializeValue(moduleValue), moduleValue));\n\n    for (let [name, value] of this.declaredGlobalLets) {\n      this.emitter.emit(\n        t.expressionStatement(t.assignmentExpression(\"=\", t.identifier(name), this.serializeValue(value)))\n      );\n    }\n\n    this.postGeneratorSerialization();\n\n    Array.prototype.push.apply(this.prelude, this.preludeGenerator.prelude);\n\n    this.modules.resolveInitializedModules();\n\n    this.emitter.finalize();\n\n    this.residualFunctions.residualFunctionInitializers.factorifyInitializers(this.factoryNameGenerator);\n    let { unstrictFunctionBodies, strictFunctionBodies } = this.residualFunctions.spliceFunctions(\n      this.rewrittenAdditionalFunctions\n    );\n\n    // add strict modes\n    let strictDirective = t.directive(t.directiveLiteral(\"use strict\"));\n    let globalDirectives = [];\n    if (!this.realm.isStrict && !unstrictFunctionBodies.length && strictFunctionBodies.length) {\n      // no unstrict functions, only strict ones\n      globalDirectives.push(strictDirective);\n    } else if (unstrictFunctionBodies.length && strictFunctionBodies.length) {\n      // strict and unstrict functions\n      funcLoop: for (let node of strictFunctionBodies) {\n        if (t.isFunctionExpression(node)) {\n          let func = ((node: any): BabelNodeFunctionExpression);\n          if (func.body.directives) {\n            for (let directive of func.body.directives) {\n              if (directive.value.value === \"use strict\") {\n                // already have a use strict directive\n                continue funcLoop;\n              }\n            }\n          } else func.body.directives = [];\n\n          func.body.directives.unshift(strictDirective);\n        }\n      }\n    }\n\n    // build ast\n    if (this.needsEmptyVar) {\n      this.prelude.push(t.variableDeclaration(\"var\", [t.variableDeclarator(emptyExpression, t.objectExpression([]))]));\n    }\n    if (this.needsAuxiliaryConstructor) {\n      this.prelude.push(\n        t.variableDeclaration(\"var\", [\n          t.variableDeclarator(constructorExpression, t.functionExpression(null, [], t.blockStatement([]))),\n        ])\n      );\n    }\n\n    let body = this.prelude.concat(this.emitter.getBody().entries);\n    factorifyObjects(body, this.factoryNameGenerator);\n\n    let ast_body = [];\n    if (this.preludeGenerator.declaredGlobals.size > 0)\n      ast_body.push(\n        t.variableDeclaration(\n          \"var\",\n          Array.from(this.preludeGenerator.declaredGlobals).map(key => t.variableDeclarator(t.identifier(key)))\n        )\n      );\n    if (this.declaredGlobalLets.size > 0)\n      ast_body.push(\n        t.variableDeclaration(\n          \"let\",\n          Array.from(this.declaredGlobalLets.keys()).map(key => t.variableDeclarator(t.identifier(key)))\n        )\n      );\n    if (body.length) {\n      if (this.realm.isCompatibleWith(\"node-source-maps\")) {\n        ast_body.push(\n          t.expressionStatement(\n            t.callExpression(\n              t.memberExpression(\n                t.callExpression(t.identifier(\"require\"), [t.stringLiteral(\"source-map-support\")]),\n                t.identifier(\"install\")\n              ),\n              []\n            )\n          )\n        );\n      }\n\n      if (this._shouldBeWrapped(body)) {\n        let globalExpression = this.realm.isCompatibleWith(\"node-cli\") ? t.identifier(\"global\") : t.thisExpression();\n\n        let functionExpression = t.functionExpression(null, [], t.blockStatement(body, globalDirectives));\n        let callExpression = this.preludeGenerator.usesThis\n          ? t.callExpression(t.memberExpression(functionExpression, t.identifier(\"call\")), [globalExpression])\n          : t.callExpression(functionExpression, []);\n        ast_body.push(t.expressionStatement(callExpression));\n      } else {\n        Array.prototype.push.apply(ast_body, body);\n      }\n    }\n\n    // Make sure that the visitor visited exactly the same values as the serializer\n    if (\n      this.serializedValues.size !== this.residualValues.size ||\n      !Array.from(this.serializedValues).every(val => this.residualValues.has(val))\n    ) {\n      this._logSerializedResidualMismatches();\n      invariant(false, \"serialized \" + this.serializedValues.size + \" of \" + this.residualValues.size);\n    }\n\n    // TODO: find better way to do this?\n    // revert changes to functionInstances in case we do multiple serialization passes\n    for (let instance of this.residualFunctionInstances.values()) {\n      this.referentializer.cleanInstance(instance);\n    }\n\n    let program_directives = [];\n    if (this.realm.isStrict) program_directives.push(strictDirective);\n    return t.file(t.program(ast_body, program_directives));\n  }\n\n  _logScopes(scopes: Set<Scope>) {\n    console.log(`  referenced by ${scopes.size} scopes`);\n    for (let s of scopes)\n      if (s instanceof Generator) {\n        let text = \"\";\n        for (; s instanceof Generator; s = this.generatorDAG.getParent(s)) text += \"=>\" + s.getName();\n        console.log(`      ${text}`);\n      } else {\n        invariant(s instanceof FunctionValue);\n        console.log(`      ${s.__originalName || JSON.stringify(s.expressionLocation) || s.constructor.name}`);\n      }\n  }\n\n  _logSerializedResidualMismatches() {\n    let logValue = value => {\n      console.log(describeValue(value));\n      let scopes = this.residualValues.get(value);\n      if (scopes !== undefined) this._logScopes(scopes);\n    };\n    console.log(\"=== serialized but not visited values\");\n    for (let value of this.serializedValues) if (!this.residualValues.has(value)) logValue(value);\n    console.log(\"=== visited but not serialized values\");\n    for (let value of this.residualValues.keys()) if (!this.serializedValues.has(value)) logValue(value);\n  }\n}\n"]}