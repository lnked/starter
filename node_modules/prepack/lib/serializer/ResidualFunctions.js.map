{"version":3,"sources":["../../src/serializer/ResidualFunctions.js"],"names":["t","ResidualFunctions","constructor","realm","options","modules","requireReturns","locationService","prelude","factoryNameGenerator","residualFunctionInfos","residualFunctionInstances","residualClassMethodInstances","additionalFunctionValueInfos","additionalFunctionValueNestedFunctions","referentializer","functionPrototypes","Map","firstFunctionUsages","functions","classes","functionInstances","residualFunctionInitializers","instance","values","undefined","has","functionValue","addFunctionInstance","additionalFunctionPreludes","keys","set","getStatistics","statistics","push","code","$ECMAScriptCode","setFunctionPrototype","prototypeId","addFunctionUsage","val","bodyReference","_shouldUseFactoryFunction","funcBody","instances","length","shouldInlineFunction","scopeInstances","size","shouldInline","start","end","bodySize","functionInfo","get","usesArguments","_getIdentifierReplacements","residualFunctionBindings","unbound","res","name","nodes","residualFunctionBinding","declarativeEnvironmentRecord","value","serializedValue","replacement","referentialized","node","_getCallReplacements","requireCalls","modified","callNode","moduleId","callee","requireCallsReplaced","_hasRewrittenFunctionInstance","rewrittenAdditionalFunctions","find","_generateFactoryFunctionInfos","factoryFunctionInfos","functionBody","factoryId","suffix","__originalName","debugNames","identifier","generate","getLocation","functionUniqueTag","uniqueOrderedTag","anyContainingAdditionalFunction","every","containingAdditionalFunction","_sortFunctionByOriginalOrdering","functionEntries","sort","funcA","funcB","funcAUniqueTag","funcBUniqueTag","_createFunctionExpression","params","body","Object","assign","functionExpression","spliceFunctions","scrubFunctionInitializers","functionBodies","additionalFunctionModifiedBindingsSegment","getModifiedBindingsSegment","additionalFunction","getFunctionBody","getPrelude","b","Array","from","entries","unstrictFunctionBodies","strictFunctionBodies","funcNodes","defineFunction","funcId","funcOrClassNode","initializationStatements","initializationBody","prototype","apply","isFunctionExpression","isCallExpression","isClassExpression","variableDeclaration","variableDeclarator","id","memberExpression","funcValue","funcInfo","scopes","Set","residualBinding","modifiedBindings","scope","add","bodySegment","referentializationScope","init","getReferentializedScopeInitialization","numericLiteral","additionalFunctionInfo","$FormalParameters","rewrittenBody","blockStatement","classMethodInstance","methodType","classMethodKeyNode","classSuperNode","classMethodComputed","classPrototype","classMethodIsStatic","isConstructor","isExpression","isIdentifier","_getOrCreateClassNode","classMethod","unshift","superClass","$Strict","usesThis","normalInstances","additionalFunctionNestedInstances","naiveProcessInstances","instancesToSplice","functionClones","hasEmptyConstructor","$HasEmptyConstructor","methodParams","slice","instantiate","scopeInitialization","concat","factoryInfo","factoryNames","sameResidualBindings","isDifferent","lastBinding","firstBinding","factoryParams","key","scopeName","scopeNameId","factoryNode","factoryDeclaration","insertionPoint","functionId","hasFunctionArg","flatArgs","map","entry","funcNode","firstUsage","hasInitializerStatement","isNotEarlierThan","callArgs","thisExpression","flatArg","param","type","childBody","returnStatement","callExpression","referentializationState","createCaptureScopeAccessFunction","createCapturedScopesArrayInitialization","reverse","splice","index","initializerStatement","getInitializerStatement","classExpression","classBody"],"mappings":"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","file":"ResidualFunctions.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { FatalError } from \"../errors.js\";\nimport { Realm } from \"../realm.js\";\nimport { FunctionValue, ECMAScriptSourceFunctionValue, ObjectValue } from \"../values/index.js\";\nimport type { SerializerOptions } from \"../options.js\";\nimport * as t from \"babel-types\";\nimport type {\n  BabelNodeExpression,\n  BabelNodeStatement,\n  BabelNodeIdentifier,\n  BabelNodeBlockStatement,\n  BabelNodeLVal,\n  BabelNodeSpreadElement,\n  BabelNodeFunctionExpression,\n  BabelNodeClassExpression,\n} from \"babel-types\";\nimport type { FunctionBodyAstNode } from \"../types.js\";\nimport type { NameGenerator } from \"../utils/generator.js\";\nimport invariant from \"../invariant.js\";\nimport type {\n  ResidualFunctionBinding,\n  FunctionInfo,\n  FactoryFunctionInfo,\n  FunctionInstance,\n  AdditionalFunctionInfo,\n} from \"./types.js\";\nimport { BodyReference, AreSameResidualBinding } from \"./types.js\";\nimport { SerializerStatistics } from \"./statistics.js\";\nimport { ResidualFunctionInstantiator, type Replacement, getReplacement } from \"./ResidualFunctionInstantiator.js\";\nimport { Modules } from \"../utils/modules.js\";\nimport { ResidualFunctionInitializers } from \"./ResidualFunctionInitializers.js\";\nimport { nullExpression } from \"../utils/internalizer.js\";\nimport type { LocationService, ClassMethodInstance } from \"./types.js\";\nimport { Referentializer } from \"./Referentializer.js\";\nimport { getOrDefault } from \"./utils.js\";\n\ntype ResidualFunctionsResult = {\n  unstrictFunctionBodies: Array<BabelNodeFunctionExpression | BabelNodeClassExpression>,\n  strictFunctionBodies: Array<BabelNodeFunctionExpression | BabelNodeClassExpression>,\n};\n\nexport class ResidualFunctions {\n  constructor(\n    realm: Realm,\n    options: SerializerOptions,\n    modules: Modules,\n    requireReturns: Map<number | string, Replacement>,\n    locationService: LocationService,\n    prelude: Array<BabelNodeStatement>,\n    factoryNameGenerator: NameGenerator,\n    residualFunctionInfos: Map<BabelNodeBlockStatement, FunctionInfo>,\n    residualFunctionInstances: Map<FunctionValue, FunctionInstance>,\n    residualClassMethodInstances: Map<FunctionValue, ClassMethodInstance>,\n    additionalFunctionValueInfos: Map<FunctionValue, AdditionalFunctionInfo>,\n    additionalFunctionValueNestedFunctions: Set<FunctionValue>,\n    referentializer: Referentializer\n  ) {\n    this.realm = realm;\n    this.modules = modules;\n    this.requireReturns = requireReturns;\n    this.locationService = locationService;\n    this.prelude = prelude;\n    this.factoryNameGenerator = factoryNameGenerator;\n    this.functionPrototypes = new Map();\n    this.firstFunctionUsages = new Map();\n    this.functions = new Map();\n    this.classes = new Map();\n    this.functionInstances = [];\n    this.residualFunctionInitializers = new ResidualFunctionInitializers(locationService);\n    this.residualFunctionInfos = residualFunctionInfos;\n    this.residualFunctionInstances = residualFunctionInstances;\n    this.residualClassMethodInstances = residualClassMethodInstances;\n    this.additionalFunctionValueInfos = additionalFunctionValueInfos;\n    this.referentializer = referentializer;\n    for (let instance of residualFunctionInstances.values()) {\n      invariant(instance !== undefined);\n      if (!additionalFunctionValueInfos.has(instance.functionValue)) this.addFunctionInstance(instance);\n    }\n    this.additionalFunctionValueNestedFunctions = additionalFunctionValueNestedFunctions;\n    this.additionalFunctionPreludes = new Map();\n    for (let functionValue of additionalFunctionValueInfos.keys()) {\n      this.additionalFunctionPreludes.set(functionValue, []);\n    }\n  }\n\n  realm: Realm;\n  modules: Modules;\n  requireReturns: Map<number | string, Replacement>;\n  locationService: LocationService;\n  prelude: Array<BabelNodeStatement>;\n  factoryNameGenerator: NameGenerator;\n  functionPrototypes: Map<FunctionValue, BabelNodeIdentifier>;\n  firstFunctionUsages: Map<FunctionValue, BodyReference>;\n  functions: Map<BabelNodeBlockStatement, Array<FunctionInstance>>;\n  classes: Map<ObjectValue, BabelNodeClassExpression>;\n  functionInstances: Array<FunctionInstance>;\n  residualFunctionInitializers: ResidualFunctionInitializers;\n  residualFunctionInfos: Map<BabelNodeBlockStatement, FunctionInfo>;\n  residualFunctionInstances: Map<FunctionValue, FunctionInstance>;\n  residualClassMethodInstances: Map<FunctionValue, ClassMethodInstance>;\n  additionalFunctionValueInfos: Map<FunctionValue, AdditionalFunctionInfo>;\n  additionalFunctionValueNestedFunctions: Set<FunctionValue>;\n  referentializer: Referentializer;\n  additionalFunctionPreludes: Map<FunctionValue, Array<BabelNodeStatement>>;\n\n  getStatistics() {\n    invariant(this.realm.statistics instanceof SerializerStatistics, \"serialization requires SerializerStatistics\");\n    return this.realm.statistics;\n  }\n\n  addFunctionInstance(instance: FunctionInstance) {\n    this.functionInstances.push(instance);\n    let code = instance.functionValue.$ECMAScriptCode;\n    invariant(code != null);\n    getOrDefault(this.functions, code, () => []).push(instance);\n  }\n\n  setFunctionPrototype(constructor: FunctionValue, prototypeId: BabelNodeIdentifier) {\n    this.functionPrototypes.set(constructor, prototypeId);\n  }\n\n  addFunctionUsage(val: FunctionValue, bodyReference: BodyReference) {\n    if (!this.firstFunctionUsages.has(val)) this.firstFunctionUsages.set(val, bodyReference);\n  }\n\n  _shouldUseFactoryFunction(funcBody: BabelNodeBlockStatement, instances: Array<FunctionInstance>) {\n    invariant(instances.length > 0);\n    function shouldInlineFunction(): boolean {\n      if (instances[0].scopeInstances.size > 0) return false;\n      let shouldInline = true;\n      if (funcBody.start && funcBody.end) {\n        let bodySize = funcBody.end - funcBody.start;\n        shouldInline = bodySize <= 30;\n      }\n      return shouldInline;\n    }\n    let functionInfo = this.residualFunctionInfos.get(funcBody);\n    invariant(functionInfo);\n    let { usesArguments } = functionInfo;\n    return !shouldInlineFunction() && instances.length > 1 && !usesArguments;\n  }\n\n  _getIdentifierReplacements(\n    funcBody: BabelNodeBlockStatement,\n    residualFunctionBindings: Map<string, ResidualFunctionBinding>\n  ): Map<BabelNodeIdentifier, Replacement> {\n    let functionInfo = this.residualFunctionInfos.get(funcBody);\n    invariant(functionInfo);\n    let { unbound } = functionInfo;\n    let res = new Map();\n    for (let [name, nodes] of unbound) {\n      let residualFunctionBinding = residualFunctionBindings.get(name);\n      if (residualFunctionBinding === undefined) continue;\n\n      // Let's skip bindings that are referring to\n      // 1) something global (without an environment record), and\n      // 2) have not been assigned a value (which would mean that they have a var/let binding and Prepack will take the liberty to rename them).\n      if (\n        residualFunctionBinding.declarativeEnvironmentRecord === null &&\n        residualFunctionBinding.value === undefined\n      ) {\n        continue;\n      }\n\n      let serializedValue = residualFunctionBinding.serializedValue;\n      invariant(serializedValue !== undefined);\n      let replacement = getReplacement(\n        serializedValue,\n        residualFunctionBinding.referentialized ? undefined : residualFunctionBinding.value\n      );\n      for (let node of nodes) res.set(node, replacement);\n    }\n    return res;\n  }\n\n  _getCallReplacements(funcBody: BabelNodeBlockStatement): Map<BabelNode, Replacement> {\n    let functionInfo = this.residualFunctionInfos.get(funcBody);\n    invariant(functionInfo);\n    let { requireCalls, modified } = functionInfo;\n    let res = new Map();\n    for (let [callNode, moduleId] of requireCalls) {\n      this.getStatistics().requireCalls++;\n      if (modified.has(callNode.callee.name)) continue;\n\n      let replacement = this.requireReturns.get(\"\" + moduleId);\n      if (replacement !== undefined) {\n        this.getStatistics().requireCallsReplaced++;\n        res.set(callNode, replacement);\n      }\n    }\n    return res;\n  }\n\n  // Note: this function takes linear time. Please do not call it inside loop.\n  _hasRewrittenFunctionInstance(\n    rewrittenAdditionalFunctions: Map<FunctionValue, Array<BabelNodeStatement>>,\n    instances: Array<FunctionInstance>\n  ): boolean {\n    return instances.find(instance => rewrittenAdditionalFunctions.has(instance.functionValue)) !== undefined;\n  }\n\n  _generateFactoryFunctionInfos(\n    rewrittenAdditionalFunctions: Map<FunctionValue, Array<BabelNodeStatement>>\n  ): Map<number, FactoryFunctionInfo> {\n    const factoryFunctionInfos = new Map();\n    for (const [functionBody, instances] of this.functions) {\n      invariant(instances.length > 0);\n\n      let factoryId;\n      const suffix = instances[0].functionValue.__originalName || this.realm.debugNames ? \"factoryFunction\" : \"\";\n      if (this._shouldUseFactoryFunction(functionBody, instances)) {\n        // Rewritten function should never use factory function.\n        invariant(!this._hasRewrittenFunctionInstance(rewrittenAdditionalFunctions, instances));\n        factoryId = t.identifier(this.factoryNameGenerator.generate(suffix));\n      } else {\n        // For inline function body case, use the first function as the factory function.\n        factoryId = this.locationService.getLocation(instances[0].functionValue);\n      }\n\n      const functionUniqueTag = ((functionBody: any): FunctionBodyAstNode).uniqueOrderedTag;\n      invariant(functionUniqueTag);\n\n      const functionInfo = this.residualFunctionInfos.get(functionBody);\n      invariant(functionInfo);\n      let anyContainingAdditionalFunction = !instances.every(\n        instance => instance.containingAdditionalFunction === undefined\n      );\n      factoryFunctionInfos.set(functionUniqueTag, { factoryId, functionInfo, anyContainingAdditionalFunction });\n    }\n    return factoryFunctionInfos;\n  }\n\n  // Preserve residual functions' ordering based on its ast dfs traversal order.\n  // This is necessary to prevent unexpected code locality issues.\n  _sortFunctionByOriginalOrdering(functionEntries: Array<[BabelNodeBlockStatement, Array<FunctionInstance>]>): void {\n    functionEntries.sort((funcA, funcB) => {\n      const funcAUniqueTag = ((funcA[0]: any): FunctionBodyAstNode).uniqueOrderedTag;\n      invariant(funcAUniqueTag);\n\n      const funcBUniqueTag = ((funcB[0]: any): FunctionBodyAstNode).uniqueOrderedTag;\n      invariant(funcBUniqueTag);\n      return funcAUniqueTag - funcBUniqueTag;\n    });\n  }\n\n  _createFunctionExpression(params: Array<BabelNodeLVal>, body: BabelNodeBlockStatement) {\n    // Additional statements might be inserted at the beginning of the body, so we clone it.\n    body = ((Object.assign({}, body): any): BabelNodeBlockStatement);\n    return t.functionExpression(null, params, body);\n  }\n\n  spliceFunctions(\n    rewrittenAdditionalFunctions: Map<FunctionValue, Array<BabelNodeStatement>>\n  ): ResidualFunctionsResult {\n    this.residualFunctionInitializers.scrubFunctionInitializers();\n\n    let functionBodies = new Map();\n    // these need to get spliced in at the end\n    let additionalFunctionModifiedBindingsSegment: Map<FunctionValue, Array<BabelNodeStatement>> = new Map();\n    let getModifiedBindingsSegment = additionalFunction =>\n      getOrDefault(additionalFunctionModifiedBindingsSegment, additionalFunction, () => []);\n    let getFunctionBody = (instance: FunctionInstance): Array<BabelNodeStatement> =>\n      getOrDefault(functionBodies, instance, () => []);\n    let getPrelude = (instance: FunctionInstance): Array<BabelNodeStatement> => {\n      let additionalFunction = instance.containingAdditionalFunction;\n      let b;\n      if (additionalFunction !== undefined) {\n        b = this.additionalFunctionPreludes.get(additionalFunction);\n        invariant(b !== undefined);\n      } else {\n        b = this.prelude;\n      }\n      return b;\n    };\n\n    let functionEntries: Array<[BabelNodeBlockStatement, Array<FunctionInstance>]> = Array.from(\n      this.functions.entries()\n    );\n    this._sortFunctionByOriginalOrdering(functionEntries);\n    this.getStatistics().functions = functionEntries.length;\n    let unstrictFunctionBodies = [];\n    let strictFunctionBodies = [];\n    let funcNodes: Map<FunctionValue, BabelNodeFunctionExpression> = new Map();\n\n    let defineFunction = (instance, funcId, funcOrClassNode) => {\n      let { functionValue } = instance;\n\n      if (instance.initializationStatements.length > 0) {\n        // always add initialization statements to insertion point\n        let initializationBody = getFunctionBody(instance);\n        Array.prototype.push.apply(initializationBody, instance.initializationStatements);\n      }\n\n      let body;\n      if (t.isFunctionExpression(funcOrClassNode)) {\n        funcNodes.set(functionValue, ((funcOrClassNode: any): BabelNodeFunctionExpression));\n        body = getPrelude(instance);\n      } else {\n        invariant(t.isCallExpression(funcOrClassNode) || t.isClassExpression(funcOrClassNode)); // .bind call\n        body = getFunctionBody(instance);\n      }\n      body.push(t.variableDeclaration(\"var\", [t.variableDeclarator(funcId, funcOrClassNode)]));\n      let prototypeId = this.functionPrototypes.get(functionValue);\n      if (prototypeId !== undefined) {\n        let id = this.locationService.getLocation(functionValue);\n        invariant(id !== undefined);\n        body.push(\n          t.variableDeclaration(\"var\", [\n            t.variableDeclarator(prototypeId, t.memberExpression(id, t.identifier(\"prototype\"))),\n          ])\n        );\n      }\n    };\n\n    // Emit code for ModifiedBindings for additional functions\n    for (let [funcValue, funcInfo] of this.additionalFunctionValueInfos) {\n      let scopes = new Set();\n      for (let [, residualBinding] of funcInfo.modifiedBindings) {\n        let scope = residualBinding.scope;\n        if (scope === undefined || scopes.has(scope)) continue;\n        scopes.add(scope);\n\n        invariant(residualBinding.referentialized);\n\n        // Find the proper prelude to emit to (global vs additional function's prelude)\n        let bodySegment = getModifiedBindingsSegment(funcValue);\n\n        // binding has been referentialized, so setup the scope to be able to\n        // access bindings from other __captured_scopes initializers\n        if (scope.referentializationScope !== funcValue) {\n          let init = this.referentializer.getReferentializedScopeInitialization(scope, t.numericLiteral(scope.id));\n          // flow forces me to do this\n          Array.prototype.push.apply(bodySegment, init);\n        }\n      }\n    }\n\n    // Process Additional Functions\n    for (let [funcValue, additionalFunctionInfo] of this.additionalFunctionValueInfos.entries()) {\n      let { instance } = additionalFunctionInfo;\n      let functionValue = ((funcValue: any): ECMAScriptSourceFunctionValue);\n      let params = functionValue.$FormalParameters;\n      invariant(params !== undefined);\n\n      let rewrittenBody = rewrittenAdditionalFunctions.get(funcValue);\n      invariant(rewrittenBody);\n\n      // rewritten functions shouldn't have references fixed up because the body,\n      // consists of serialized code. For simplicity we emit their instances in a naive way\n      let functionBody = t.blockStatement(rewrittenBody);\n      let funcOrClassNode;\n\n      if (this.residualClassMethodInstances.has(funcValue)) {\n        let classMethodInstance = this.residualClassMethodInstances.get(funcValue);\n        invariant(classMethodInstance);\n        let {\n          methodType,\n          classMethodKeyNode,\n          classSuperNode,\n          classMethodComputed,\n          classPrototype,\n          classMethodIsStatic,\n        } = classMethodInstance;\n\n        let isConstructor = methodType === \"constructor\";\n        invariant(classPrototype instanceof ObjectValue);\n        invariant(classMethodKeyNode && (t.isExpression(classMethodKeyNode) || t.isIdentifier(classMethodKeyNode)));\n        // we use the classPrototype as the key to get the class expression ast node\n        funcOrClassNode = this._getOrCreateClassNode(classPrototype);\n        let classMethod = t.classMethod(\n          methodType,\n          classMethodKeyNode,\n          params,\n          functionBody,\n          classMethodComputed,\n          classMethodIsStatic\n        );\n        // add the class method to the class expression node body\n        if (isConstructor) {\n          funcOrClassNode.body.body.unshift(classMethod);\n        } else {\n          funcOrClassNode.body.body.push(classMethod);\n        }\n        // we only return the funcOrClassNode if this is the constructor\n        if (!isConstructor) {\n          continue;\n        }\n        // handle the class super\n        if (classSuperNode !== undefined) {\n          funcOrClassNode.superClass = classSuperNode;\n        }\n      } else {\n        funcOrClassNode = t.functionExpression(null, params, functionBody);\n      }\n      let id = this.locationService.getLocation(funcValue);\n      invariant(id !== undefined);\n\n      if (funcValue instanceof ECMAScriptSourceFunctionValue && funcValue.$Strict) {\n        strictFunctionBodies.push(funcOrClassNode);\n      } else {\n        unstrictFunctionBodies.push(funcOrClassNode);\n      }\n      defineFunction(instance, id, funcOrClassNode);\n    }\n\n    // Process normal functions\n    const factoryFunctionInfos = this._generateFactoryFunctionInfos(rewrittenAdditionalFunctions);\n    for (let [funcBody, instances] of functionEntries) {\n      let functionInfo = this.residualFunctionInfos.get(funcBody);\n      invariant(functionInfo);\n      let { unbound, usesThis } = functionInfo;\n      let params = instances[0].functionValue.$FormalParameters;\n      invariant(params !== undefined);\n\n      // Split instances into normal or nested in an additional function\n      let normalInstances = [];\n      let additionalFunctionNestedInstances = [];\n      for (let instance of instances) {\n        if (this.additionalFunctionValueNestedFunctions.has(instance.functionValue))\n          additionalFunctionNestedInstances.push(instance);\n        else normalInstances.push(instance);\n      }\n\n      let naiveProcessInstances = instancesToSplice => {\n        this.getStatistics().functionClones += instancesToSplice.length;\n\n        for (let instance of instancesToSplice) {\n          let { functionValue, residualFunctionBindings, scopeInstances } = instance;\n          let funcOrClassNode;\n\n          if (this.residualClassMethodInstances.has(functionValue)) {\n            let classMethodInstance = this.residualClassMethodInstances.get(functionValue);\n            invariant(classMethodInstance);\n            let {\n              classSuperNode,\n              classMethodKeyNode,\n              methodType,\n              classMethodComputed,\n              classPrototype,\n              classMethodIsStatic,\n            } = classMethodInstance;\n\n            let isConstructor = methodType === \"constructor\";\n            invariant(classPrototype instanceof ObjectValue);\n            invariant(classMethodKeyNode);\n            invariant(t.isExpression(classMethodKeyNode) || t.isIdentifier(classMethodKeyNode));\n            // we use the classPrototype as the key to get the class expression ast node\n            funcOrClassNode = this._getOrCreateClassNode(classPrototype);\n            // if we are dealing with a constructor, don't serialize it if the original\n            // had an empty user-land constructor (because we create a constructor behind the scenes for them)\n            let hasEmptyConstructor = !!functionValue.$HasEmptyConstructor;\n            if (!isConstructor || (isConstructor && !hasEmptyConstructor)) {\n              let methodParams = params.slice();\n              let classMethod = new ResidualFunctionInstantiator(\n                factoryFunctionInfos,\n                this._getIdentifierReplacements(funcBody, residualFunctionBindings),\n                this._getCallReplacements(funcBody),\n                t.classMethod(\n                  methodType,\n                  classMethodKeyNode,\n                  methodParams,\n                  funcBody,\n                  classMethodComputed,\n                  classMethodIsStatic\n                )\n              ).instantiate();\n\n              // add the class method to the class expression node body\n              if (isConstructor) {\n                funcOrClassNode.body.body.unshift(classMethod);\n              } else {\n                funcOrClassNode.body.body.push(classMethod);\n              }\n            }\n            // we only return the funcOrClassNode if this is the constructor\n            if (!isConstructor) {\n              continue;\n            }\n            // handle the class super\n            if (classSuperNode !== undefined) {\n              funcOrClassNode.superClass = classSuperNode;\n            }\n          } else {\n            funcOrClassNode = new ResidualFunctionInstantiator(\n              factoryFunctionInfos,\n              this._getIdentifierReplacements(funcBody, residualFunctionBindings),\n              this._getCallReplacements(funcBody),\n              this._createFunctionExpression(params, funcBody)\n            ).instantiate();\n\n            let scopeInitialization = [];\n            for (let scope of scopeInstances.values()) {\n              scopeInitialization = scopeInitialization.concat(\n                this.referentializer.getReferentializedScopeInitialization(scope, t.numericLiteral(scope.id))\n              );\n            }\n\n            if (scopeInitialization.length > 0)\n              funcOrClassNode.body.body = scopeInitialization.concat(funcOrClassNode.body.body);\n          }\n          let id = this.locationService.getLocation(functionValue);\n          invariant(id !== undefined);\n\n          if (functionValue.$Strict) {\n            strictFunctionBodies.push(funcOrClassNode);\n          } else {\n            unstrictFunctionBodies.push(funcOrClassNode);\n          }\n          invariant(id !== undefined);\n          invariant(funcOrClassNode !== undefined);\n          defineFunction(instance, id, funcOrClassNode);\n        }\n      };\n\n      if (additionalFunctionNestedInstances.length > 0) naiveProcessInstances(additionalFunctionNestedInstances);\n      if (normalInstances.length > 0 && !this._shouldUseFactoryFunction(funcBody, normalInstances)) {\n        naiveProcessInstances(normalInstances);\n        this.getStatistics().functionClones--;\n      } else if (normalInstances.length > 0) {\n        const functionUniqueTag = ((funcBody: any): FunctionBodyAstNode).uniqueOrderedTag;\n        invariant(functionUniqueTag);\n        const factoryInfo = factoryFunctionInfos.get(functionUniqueTag);\n        invariant(factoryInfo);\n        const { factoryId } = factoryInfo;\n\n        // filter included variables to only include those that are different\n        let factoryNames: Array<string> = [];\n        let sameResidualBindings = new Map();\n        for (let name of unbound.keys()) {\n          let isDifferent = false;\n          let lastBinding;\n\n          let firstBinding = normalInstances[0].residualFunctionBindings.get(name);\n          invariant(firstBinding);\n          if (firstBinding.modified) {\n            // Must modify for traversal\n            sameResidualBindings.set(name, firstBinding);\n            continue;\n          }\n\n          for (let { residualFunctionBindings } of normalInstances) {\n            let residualBinding = residualFunctionBindings.get(name);\n\n            invariant(residualBinding);\n            invariant(!residualBinding.modified);\n            if (!lastBinding) {\n              lastBinding = residualBinding;\n            } else if (!AreSameResidualBinding(this.realm, residualBinding, lastBinding)) {\n              isDifferent = true;\n              break;\n            }\n          }\n\n          if (isDifferent) {\n            factoryNames.push(name);\n          } else {\n            invariant(lastBinding);\n            sameResidualBindings.set(name, lastBinding);\n          }\n        }\n\n        let factoryParams: Array<BabelNodeLVal> = [];\n        for (let key of factoryNames) {\n          factoryParams.push(t.identifier(key));\n        }\n\n        let scopeInitialization = [];\n        for (let [scopeName, scope] of normalInstances[0].scopeInstances) {\n          let scopeNameId = t.identifier(scopeName);\n          factoryParams.push(scopeNameId);\n          scopeInitialization = scopeInitialization.concat(\n            this.referentializer.getReferentializedScopeInitialization(scope, scopeNameId)\n          );\n        }\n\n        factoryParams = factoryParams.concat(params).slice();\n        let factoryNode = new ResidualFunctionInstantiator(\n          factoryFunctionInfos,\n          this._getIdentifierReplacements(funcBody, sameResidualBindings),\n          this._getCallReplacements(funcBody),\n          this._createFunctionExpression(factoryParams, funcBody)\n        ).instantiate();\n\n        if (scopeInitialization.length > 0) factoryNode.body.body = scopeInitialization.concat(factoryNode.body.body);\n\n        // factory functions do not depend on any nested generator scope, so they go to the prelude\n        let factoryDeclaration = t.variableDeclaration(\"var\", [t.variableDeclarator(factoryId, factoryNode)]);\n        this.prelude.push(factoryDeclaration);\n\n        if (normalInstances[0].functionValue.$Strict) {\n          strictFunctionBodies.push(factoryNode);\n        } else {\n          unstrictFunctionBodies.push(factoryNode);\n        }\n\n        for (let instance of normalInstances) {\n          let { functionValue, residualFunctionBindings, insertionPoint } = instance;\n          let functionId = this.locationService.getLocation(functionValue);\n          invariant(functionId !== undefined);\n          let hasFunctionArg = false;\n          let flatArgs: Array<BabelNodeExpression> = factoryNames.map(name => {\n            let residualBinding = residualFunctionBindings.get(name);\n            invariant(residualBinding);\n            let serializedValue = residualBinding.serializedValue;\n            hasFunctionArg =\n              hasFunctionArg || (residualBinding.value && residualBinding.value instanceof FunctionValue);\n            invariant(serializedValue);\n            return serializedValue;\n          });\n          for (let entry of instance.scopeInstances) {\n            flatArgs.push(t.numericLiteral(entry[1].id));\n          }\n          let funcNode;\n          let firstUsage = this.firstFunctionUsages.get(functionValue);\n          invariant(insertionPoint !== undefined);\n          if (\n            // The same free variables in shared instances may refer to objects with different initialization values\n            // so a stub forward function is needed during delay initializations.\n            this.residualFunctionInitializers.hasInitializerStatement(functionValue) ||\n            usesThis ||\n            hasFunctionArg ||\n            (firstUsage !== undefined && !firstUsage.isNotEarlierThan(insertionPoint)) ||\n            this.functionPrototypes.get(functionValue) !== undefined\n          ) {\n            let callArgs: Array<BabelNodeExpression | BabelNodeSpreadElement> = [t.thisExpression()];\n            for (let flatArg of flatArgs) callArgs.push(flatArg);\n            for (let param of params) {\n              if (param.type !== \"Identifier\") {\n                throw new FatalError(\"TODO: do not know how to deal with non-Identifier parameters\");\n              }\n              callArgs.push(((param: any): BabelNodeIdentifier));\n            }\n\n            let callee = t.memberExpression(factoryId, t.identifier(\"call\"));\n\n            let childBody = t.blockStatement([t.returnStatement(t.callExpression(callee, callArgs))]);\n\n            funcNode = t.functionExpression(null, params, childBody);\n            if (functionValue.$Strict) {\n              strictFunctionBodies.push(funcNode);\n            } else {\n              unstrictFunctionBodies.push(funcNode);\n            }\n          } else {\n            funcNode = t.callExpression(\n              t.memberExpression(factoryId, t.identifier(\"bind\")),\n              [nullExpression].concat(flatArgs)\n            );\n          }\n\n          defineFunction(instance, functionId, funcNode);\n        }\n      }\n    }\n\n    for (let referentializationScope of this.referentializer.referentializationState.keys()) {\n      let prelude;\n      // Get the prelude for this additional function value\n      if (referentializationScope !== \"GLOBAL\") {\n        let additionalFunction = referentializationScope;\n        prelude = this.additionalFunctionPreludes.get(additionalFunction);\n        invariant(prelude !== undefined);\n      } else {\n        prelude = this.prelude;\n      }\n      prelude.unshift(this.referentializer.createCaptureScopeAccessFunction(referentializationScope));\n      prelude.unshift(this.referentializer.createCapturedScopesArrayInitialization(referentializationScope));\n    }\n\n    for (let instance of this.functionInstances.reverse()) {\n      let functionBody = functionBodies.get(instance);\n      if (functionBody !== undefined) {\n        let insertionPoint = instance.insertionPoint;\n        invariant(insertionPoint instanceof BodyReference);\n        // v8 seems to do something clever with array splicing, so this potentially\n        // expensive operations seems to be actually cheap.\n        insertionPoint.body.entries.splice(insertionPoint.index, 0, ...functionBody);\n      }\n    }\n\n    // Inject initializer code for indexed vars into functions (for delay initializations)\n    for (let [functionValue, funcNode] of funcNodes) {\n      let initializerStatement = this.residualFunctionInitializers.getInitializerStatement(functionValue);\n      if (initializerStatement !== undefined) {\n        invariant(t.isFunctionExpression(funcNode));\n        let blockStatement: BabelNodeBlockStatement = ((funcNode: any): BabelNodeFunctionExpression).body;\n        blockStatement.body.unshift(initializerStatement);\n      }\n    }\n\n    for (let [additionalFunction, body] of Array.from(rewrittenAdditionalFunctions.entries()).reverse()) {\n      let additionalFunctionInfo = this.additionalFunctionValueInfos.get(additionalFunction);\n      invariant(additionalFunctionInfo);\n      // Modified bindings initializers of optimized function\n      let bodySegment = additionalFunctionModifiedBindingsSegment.get(additionalFunction);\n      // initializers from Referentialization\n      let initializationStatements = getFunctionBody(additionalFunctionInfo.instance);\n      let prelude = this.additionalFunctionPreludes.get(additionalFunction);\n      invariant(prelude !== undefined);\n      let insertionPoint = additionalFunctionInfo.instance.insertionPoint;\n      invariant(insertionPoint);\n      // TODO: I think this inserts things in the wrong place\n      insertionPoint.body.entries.splice(insertionPoint.index, 0, ...initializationStatements);\n      if (bodySegment) body.unshift(...bodySegment);\n      body.unshift(...prelude);\n    }\n\n    return { unstrictFunctionBodies, strictFunctionBodies };\n  }\n  _getOrCreateClassNode(classPrototype: ObjectValue): BabelNodeClassExpression {\n    if (!this.classes.has(classPrototype)) {\n      let funcOrClassNode = t.classExpression(null, null, t.classBody([]), []);\n      this.classes.set(classPrototype, funcOrClassNode);\n      return funcOrClassNode;\n    } else {\n      let funcOrClassNode = this.classes.get(classPrototype);\n      invariant(funcOrClassNode && t.isClassExpression(funcOrClassNode));\n      return funcOrClassNode;\n    }\n  }\n}\n"]}