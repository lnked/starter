{"version":3,"sources":["../../src/serializer/visitors.js"],"names":["t","visitName","path","state","node","modified","scope","hasBinding","name","nodes","functionInfo","unbound","get","undefined","set","push","add","ignorePath","parent","isLabeledStatement","isBreakStatement","isContinueStatement","ClosureRefVisitor","enter","depth","exit","CallExpression","getModuleIdIfNodeIsRequireFunction","moduleId","requireCalls","ReferencedIdentifier","innerName","usesArguments","ThisExpression","usesThis","ids","getBindingIdentifiers"],"mappings":";;;;;;;AAWA;;AACA;;IAAYA,C;;;;AAZZ;;;;;;;;;AA2BA,SAASC,SAAT,CAAmBC,IAAnB,EAAyBC,KAAzB,EAAgCC,IAAhC,EAAsCC,QAAtC,EAAgD;AAC9C;AACA,MAAIH,KAAKI,KAAL,CAAWC,UAAX,CAAsBH,KAAKI,IAA3B,EAAiC,aAAc,IAA/C,CAAJ,EAA0D;;AAE1D;AACA,MAAIC,QAAQN,MAAMO,YAAN,CAAmBC,OAAnB,CAA2BC,GAA3B,CAA+BR,KAAKI,IAApC,CAAZ;AACA,MAAIC,UAAUI,SAAd,EAAyBV,MAAMO,YAAN,CAAmBC,OAAnB,CAA2BG,GAA3B,CAA+BV,KAAKI,IAApC,EAA2CC,QAAQ,EAAnD;AACzBA,QAAMM,IAAN,CAAWX,IAAX;AACA,MAAIC,QAAJ,EAAcF,MAAMO,YAAN,CAAmBL,QAAnB,CAA4BW,GAA5B,CAAgCZ,KAAKI,IAArC;AACf;;AAED,SAASS,UAAT,CAAoBf,IAApB,EAA6C;AAC3C,MAAIgB,SAAShB,KAAKgB,MAAlB;AACA,SAAOlB,EAAEmB,kBAAF,CAAqBD,MAArB,KAAgClB,EAAEoB,gBAAF,CAAmBF,MAAnB,CAAhC,IAA8DlB,EAAEqB,mBAAF,CAAsBH,MAAtB,CAArE;AACD;;AAEM,IAAII,gDAAoB;AAC7B,4CAA0C;AACxCC,UAAMrB,IAAN,EAA+BC,KAA/B,EAA8D;AAC5DA,YAAMO,YAAN,CAAmBc,KAAnB;AACD,KAHuC;AAIxCC,SAAKvB,IAAL,EAA8BC,KAA9B,EAA6D;AAC3DA,YAAMO,YAAN,CAAmBc,KAAnB;AACD;AANuC,GADb;;AAU7BE,iBAAexB,IAAf,EAAwCC,KAAxC,EAAuE;AACrE;AACA;AACA,QAAIA,MAAMwB,kCAAN,KAA6Cd,SAAjD,EAA4D;AAC5D,QAAIe,WAAWzB,MAAMwB,kCAAN,CAAyCzB,KAAKI,KAA9C,EAAqDJ,KAAKE,IAA1D,CAAf;AACA,QAAIwB,aAAaf,SAAjB,EAA4B;AAC5BV,UAAMO,YAAN,CAAmBmB,YAAnB,CAAgCf,GAAhC,CAAoCZ,KAAKE,IAAzC,EAA+CwB,QAA/C;AACD,GAjB4B;;AAmB7BE,uBAAqB5B,IAArB,EAA8CC,KAA9C,EAA6E;AAC3E,QAAIc,WAAWf,IAAX,CAAJ,EAAsB;;AAEtB,QAAI6B,YAAY7B,KAAKE,IAAL,CAAUI,IAA1B;AACA,QAAIuB,cAAc,WAAlB,EAA+B;AAC7B,UAAI5B,MAAMO,YAAN,CAAmBc,KAAnB,KAA6B,CAAjC,EAAoC;AAClCrB,cAAMO,YAAN,CAAmBsB,aAAnB,GAAmC,IAAnC;AACD;AACD;AACA;AACD;AACD/B,cAAUC,IAAV,EAAgBC,KAAhB,EAAuBD,KAAKE,IAA5B,EAAkC,KAAlC;AACD,GA/B4B;;AAiC7B6B,iBAAe/B,IAAf,EAAwCC,KAAxC,EAAuE;AACrE,QAAIA,MAAMO,YAAN,CAAmBc,KAAnB,KAA6B,CAAjC,EAAoC;AAClCrB,YAAMO,YAAN,CAAmBwB,QAAnB,GAA8B,IAA9B;AACD;AACF,GArC4B;;AAuC7B,0CAAwChC,IAAxC,EAAiEC,KAAjE,EAAgG;AAC9F,QAAIgC,MAAMjC,KAAKkC,qBAAL,EAAV;AACA,SAAK,IAAI5B,IAAT,IAAiB2B,GAAjB,EAAsB;AACpBlC,gBAAUC,IAAV,EAAgBC,KAAhB,EAAuBgC,IAAI3B,IAAJ,CAAvB,EAAkC,IAAlC;AACD;AACF;AA5C4B,CAAxB","file":"visitors.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm } from \"../realm.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNodeCallExpression } from \"babel-types\";\nimport type { BabelTraversePath, BabelTraverseScope } from \"babel-traverse\";\nimport type { FunctionInfo } from \"./types.js\";\n\ntype GetModuleIdIfNodeIsRequireFunction =\n  | void\n  | ((scope: BabelTraverseScope, node: BabelNodeCallExpression) => void | number | string);\n\nexport type ClosureRefVisitorState = {\n  functionInfo: FunctionInfo,\n  realm: Realm,\n  getModuleIdIfNodeIsRequireFunction: GetModuleIdIfNodeIsRequireFunction,\n};\n\nfunction visitName(path, state, node, modified) {\n  // Is the name bound to some local identifier? If so, we don't need to do anything\n  if (path.scope.hasBinding(node.name, /*noGlobals*/ true)) return;\n\n  // Otherwise, let's record that there's an unbound identifier\n  let nodes = state.functionInfo.unbound.get(node.name);\n  if (nodes === undefined) state.functionInfo.unbound.set(node.name, (nodes = []));\n  nodes.push(node);\n  if (modified) state.functionInfo.modified.add(node.name);\n}\n\nfunction ignorePath(path: BabelTraversePath) {\n  let parent = path.parent;\n  return t.isLabeledStatement(parent) || t.isBreakStatement(parent) || t.isContinueStatement(parent);\n}\n\nexport let ClosureRefVisitor = {\n  \"FunctionDeclaration|FunctionExpression\": {\n    enter(path: BabelTraversePath, state: ClosureRefVisitorState) {\n      state.functionInfo.depth++;\n    },\n    exit(path: BabelTraversePath, state: ClosureRefVisitorState) {\n      state.functionInfo.depth--;\n    },\n  },\n\n  CallExpression(path: BabelTraversePath, state: ClosureRefVisitorState) {\n    // Here we apply the require optimization by replacing require calls with their\n    // corresponding initialized modules.\n    if (state.getModuleIdIfNodeIsRequireFunction === undefined) return;\n    let moduleId = state.getModuleIdIfNodeIsRequireFunction(path.scope, path.node);\n    if (moduleId === undefined) return;\n    state.functionInfo.requireCalls.set(path.node, moduleId);\n  },\n\n  ReferencedIdentifier(path: BabelTraversePath, state: ClosureRefVisitorState) {\n    if (ignorePath(path)) return;\n\n    let innerName = path.node.name;\n    if (innerName === \"arguments\") {\n      if (state.functionInfo.depth === 1) {\n        state.functionInfo.usesArguments = true;\n      }\n      // \"arguments\" bound to local scope. therefore, there's no need to visit this identifier.\n      return;\n    }\n    visitName(path, state, path.node, false);\n  },\n\n  ThisExpression(path: BabelTraversePath, state: ClosureRefVisitorState) {\n    if (state.functionInfo.depth === 1) {\n      state.functionInfo.usesThis = true;\n    }\n  },\n\n  \"AssignmentExpression|UpdateExpression\"(path: BabelTraversePath, state: ClosureRefVisitorState) {\n    let ids = path.getBindingIdentifiers();\n    for (let name in ids) {\n      visitName(path, state, ids[name], true);\n    }\n  },\n};\n"]}