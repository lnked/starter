{"version":3,"sources":["../../src/react/components.js"],"names":["getInitialProps","getInitialContext","createSimpleClassInstance","createClassInstanceForFirstRenderOnly","createClassInstance","evaluateClassConstructor","applyGetDerivedStateFromProps","t","lifecycleMethods","Set","whitelistedProperties","realm","componentType","propsName","$FormalParameters","length","firstParam","isIdentifier","name","value","createAbstractObject","contextName","superTypeParameters","$SuperTypeParameters","undefined","secondParam","visitClassMethodAstForThisUsage","method","formalParameters","code","$ECMAScriptCode","file","program","expressionStatement","functionExpression","ThisExpression","path","parentNode","parentPath","node","isMemberExpression","props","context","componentPrototype","instance","allowedPropertyAccess","properties","has","add","$GetOwnProperty","P","call","refuseSerialization","deeplyApplyInstancePrototypeProperties","classMetadata","instanceProperties","instanceSymbols","proto","$Prototype","intrinsics","ObjectPrototype","symbol","symbols","evaluatedNode","objectAssign","Object","objectAssignCall","$Call","state","makeFinal","setState","_context","stateToUpdate","callback","prevState","newState","key","binding","descriptor","enumerable","intrinsicName","constructorFunc","evaluatePure","evaluateForEffects","propertyName","getName","getDerivedStateFromProps","getDerivedStateFromPropsCall","partialState","null","deriveState","kind","condition","args","a","b","createFromConditionalOp","false","createFromLogicalOp","createFromBinaryOp","c","createTemporalFromBuildFunction","methodNode","_args","callExpression","makeSimple","makePartial","conditional","e","isInPureScope"],"mappings":";;;;;QA+CgBA,e,GAAAA,e;QAyBAC,iB,GAAAA,iB;QA2CAC,yB,GAAAA,yB;QAuEAC,qC,GAAAA,qC;QA0DAC,mB,GAAAA,mB;QA2BAC,wB,GAAAA,wB;QAmCAC,6B,GAAAA,6B;;AAvShB;;AACA;;AAWA;;IAAYC,C;;AAEZ;;AACA;;AACA;;AACA;;AACA;;;;AACA;;;;AAGA;;;;;;AAjCA;;;;;;;;;AAmCA,MAAMC,mBAAmB,IAAIC,GAAJ,CAAQ,CAC/B,sBAD+B,EAE/B,mBAF+B,EAG/B,oBAH+B,EAI/B,oBAJ+B,EAK/B,qBAL+B,EAM/B,mBAN+B,EAO/B,2BAP+B,CAAR,CAAzB;;AAUA,MAAMC,wBAAwB,IAAID,GAAJ,CAAQ,CAAC,OAAD,EAAU,SAAV,EAAqB,MAArB,EAA6B,UAA7B,CAAR,CAA9B;;AAEO,SAAST,eAAT,CACLW,KADK,EAELC,aAFK,EAGgB;AACrB,MAAIC,YAAY,IAAhB;AACA,MAAID,kBAAkB,IAAtB,EAA4B;AAC1B,QAAI,kCAAsBD,KAAtB,EAA6BC,aAA7B,CAAJ,EAAiD;AAC/CC,kBAAY,YAAZ;AACD,KAFD,MAEO;AACL;AACA,UAAID,cAAcE,iBAAd,CAAgCC,MAAhC,GAAyC,CAA7C,EAAgD;AAC9C,YAAIC,aAAaJ,cAAcE,iBAAd,CAAgC,CAAhC,CAAjB;AACA,YAAIP,EAAEU,YAAF,CAAeD,UAAf,CAAJ,EAAgC;AAC9BH,sBAAcG,UAAF,CAAyCE,IAArD;AACD;AACF;AACF;AACF;AACD,MAAIC,QAAQ,qBAAcC,oBAAd,CAAmCT,KAAnC,EAA0CE,aAAa,OAAvD,CAAZ;AACA;AACA,uCAAyBF,KAAzB,EAAgCQ,KAAhC;AACA,2BAAUA,2CAAV;AACA,SAAOA,KAAP;AACD;;AAEM,SAASlB,iBAAT,CAA2BU,KAA3B,EAAyCC,aAAzC,EAA4G;AACjH,MAAIS,cAAc,IAAlB;AACA,MAAI,kCAAsBV,KAAtB,EAA6BC,aAA7B,CAAJ,EAAiD;AAC/C;AACA,QAAIU,sBAAsBV,cAAcW,oBAAxC;AACAF,kBAAc,cAAd;;AAEA,QAAIC,wBAAwBE,SAA5B,EAAuC;AACrC,YAAM,4BAAoB,+CAApB,CAAN;AACD;AACF,GARD,MAQO;AACL;AACA,QAAIZ,cAAcE,iBAAd,CAAgCC,MAAhC,GAAyC,CAA7C,EAAgD;AAC9C,UAAIU,cAAcb,cAAcE,iBAAd,CAAgC,CAAhC,CAAlB;AACA,UAAIP,EAAEU,YAAF,CAAeQ,WAAf,CAAJ,EAAiC;AAC/BJ,sBAAgBI,WAAF,CAA0CP,IAAxD;AACD;AACF;AACF;AACD,MAAIC,QAAQ,qBAAcC,oBAAd,CAAmCT,KAAnC,EAA0CU,eAAe,SAAzD,CAAZ;AACA,SAAOF,KAAP;AACD;;AAED,SAASO,+BAAT,CAAyCf,KAAzC,EAAuDgB,MAAvD,EAAoG;AAClG,MAAIC,mBAAmBD,OAAOb,iBAA9B;AACA,MAAIe,OAAOF,OAAOG,eAAlB;;AAEA,+BACEvB,EAAEwB,IAAF,CAAOxB,EAAEyB,OAAF,CAAU,CAACzB,EAAE0B,mBAAF,CAAsB1B,EAAE2B,kBAAF,CAAqB,IAArB,EAA2BN,gBAA3B,EAA6CC,IAA7C,CAAtB,CAAD,CAAV,CAAP,CADF,EAEE;AACEM,mBAAeC,IAAf,EAAqB;AACnB,UAAIC,aAAaD,KAAKE,UAAL,CAAgBC,IAAjC;;AAEA,UAAI,CAAChC,EAAEiC,kBAAF,CAAqBH,UAArB,CAAL,EAAuC;AACrC,cAAM,+BAAwB,wDAAxB,CAAN;AACD;AACF;AAPH,GAFF,EAWE,IAXF,EAYE,EAZF;AAcD;;AAEM,SAASnC,yBAAT,CACLS,KADK,EAELC,aAFK,EAGL6B,KAHK,EAILC,OAJK,EAKgB;AACrB,MAAIC,qBAAqB,iBAAIhC,KAAJ,EAAWC,aAAX,EAA0B,WAA1B,CAAzB;AACA,2BAAU+B,gDAAV;AACA;AACA,MAAIC,WAAW,uBAAgBjC,KAAhB,EAAuBgC,kBAAvB,EAA2C,MAA3C,EAAmD,IAAnD,CAAf;AACA,MAAIE,wBAAwB,IAAIpC,GAAJ,CAAQ,CAAC,OAAD,EAAU,SAAV,CAAR,CAA5B;AACA,OAAK,IAAI,CAACS,IAAD,CAAT,IAAmByB,mBAAmBG,UAAtC,EAAkD;AAChD,QAAItC,iBAAiBuC,GAAjB,CAAqB7B,IAArB,CAAJ,EAAgC;AAC9B;AACA,YAAM,+BAAuB,uDAAvB,CAAN;AACD,KAHD,MAGO,IAAIA,SAAS,aAAb,EAA4B;AACjC2B,4BAAsBG,GAAtB,CAA0B9B,IAA1B;AACA,UAAIS,SAAS,iBAAIhB,KAAJ,EAAWgC,kBAAX,EAA+BzB,IAA/B,CAAb;AACA,UAAIS,sDAAJ,EAAqD;AACnDD,wCAAgCf,KAAhC,EAAuCgB,MAAvC;AACD;AACD,6BAAWlB,GAAX,CAAeE,KAAf,EAAsBiC,QAAtB,EAAgC1B,IAAhC,EAAsCS,MAAtC,EAA8C,IAA9C;AACD;AACF;AACD;AACA,yBAAWlB,GAAX,CAAeE,KAAf,EAAsBiC,QAAtB,EAAgC,OAAhC,EAAyCH,KAAzC,EAAgD,IAAhD;AACA;AACA,yBAAWhC,GAAX,CAAeE,KAAf,EAAsBiC,QAAtB,EAAgC,SAAhC,EAA2CF,OAA3C,EAAoD,IAApD;AACA;AACA;AACA,MAAIO,kBAAkBL,SAASK,eAA/B;AACAL,WAASK,eAAT,GAA2BC,KAAK;AAC9B,QAAI,CAACL,sBAAsBE,GAAtB,CAA0BG,CAA1B,CAAL,EAAmC;AACjC;AACA,YAAM,+BAAuB,8EAAvB,CAAN;AACD;AACD,WAAOD,gBAAgBE,IAAhB,CAAqBP,QAArB,EAA+BM,CAA/B,CAAP;AACD,GAND;AAOA;AACAN,WAASQ,mBAAT,GAA+B,KAA/B;AACA;AACA,SAAOR,QAAP;AACD;;AAED,SAASS,sCAAT,CACE1C,KADF,EAEEiC,QAFF,EAGED,kBAHF,EAIEW,aAJF,EAKE;AACA,MAAI,EAAEC,kBAAF,EAAsBC,eAAtB,KAA0CF,aAA9C;AACA,MAAIG,QAAQd,mBAAmBe,UAA/B;;AAEA,MAAID,uCAAgCA,UAAU9C,MAAMgD,UAAN,CAAiBC,eAA/D,EAAgF;AAC9EP,2CAAuC1C,KAAvC,EAA8CiC,QAA9C,EAAwDa,KAAxD,EAA+DH,aAA/D;AACD;;AAED,OAAK,IAAI,CAACpC,IAAD,CAAT,IAAmByB,mBAAmBG,UAAtC,EAAkD;AAChD;AACA,QAAI5B,SAAS,aAAT,IAA0B,CAACqC,mBAAmBR,GAAnB,CAAuB7B,IAAvB,CAA/B,EAA6D;AAC3D,6BAAWT,GAAX,CAAeE,KAAf,EAAsBiC,QAAtB,EAAgC1B,IAAhC,EAAsC,iBAAIP,KAAJ,EAAWgC,kBAAX,EAA+BzB,IAA/B,CAAtC,EAA4E,IAA5E;AACD;AACF;AACD,OAAK,IAAI,CAAC2C,MAAD,CAAT,IAAqBlB,mBAAmBmB,OAAxC,EAAiD;AAC/C;AACA,QAAI,CAACN,gBAAgBT,GAAhB,CAAoBc,MAApB,CAAL,EAAkC;AAChC,6BAAWpD,GAAX,CAAeE,KAAf,EAAsBiC,QAAtB,EAAgCiB,MAAhC,EAAwC,iBAAIlD,KAAJ,EAAWgC,kBAAX,EAA+BkB,MAA/B,CAAxC,EAAgF,IAAhF;AACD;AACF;AACF;;AAEM,SAAS1D,qCAAT,CACLQ,KADK,EAELC,aAFK,EAGL6B,KAHK,EAILC,OAJK,EAKLqB,aALK,EAMQ;AACb,MAAInB,WAAW,qCAAyBjC,KAAzB,EAAgCC,aAAhC,EAA+CD,MAAMgD,UAAN,CAAiBnC,SAAhE,EAA2E,CAACiB,KAAD,EAAQC,OAAR,CAA3E,EAA6F,IAA7F,CAAf;AACA,MAAIsB,eAAe,iBAAIrD,KAAJ,EAAWA,MAAMgD,UAAN,CAAiBM,MAA5B,EAAoC,QAApC,CAAnB;AACA,2BAAUD,sDAAV;AACA,MAAIE,mBAAmBF,aAAaG,KAApC;AACA,2BAAUD,qBAAqB1C,SAA/B;;AAEA,2BAAUoB,sCAAV;AACAA,WAASQ,mBAAT,GAA+B,IAA/B;AACA;AACA,yBAAW3C,GAAX,CAAeE,KAAf,EAAsBiC,QAAtB,EAAgC,OAAhC,EAAyCH,KAAzC,EAAgD,IAAhD;AACA;AACA,yBAAWhC,GAAX,CAAeE,KAAf,EAAsBiC,QAAtB,EAAgC,SAAhC,EAA2CF,OAA3C,EAAoD,IAApD;AACA,MAAI0B,QAAQ,iBAAIzD,KAAJ,EAAWiC,QAAX,EAAqB,OAArB,CAAZ;AACA,MAAIwB,+CAAwCA,mCAA5C,EAA0E;AACxEA,UAAMC,SAAN;AACD;AACD;AACA,MAAIC,WAAW,+BAAwB3D,KAAxB,EAA+Ba,SAA/B,EAA2C,UAA3C,EAAsD,CAAtD,EAAyD,CAAC+C,QAAD,EAAW,CAACC,aAAD,EAAgBC,QAAhB,CAAX,KAAyC;AAC/G,6BAAU7B,sCAAV;AACA,QAAI8B,YAAY,iBAAI/D,KAAJ,EAAWiC,QAAX,EAAqB,OAArB,CAAhB;AACA,6BAAU8B,uCAAV;;AAEA,QAAIF,iEAA0DA,cAAcL,KAA5E,EAAmF;AACjFK,sBAAgBA,cAAcL,KAAd,CAAoBvB,QAApB,EAA8B,CAAC8B,SAAD,CAA9B,CAAhB;AACD;AACD,QAAIF,2CAAJ,EAA0C;AACxC,UAAIG,WAAW,uBAAgBhE,KAAhB,EAAuBA,MAAMgD,UAAN,CAAiBC,eAAxC,CAAf;AACAM,uBAAiBvD,MAAMgD,UAAN,CAAiBnC,SAAlC,EAA6C,CAACmD,QAAD,EAAWD,SAAX,CAA7C;;AAEA,WAAK,IAAI,CAACE,GAAD,EAAMC,OAAN,CAAT,IAA2BL,cAAc1B,UAAzC,EAAqD;AACnD,YAAI+B,WAAWA,QAAQC,UAAnB,IAAiCD,QAAQC,UAAR,CAAmBC,UAAxD,EAAoE;AAClE,cAAI5D,QAAQ,wBAAYR,KAAZ,EAAmB6D,aAAnB,EAAkCI,GAAlC,CAAZ;AACA,iCAAWnE,GAAX,CAAeE,KAAf,EAAsBgE,QAAtB,EAAgCC,GAAhC,EAAqCzD,KAArC,EAA4C,IAA5C;AACD;AACF;;AAEDwD,eAASN,SAAT;AACA,6BAAW5D,GAAX,CAAeE,KAAf,EAAsBiC,QAAtB,EAAgC,OAAhC,EAAyC+B,QAAzC,EAAmD,IAAnD;AACD;AACD,QAAIF,4DAAqDA,SAASN,KAAlE,EAAyE;AACvEM,eAASN,KAAT,CAAevB,QAAf,EAAyB,EAAzB;AACD;AACD,WAAOjC,MAAMgD,UAAN,CAAiBnC,SAAxB;AACD,GA1Bc,CAAf;AA2BA8C,WAASU,aAAT,GAAyB,iBAAzB;AACA,yBAAWvE,GAAX,CAAeE,KAAf,EAAsBiC,QAAtB,EAAgC,UAAhC,EAA4C0B,QAA5C,EAAsD,IAAtD;;AAEA1B,WAASQ,mBAAT,GAA+B,KAA/B;AACA,SAAOR,QAAP;AACD;;AAEM,SAASxC,mBAAT,CACLO,KADK,EAELC,aAFK,EAGL6B,KAHK,EAILC,OAJK,EAKLY,aALK,EAMgB;AACrB,MAAIX,qBAAqB,iBAAIhC,KAAJ,EAAWC,aAAX,EAA0B,WAA1B,CAAzB;AACA,2BAAU+B,gDAAV;AACA;AACA,MAAIC,WAAW,uBAAgBjC,KAAhB,EAAuBgC,kBAAvB,EAA2C,MAA3C,EAAmD,IAAnD,CAAf;AACAU,yCAAuC1C,KAAvC,EAA8CiC,QAA9C,EAAwDD,kBAAxD,EAA4EW,aAA5E;;AAEA;AACA,yBAAW7C,GAAX,CAAeE,KAAf,EAAsBiC,QAAtB,EAAgC,MAAhC,EAAwC,qBAAcxB,oBAAd,CAAmCT,KAAnC,EAA0C,WAA1C,CAAxC,EAAgG,IAAhG;AACA;AACA,yBAAWF,GAAX,CAAeE,KAAf,EAAsBiC,QAAtB,EAAgC,OAAhC,EAAyCH,KAAzC,EAAgD,IAAhD;AACA;AACA,yBAAWhC,GAAX,CAAeE,KAAf,EAAsBiC,QAAtB,EAAgC,SAAhC,EAA2CF,OAA3C,EAAoD,IAApD;AACA;AACAE,WAASQ,mBAAT,GAA+B,KAA/B;AACA;AACA,MAAIjC,QAAQ,qBAAcC,oBAAd,CAAmCT,KAAnC,EAA0C,MAA1C,EAAkDiC,QAAlD,CAAZ;AACA,2BAAUzB,2CAAV;AACA,SAAOA,KAAP;AACD;;AAEM,SAASd,wBAAT,CACLM,KADK,EAELsE,eAFK,EAGLxC,KAHK,EAILC,OAJK,EAKmE;AACxE,MAAIa,qBAAqB,IAAI9C,GAAJ,EAAzB;AACA,MAAI+C,kBAAkB,IAAI/C,GAAJ,EAAtB;;AAEAE,QAAMuE,YAAN,CAAmB,MACjBvE,MAAMwE,kBAAN,CACE,MAAM;AACJ,QAAIvC,WAAW,uBAAUjC,KAAV,EAAiBsE,eAAjB,EAAkC,CAACxC,KAAD,EAAQC,OAAR,CAAlC,CAAf;AACA,6BAAUE,sCAAV;AACA,SAAK,IAAI,CAACwC,YAAD,CAAT,IAA2BxC,SAASE,UAApC,EAAgD;AAC9C,UAAI,CAACpC,sBAAsBqC,GAAtB,CAA0BqC,YAA1B,CAAL,EAA8C;AAC5C7B,2BAAmBP,GAAnB,CAAuBoC,YAAvB;AACD;AACF;AACD,SAAK,IAAI,CAACvB,MAAD,CAAT,IAAqBjB,SAASkB,OAA9B,EAAuC;AACrCN,sBAAgBR,GAAhB,CAAoBa,MAApB;AACD;AACD,WAAOjB,QAAP;AACD,GAbH;AAcE,WAAU,IAdZ,EAeG,gCAA+BqC,gBAAgBI,OAAhB,EAA0B,EAf5D,CADF;;AAoBA,SAAO;AACL9B,sBADK;AAELC;AAFK,GAAP;AAID;;AAEM,SAASlD,6BAAT,CACLK,KADK,EAEL2E,wBAFK,EAGL1C,QAHK,EAILH,KAJK,EAKC;AACN,MAAIiC,YAAY,iBAAI/D,KAAJ,EAAWiC,QAAX,EAAqB,OAArB,CAAhB;AACA,MAAI2C,+BAA+BD,yBAAyBnB,KAA5D;AACA,2BAAUoB,iCAAiC/D,SAA3C;AACA,MAAIgE,eAAeD,6BAA6B5E,MAAMgD,UAAN,CAAiB8B,IAA9C,EAAoD,CAAChD,KAAD,EAAQiC,SAAR,CAApD,CAAnB;;AAEA,QAAMgB,cAActB,SAAS;AAC3B,QAAIJ,eAAe,iBAAIrD,KAAJ,EAAWA,MAAMgD,UAAN,CAAiBM,MAA5B,EAAoC,QAApC,CAAnB;AACA,6BAAUD,sDAAV;AACA,QAAIE,mBAAmBF,aAAaG,KAApC;AACA,6BAAUD,qBAAqB1C,SAA/B;;AAEA,QAAI4C,yCAAkC,EAAEA,2CAAF,CAAtC,EAA+E;AAC7E,YAAMuB,OAAOvB,MAAMuB,IAAnB;;AAEA,UAAIA,SAAS,aAAb,EAA4B;AAC1B,YAAIC,YAAYxB,MAAMyB,IAAN,CAAW,CAAX,CAAhB;AACA,YAAIC,IAAIJ,YAAYtB,MAAMyB,IAAN,CAAW,CAAX,CAAZ,CAAR;AACA,YAAIE,IAAIL,YAAYtB,MAAMyB,IAAN,CAAW,CAAX,CAAZ,CAAR;AACA,iCAAUD,yCAAV;AACA,YAAIE,MAAM,IAAN,IAAcC,MAAM,IAAxB,EAA8B;AAC5B,iBAAO,IAAP;AACD,SAFD,MAEO,IAAID,MAAM,IAAV,EAAgB;AACrB,mCAAUC,yBAAV;AACA,iBAAO,qBAAcC,uBAAd,CAAsCrF,KAAtC,EAA6CiF,SAA7C,EAAwDjF,MAAMgD,UAAN,CAAiBsC,KAAzE,EAAgFF,CAAhF,CAAP;AACD,SAHM,MAGA,IAAIA,MAAM,IAAV,EAAgB;AACrB,mCAAUD,yBAAV;AACA,iBAAO,qBAAcE,uBAAd,CAAsCrF,KAAtC,EAA6CiF,SAA7C,EAAwDE,CAAxD,EAA2DnF,MAAMgD,UAAN,CAAiBsC,KAA5E,CAAP;AACD,SAHM,MAGA;AACL,mCAAUH,yBAAV;AACA,mCAAUC,yBAAV;AACA,iBAAO,qBAAcC,uBAAd,CAAsCrF,KAAtC,EAA6CiF,SAA7C,EAAwDE,CAAxD,EAA2DC,CAA3D,CAAP;AACD;AACF,OAlBD,MAkBO,IAAIJ,SAAS,IAAT,IAAiBA,SAAS,IAA9B,EAAoC;AACzC,YAAIG,IAAIJ,YAAYtB,MAAMyB,IAAN,CAAW,CAAX,CAAZ,CAAR;AACA,YAAIE,IAAIL,YAAYtB,MAAMyB,IAAN,CAAW,CAAX,CAAZ,CAAR;AACA,YAAIE,MAAM,IAAV,EAAgB;AACd,mCAAUD,yBAAV;AACA,iBAAO,qBAAcI,mBAAd,CAAkCvF,KAAlC,EAAyCgF,IAAzC,EAA+CG,CAA/C,EAAkDnF,MAAMgD,UAAN,CAAiBsC,KAAnE,CAAP;AACD,SAHD,MAGO;AACL,mCAAUH,yBAAV;AACA,mCAAUC,yBAAV;AACA,iBAAO,qBAAcG,mBAAd,CAAkCvF,KAAlC,EAAyCgF,IAAzC,EAA+CG,CAA/C,EAAkDC,CAAlD,CAAP;AACD;AACF,OAXM,MAWA;AACL,iCAAU3B,MAAMyB,IAAN,KAAerE,SAAzB,EAAoC,oDAApC;AACA;AACA;AACA,YAAIsE,IAAI,qBAAcK,kBAAd,CAAiCxF,KAAjC,EAAwC,KAAxC,EAA+CyD,KAA/C,EAAsDzD,MAAMgD,UAAN,CAAiB8B,IAAvE,CAAR;AACA,YAAIM,IAAI,qBAAcI,kBAAd,CAAiCxF,KAAjC,EAAwC,KAAxC,EAA+CyD,KAA/C,EAAsDzD,MAAMgD,UAAN,CAAiBnC,SAAvE,CAAR;AACA,YAAI4E,IAAI,qBAAcF,mBAAd,CAAkCvF,KAAlC,EAAyC,IAAzC,EAA+CmF,CAA/C,EAAkDC,CAAlD,CAAR;AACA,iCAAUK,iCAAV;AACA,YAAIzB,WAAW,uBAAgBhE,KAAhB,EAAuBA,MAAMgD,UAAN,CAAiBC,eAAxC,CAAf;AACA;AACA;AACA;AACA;AACA,6BAAcyC,+BAAd,CACE1F,KADF,wBAGE,CAACqD,YAAD,EAAeW,QAAf,EAAyBD,SAAzB,EAAoCN,KAApC,CAHF,EAIE,CAAC,CAACkC,UAAD,EAAa,GAAGC,KAAhB,CAAD,KAA4B;AAC1B,iBAAOhG,EAAEiG,cAAF,CAAiBF,UAAjB,EAA+BC,KAA/B,CAAP;AACD,SANH;AAQA5B,iBAAS8B,UAAT;AACA9B,iBAAS+B,WAAT;AACA/B,iBAASN,SAAT;AACA,YAAIsC,cAAc,qBAAcT,mBAAd,CAAkCvF,KAAlC,EAAyC,IAAzC,EAA+CyF,CAA/C,EAAkDzB,QAAlD,CAAlB;AACA,eAAOgC,WAAP;AACD;AACF,KA3DD,MA2DO,IAAIvC,UAAUzD,MAAMgD,UAAN,CAAiB8B,IAA3B,IAAmCrB,UAAUzD,MAAMgD,UAAN,CAAiBnC,SAAlE,EAA6E;AAClF,UAAImD,WAAW,uBAAgBhE,KAAhB,EAAuBA,MAAMgD,UAAN,CAAiBC,eAAxC,CAAf;AACA,UAAI;AACFM,yBAAiBvD,MAAMgD,UAAN,CAAiBnC,SAAlC,EAA6C,CAACmD,QAAD,EAAWD,SAAX,EAAsBN,KAAtB,CAA7C;AACD,OAFD,CAEE,OAAOwC,CAAP,EAAU;AACV,YAAIjG,MAAMkG,aAAN,MAAyBD,gCAA7B,EAAsD;AACpD,+BAAcP,+BAAd,CACE1F,KADF,wBAGE,CAACqD,YAAD,EAAeW,QAAf,EAAyBD,SAAzB,EAAoCN,KAApC,CAHF,EAIE,CAAC,CAACkC,UAAD,EAAa,GAAGC,KAAhB,CAAD,KAA4B;AAC1B,mBAAOhG,EAAEiG,cAAF,CAAiBF,UAAjB,EAA+BC,KAA/B,CAAP;AACD,WANH;AAQA5B,mBAAS8B,UAAT;AACA9B,mBAAS+B,WAAT;AACA,iBAAO/B,QAAP;AACD;AACD,cAAMiC,CAAN;AACD;AACDjC,eAASN,SAAT;AACA,aAAOM,QAAP;AACD,KAtBM,MAsBA;AACL,aAAO,IAAP;AACD;AACF,GA1FD;;AA4FA,MAAIA,WAAWe,YAAYF,YAAZ,CAAf;AACA,MAAIb,aAAa,IAAjB,EAAuB;AACrB,QAAIA,wCAAJ,EAAuC;AACrCA,iBAAW,qBAAcuB,mBAAd,CAAkCvF,KAAlC,EAAyC,IAAzC,EAA+CgE,QAA/C,EAAyDD,SAAzD,CAAX;AACD;AACD,6BAAUC,gCAAV;AACA,2BAAWlE,GAAX,CAAeE,KAAf,EAAsBiC,QAAtB,EAAgC,OAAhC,EAAyC+B,QAAzC,EAAmD,IAAnD;AACD;AACF","file":"components.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm } from \"../realm.js\";\nimport {\n  ECMAScriptSourceFunctionValue,\n  AbstractValue,\n  ObjectValue,\n  AbstractObjectValue,\n  SymbolValue,\n  NativeFunctionValue,\n  ECMAScriptFunctionValue,\n  Value,\n  FunctionValue,\n} from \"../values/index.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNodeIdentifier } from \"babel-types\";\nimport { valueIsClassComponent, deleteRefAndKeyFromProps, getProperty, getValueFromFunctionCall } from \"./utils\";\nimport { ExpectedBailOut, SimpleClassBailOut } from \"./errors.js\";\nimport { Get, Construct } from \"../methods/index.js\";\nimport { Properties } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport traverse from \"babel-traverse\";\nimport type { ClassComponentMetadata } from \"../types.js\";\nimport type { ReactEvaluatedNode } from \"../serializer/types.js\";\nimport { FatalError } from \"../errors.js\";\n\nconst lifecycleMethods = new Set([\n  \"componentWillUnmount\",\n  \"componentDidMount\",\n  \"componentWillMount\",\n  \"componentDidUpdate\",\n  \"componentWillUpdate\",\n  \"componentDidCatch\",\n  \"componentWillReceiveProps\",\n]);\n\nconst whitelistedProperties = new Set([\"props\", \"context\", \"refs\", \"setState\"]);\n\nexport function getInitialProps(\n  realm: Realm,\n  componentType: ECMAScriptSourceFunctionValue | null\n): AbstractObjectValue {\n  let propsName = null;\n  if (componentType !== null) {\n    if (valueIsClassComponent(realm, componentType)) {\n      propsName = \"this.props\";\n    } else {\n      // otherwise it's a functional component, where the first paramater of the function is \"props\" (if it exists)\n      if (componentType.$FormalParameters.length > 0) {\n        let firstParam = componentType.$FormalParameters[0];\n        if (t.isIdentifier(firstParam)) {\n          propsName = ((firstParam: any): BabelNodeIdentifier).name;\n        }\n      }\n    }\n  }\n  let value = AbstractValue.createAbstractObject(realm, propsName || \"props\");\n  // props objects don't have a key and ref, so we remove them\n  deleteRefAndKeyFromProps(realm, value);\n  invariant(value instanceof AbstractObjectValue);\n  return value;\n}\n\nexport function getInitialContext(realm: Realm, componentType: ECMAScriptSourceFunctionValue): AbstractObjectValue {\n  let contextName = null;\n  if (valueIsClassComponent(realm, componentType)) {\n    // it's a class component, so we need to check the type on for context of the component prototype\n    let superTypeParameters = componentType.$SuperTypeParameters;\n    contextName = \"this.context\";\n\n    if (superTypeParameters !== undefined) {\n      throw new ExpectedBailOut(\"context on class components not yet supported\");\n    }\n  } else {\n    // otherwise it's a functional component, where the second paramater of the function is \"context\" (if it exists)\n    if (componentType.$FormalParameters.length > 1) {\n      let secondParam = componentType.$FormalParameters[1];\n      if (t.isIdentifier(secondParam)) {\n        contextName = ((secondParam: any): BabelNodeIdentifier).name;\n      }\n    }\n  }\n  let value = AbstractValue.createAbstractObject(realm, contextName || \"context\");\n  return value;\n}\n\nfunction visitClassMethodAstForThisUsage(realm: Realm, method: ECMAScriptSourceFunctionValue): void {\n  let formalParameters = method.$FormalParameters;\n  let code = method.$ECMAScriptCode;\n\n  traverse(\n    t.file(t.program([t.expressionStatement(t.functionExpression(null, formalParameters, code))])),\n    {\n      ThisExpression(path) {\n        let parentNode = path.parentPath.node;\n\n        if (!t.isMemberExpression(parentNode)) {\n          throw new SimpleClassBailOut(`possible leakage of independent \"this\" reference found`);\n        }\n      },\n    },\n    null,\n    {}\n  );\n}\n\nexport function createSimpleClassInstance(\n  realm: Realm,\n  componentType: ECMAScriptSourceFunctionValue,\n  props: ObjectValue | AbstractValue,\n  context: ObjectValue | AbstractValue\n): AbstractObjectValue {\n  let componentPrototype = Get(realm, componentType, \"prototype\");\n  invariant(componentPrototype instanceof ObjectValue);\n  // create an instance object and disable serialization as we don't want to output the internals we set below\n  let instance = new ObjectValue(realm, componentPrototype, \"this\", true);\n  let allowedPropertyAccess = new Set([\"props\", \"context\"]);\n  for (let [name] of componentPrototype.properties) {\n    if (lifecycleMethods.has(name)) {\n      // this error will result in the simple class falling back to a complex class\n      throw new SimpleClassBailOut(\"lifecycle methods are not supported on simple classes\");\n    } else if (name !== \"constructor\") {\n      allowedPropertyAccess.add(name);\n      let method = Get(realm, componentPrototype, name);\n      if (method instanceof ECMAScriptSourceFunctionValue) {\n        visitClassMethodAstForThisUsage(realm, method);\n      }\n      Properties.Set(realm, instance, name, method, true);\n    }\n  }\n  // assign props\n  Properties.Set(realm, instance, \"props\", props, true);\n  // assign context\n  Properties.Set(realm, instance, \"context\", context, true);\n  // as this object is simple, we want to check if any access to anything other than\n  // \"this.props\" or \"this.context\" or methods on the class occur\n  let $GetOwnProperty = instance.$GetOwnProperty;\n  instance.$GetOwnProperty = P => {\n    if (!allowedPropertyAccess.has(P)) {\n      // this error will result in the simple class falling back to a complex class\n      throw new SimpleClassBailOut(\"access to basic class instance properties is not supported on simple classes\");\n    }\n    return $GetOwnProperty.call(instance, P);\n  };\n  // enable serialization to support simple instance variables properties\n  instance.refuseSerialization = false;\n  // return the instance\n  return instance;\n}\n\nfunction deeplyApplyInstancePrototypeProperties(\n  realm: Realm,\n  instance: ObjectValue,\n  componentPrototype: ObjectValue,\n  classMetadata: ClassComponentMetadata\n) {\n  let { instanceProperties, instanceSymbols } = classMetadata;\n  let proto = componentPrototype.$Prototype;\n\n  if (proto instanceof ObjectValue && proto !== realm.intrinsics.ObjectPrototype) {\n    deeplyApplyInstancePrototypeProperties(realm, instance, proto, classMetadata);\n  }\n\n  for (let [name] of componentPrototype.properties) {\n    // ensure we don't set properties that were defined on the instance\n    if (name !== \"constructor\" && !instanceProperties.has(name)) {\n      Properties.Set(realm, instance, name, Get(realm, componentPrototype, name), true);\n    }\n  }\n  for (let [symbol] of componentPrototype.symbols) {\n    // ensure we don't set symbols that were defined on the instance\n    if (!instanceSymbols.has(symbol)) {\n      Properties.Set(realm, instance, symbol, Get(realm, componentPrototype, symbol), true);\n    }\n  }\n}\n\nexport function createClassInstanceForFirstRenderOnly(\n  realm: Realm,\n  componentType: ECMAScriptSourceFunctionValue,\n  props: ObjectValue | AbstractValue,\n  context: ObjectValue | AbstractValue,\n  evaluatedNode: ReactEvaluatedNode\n): ObjectValue {\n  let instance = getValueFromFunctionCall(realm, componentType, realm.intrinsics.undefined, [props, context], true);\n  let objectAssign = Get(realm, realm.intrinsics.Object, \"assign\");\n  invariant(objectAssign instanceof ECMAScriptFunctionValue);\n  let objectAssignCall = objectAssign.$Call;\n  invariant(objectAssignCall !== undefined);\n\n  invariant(instance instanceof ObjectValue);\n  instance.refuseSerialization = true;\n  // assign props\n  Properties.Set(realm, instance, \"props\", props, true);\n  // assign context\n  Properties.Set(realm, instance, \"context\", context, true);\n  let state = Get(realm, instance, \"state\");\n  if (state instanceof AbstractObjectValue || state instanceof ObjectValue) {\n    state.makeFinal();\n  }\n  // assign a mocked setState\n  let setState = new NativeFunctionValue(realm, undefined, `setState`, 1, (_context, [stateToUpdate, callback]) => {\n    invariant(instance instanceof ObjectValue);\n    let prevState = Get(realm, instance, \"state\");\n    invariant(prevState instanceof ObjectValue);\n\n    if (stateToUpdate instanceof ECMAScriptSourceFunctionValue && stateToUpdate.$Call) {\n      stateToUpdate = stateToUpdate.$Call(instance, [prevState]);\n    }\n    if (stateToUpdate instanceof ObjectValue) {\n      let newState = new ObjectValue(realm, realm.intrinsics.ObjectPrototype);\n      objectAssignCall(realm.intrinsics.undefined, [newState, prevState]);\n\n      for (let [key, binding] of stateToUpdate.properties) {\n        if (binding && binding.descriptor && binding.descriptor.enumerable) {\n          let value = getProperty(realm, stateToUpdate, key);\n          Properties.Set(realm, newState, key, value, true);\n        }\n      }\n\n      newState.makeFinal();\n      Properties.Set(realm, instance, \"state\", newState, true);\n    }\n    if (callback instanceof ECMAScriptSourceFunctionValue && callback.$Call) {\n      callback.$Call(instance, []);\n    }\n    return realm.intrinsics.undefined;\n  });\n  setState.intrinsicName = \"(function() {})\";\n  Properties.Set(realm, instance, \"setState\", setState, true);\n\n  instance.refuseSerialization = false;\n  return instance;\n}\n\nexport function createClassInstance(\n  realm: Realm,\n  componentType: ECMAScriptSourceFunctionValue,\n  props: ObjectValue | AbstractValue,\n  context: ObjectValue | AbstractValue,\n  classMetadata: ClassComponentMetadata\n): AbstractObjectValue {\n  let componentPrototype = Get(realm, componentType, \"prototype\");\n  invariant(componentPrototype instanceof ObjectValue);\n  // create an instance object and disable serialization as we don't want to output the internals we set below\n  let instance = new ObjectValue(realm, componentPrototype, \"this\", true);\n  deeplyApplyInstancePrototypeProperties(realm, instance, componentPrototype, classMetadata);\n\n  // assign refs\n  Properties.Set(realm, instance, \"refs\", AbstractValue.createAbstractObject(realm, \"this.refs\"), true);\n  // assign props\n  Properties.Set(realm, instance, \"props\", props, true);\n  // assign context\n  Properties.Set(realm, instance, \"context\", context, true);\n  // enable serialization to support simple instance variables properties\n  instance.refuseSerialization = false;\n  // return the instance in an abstract object\n  let value = AbstractValue.createAbstractObject(realm, \"this\", instance);\n  invariant(value instanceof AbstractObjectValue);\n  return value;\n}\n\nexport function evaluateClassConstructor(\n  realm: Realm,\n  constructorFunc: ECMAScriptSourceFunctionValue,\n  props: ObjectValue | AbstractValue | AbstractObjectValue,\n  context: ObjectValue | AbstractObjectValue\n): { instanceProperties: Set<string>, instanceSymbols: Set<SymbolValue> } {\n  let instanceProperties = new Set();\n  let instanceSymbols = new Set();\n\n  realm.evaluatePure(() =>\n    realm.evaluateForEffects(\n      () => {\n        let instance = Construct(realm, constructorFunc, [props, context]);\n        invariant(instance instanceof ObjectValue);\n        for (let [propertyName] of instance.properties) {\n          if (!whitelistedProperties.has(propertyName)) {\n            instanceProperties.add(propertyName);\n          }\n        }\n        for (let [symbol] of instance.symbols) {\n          instanceSymbols.add(symbol);\n        }\n        return instance;\n      },\n      /*state*/ null,\n      `react component constructor: ${constructorFunc.getName()}`\n    )\n  );\n\n  return {\n    instanceProperties,\n    instanceSymbols,\n  };\n}\n\nexport function applyGetDerivedStateFromProps(\n  realm: Realm,\n  getDerivedStateFromProps: ECMAScriptSourceFunctionValue,\n  instance: ObjectValue,\n  props: ObjectValue | AbstractValue | AbstractObjectValue\n): void {\n  let prevState = Get(realm, instance, \"state\");\n  let getDerivedStateFromPropsCall = getDerivedStateFromProps.$Call;\n  invariant(getDerivedStateFromPropsCall !== undefined);\n  let partialState = getDerivedStateFromPropsCall(realm.intrinsics.null, [props, prevState]);\n\n  const deriveState = state => {\n    let objectAssign = Get(realm, realm.intrinsics.Object, \"assign\");\n    invariant(objectAssign instanceof ECMAScriptFunctionValue);\n    let objectAssignCall = objectAssign.$Call;\n    invariant(objectAssignCall !== undefined);\n\n    if (state instanceof AbstractValue && !(state instanceof AbstractObjectValue)) {\n      const kind = state.kind;\n\n      if (kind === \"conditional\") {\n        let condition = state.args[0];\n        let a = deriveState(state.args[1]);\n        let b = deriveState(state.args[2]);\n        invariant(condition instanceof AbstractValue);\n        if (a === null && b === null) {\n          return null;\n        } else if (a === null) {\n          invariant(b instanceof Value);\n          return AbstractValue.createFromConditionalOp(realm, condition, realm.intrinsics.false, b);\n        } else if (b === null) {\n          invariant(a instanceof Value);\n          return AbstractValue.createFromConditionalOp(realm, condition, a, realm.intrinsics.false);\n        } else {\n          invariant(a instanceof Value);\n          invariant(b instanceof Value);\n          return AbstractValue.createFromConditionalOp(realm, condition, a, b);\n        }\n      } else if (kind === \"||\" || kind === \"&&\") {\n        let a = deriveState(state.args[0]);\n        let b = deriveState(state.args[1]);\n        if (b === null) {\n          invariant(a instanceof Value);\n          return AbstractValue.createFromLogicalOp(realm, kind, a, realm.intrinsics.false);\n        } else {\n          invariant(a instanceof Value);\n          invariant(b instanceof Value);\n          return AbstractValue.createFromLogicalOp(realm, kind, a, b);\n        }\n      } else {\n        invariant(state.args !== undefined, \"TODO: unknown abstract value passed to deriveState\");\n        // as the value is completely abstract, we need to add a bunch of\n        // operations to be emitted to ensure we do the right thing at runtime\n        let a = AbstractValue.createFromBinaryOp(realm, \"!==\", state, realm.intrinsics.null);\n        let b = AbstractValue.createFromBinaryOp(realm, \"!==\", state, realm.intrinsics.undefined);\n        let c = AbstractValue.createFromLogicalOp(realm, \"&&\", a, b);\n        invariant(c instanceof AbstractValue);\n        let newState = new ObjectValue(realm, realm.intrinsics.ObjectPrototype);\n        // we cannot use the standard Object.assign as partial state\n        // is not simple. however, given getDerivedStateFromProps is\n        // meant to be pure, we can assume that there are no getters on\n        // the partial abstract state\n        AbstractValue.createTemporalFromBuildFunction(\n          realm,\n          FunctionValue,\n          [objectAssign, newState, prevState, state],\n          ([methodNode, ..._args]) => {\n            return t.callExpression(methodNode, ((_args: any): Array<any>));\n          }\n        );\n        newState.makeSimple();\n        newState.makePartial();\n        newState.makeFinal();\n        let conditional = AbstractValue.createFromLogicalOp(realm, \"&&\", c, newState);\n        return conditional;\n      }\n    } else if (state !== realm.intrinsics.null && state !== realm.intrinsics.undefined) {\n      let newState = new ObjectValue(realm, realm.intrinsics.ObjectPrototype);\n      try {\n        objectAssignCall(realm.intrinsics.undefined, [newState, prevState, state]);\n      } catch (e) {\n        if (realm.isInPureScope() && e instanceof FatalError) {\n          AbstractValue.createTemporalFromBuildFunction(\n            realm,\n            FunctionValue,\n            [objectAssign, newState, prevState, state],\n            ([methodNode, ..._args]) => {\n              return t.callExpression(methodNode, ((_args: any): Array<any>));\n            }\n          );\n          newState.makeSimple();\n          newState.makePartial();\n          return newState;\n        }\n        throw e;\n      }\n      newState.makeFinal();\n      return newState;\n    } else {\n      return null;\n    }\n  };\n\n  let newState = deriveState(partialState);\n  if (newState !== null) {\n    if (newState instanceof AbstractValue) {\n      newState = AbstractValue.createFromLogicalOp(realm, \"||\", newState, prevState);\n    }\n    invariant(newState instanceof Value);\n    Properties.Set(realm, instance, \"state\", newState, true);\n  }\n}\n"]}