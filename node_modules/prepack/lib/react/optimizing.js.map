{"version":3,"sources":["../../src/react/optimizing.js"],"names":["optimizeReactComponentTreeRoot","applyOptimizedReactComponents","applyWriteEffectsForOptimizedComponent","realm","componentType","effects","componentTreeState","evaluatedNode","writeEffects","environmentRecordIdAfterGlobalCode","additionalFunctionEffects","name","value","result","intrinsics","undefined","status","set","prototype","renderMethod","contextTypes","size","ObjectPrototype","noOpFunc","key","Set","optimizeReactComponentTreeBranches","reconciler","logger","react","verbose","branchedComponentTrees","length","logInformation","rootValue","branchRootValue","branchComponentType","hasEvaluatedRootNode","clearComponentTreeState","branchEffects","resolveReactComponentTree","branchComponentTreeState","optimizeReactNestedClosures","nestedOptimizedClosures","func","nestedEffects","context","branchState","hasEvaluatedNestedClosure","closureEffects","resolveNestedOptimizedClosure","$BoundTargetFunction","componentRoot","config","statistics","reactSerializerState","evaluatedRootNode","evaluatedRootNodes","push","componentTreeEffects","startingComponentTreeBranches","optimizedNestedClosuresToWrite"],"mappings":"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","file":"optimizing.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { type Effects, Realm } from \"../realm.js\";\nimport { AbstractValue, ECMAScriptSourceFunctionValue, BoundFunctionValue, ObjectValue } from \"../values/index.js\";\nimport { createAdditionalEffects } from \"../serializer/utils.js\";\nimport {\n  convertFunctionalComponentToComplexClassComponent,\n  convertSimpleClassComponentToFunctionalComponent,\n  createNoopFunction,\n  createReactEvaluatedNode,\n  getComponentName,\n  getComponentTypeFromRootValue,\n  normalizeFunctionalComponentParamaters,\n  valueIsClassComponent,\n} from \"./utils.js\";\nimport {\n  type WriteEffects,\n  type ReactEvaluatedNode,\n  type ReactSerializerState,\n  ReactStatistics,\n} from \"../serializer/types.js\";\nimport { Reconciler, type ComponentTreeState } from \"./reconcilation.js\";\nimport { ReconcilerFatalError } from \"./errors.js\";\nimport { Properties } from \"../singletons.js\";\nimport { Get } from \"../methods/index.js\";\nimport invariant from \"../invariant.js\";\nimport type { ReactComponentTreeConfig } from \"../types.js\";\nimport { Logger } from \"../utils/logger.js\";\n\nfunction applyWriteEffectsForOptimizedComponent(\n  realm: Realm,\n  componentType: ECMAScriptSourceFunctionValue,\n  effects: Effects,\n  componentTreeState: ComponentTreeState,\n  evaluatedNode: ReactEvaluatedNode,\n  writeEffects: WriteEffects,\n  environmentRecordIdAfterGlobalCode: number\n): void {\n  let additionalFunctionEffects = createAdditionalEffects(\n    realm,\n    effects,\n    false,\n    \"ReactAdditionalFunctionEffects\",\n    environmentRecordIdAfterGlobalCode\n  );\n  if (additionalFunctionEffects === null) {\n    throw new ReconcilerFatalError(\n      `Failed to optimize React component tree for \"${evaluatedNode.name}\" due to an unsupported completion`,\n      evaluatedNode\n    );\n  }\n  effects = additionalFunctionEffects.effects;\n  let value = effects.result;\n\n  if (value === realm.intrinsics.undefined) {\n    // if we get undefined, then this component tree failed and a message was already logged\n    // in the reconciler\n    return;\n  }\n  if (valueIsClassComponent(realm, componentType)) {\n    if (componentTreeState.status === \"SIMPLE\") {\n      // if the root component was a class and is now simple, we can convert it from a class\n      // component to a functional component\n      convertSimpleClassComponentToFunctionalComponent(realm, componentType, additionalFunctionEffects);\n      normalizeFunctionalComponentParamaters(componentType);\n      writeEffects.set(componentType, additionalFunctionEffects);\n    } else {\n      let prototype = Get(realm, componentType, \"prototype\");\n      invariant(prototype instanceof ObjectValue);\n      let renderMethod = Get(realm, prototype, \"render\");\n      invariant(renderMethod instanceof ECMAScriptSourceFunctionValue);\n      writeEffects.set(renderMethod, additionalFunctionEffects);\n    }\n  } else {\n    if (componentTreeState.status === \"COMPLEX\") {\n      convertFunctionalComponentToComplexClassComponent(\n        realm,\n        componentType,\n        componentTreeState.componentType,\n        additionalFunctionEffects\n      );\n      let prototype = Get(realm, componentType, \"prototype\");\n      invariant(prototype instanceof ObjectValue);\n      let renderMethod = Get(realm, prototype, \"render\");\n      invariant(renderMethod instanceof ECMAScriptSourceFunctionValue);\n      writeEffects.set(renderMethod, additionalFunctionEffects);\n    } else {\n      normalizeFunctionalComponentParamaters(componentType);\n      writeEffects.set(componentType, additionalFunctionEffects);\n    }\n  }\n  // apply contextTypes for legacy context\n  if (componentTreeState.contextTypes.size > 0) {\n    let contextTypes = new ObjectValue(realm, realm.intrinsics.ObjectPrototype);\n    let noOpFunc = createNoopFunction(realm);\n    for (let key of componentTreeState.contextTypes) {\n      Properties.Set(realm, contextTypes, key, noOpFunc, true);\n    }\n    Properties.Set(realm, componentType, \"contextTypes\", contextTypes, true);\n  }\n}\n\nfunction optimizeReactComponentTreeBranches(\n  realm: Realm,\n  reconciler: Reconciler,\n  writeEffects: WriteEffects,\n  environmentRecordIdAfterGlobalCode: number,\n  logger: Logger\n): void {\n  if (realm.react.verbose && reconciler.branchedComponentTrees.length > 0) {\n    logger.logInformation(`  Evaluating React component tree branches...`);\n  }\n  // for now we just use abstract props/context, in the future we'll create a new branch with a new component\n  // that used the props/context. It will extend the original component and only have a render method\n  for (let { rootValue: branchRootValue, evaluatedNode } of reconciler.branchedComponentTrees) {\n    let branchComponentType = getComponentTypeFromRootValue(realm, branchRootValue);\n    if (branchComponentType === null) {\n      evaluatedNode.status = \"UNKNOWN_TYPE\";\n      continue;\n    }\n    // so we don't process the same component multiple times (we might change this logic later)\n    if (reconciler.hasEvaluatedRootNode(branchComponentType, evaluatedNode)) {\n      continue;\n    }\n    reconciler.clearComponentTreeState();\n    if (realm.react.verbose) {\n      logger.logInformation(`    Evaluating ${evaluatedNode.name} (branch)`);\n    }\n    let branchEffects = reconciler.resolveReactComponentTree(branchComponentType, null, null, evaluatedNode);\n    if (realm.react.verbose) {\n      logger.logInformation(`    ✔ ${evaluatedNode.name} (branch)`);\n    }\n    let branchComponentTreeState = reconciler.componentTreeState;\n    applyWriteEffectsForOptimizedComponent(\n      realm,\n      branchComponentType,\n      branchEffects,\n      branchComponentTreeState,\n      evaluatedNode,\n      writeEffects,\n      environmentRecordIdAfterGlobalCode\n    );\n  }\n}\n\nfunction optimizeReactNestedClosures(\n  realm: Realm,\n  reconciler: Reconciler,\n  writeEffects: WriteEffects,\n  environmentRecordIdAfterGlobalCode: number,\n  logger: Logger\n): void {\n  if (realm.react.verbose && reconciler.nestedOptimizedClosures.length > 0) {\n    logger.logInformation(`  Evaluating nested closures...`);\n  }\n  for (let {\n    func,\n    evaluatedNode,\n    nestedEffects,\n    componentType,\n    context,\n    branchState,\n  } of reconciler.nestedOptimizedClosures) {\n    if (reconciler.hasEvaluatedNestedClosure(func)) {\n      continue;\n    }\n    if (func instanceof ECMAScriptSourceFunctionValue && reconciler.hasEvaluatedRootNode(func, evaluatedNode)) {\n      continue;\n    }\n    if (realm.react.verbose) {\n      logger.logInformation(`    Evaluating function \"${getComponentName(realm, func)}\"`);\n    }\n    let closureEffects = reconciler.resolveNestedOptimizedClosure(\n      func,\n      nestedEffects,\n      componentType,\n      context,\n      branchState,\n      evaluatedNode\n    );\n    if (realm.react.verbose) {\n      logger.logInformation(`    ✔ function \"${getComponentName(realm, func)}\"`);\n    }\n    let additionalFunctionEffects = createAdditionalEffects(\n      realm,\n      closureEffects,\n      true,\n      \"ReactNestedAdditionalFunctionEffects\",\n      environmentRecordIdAfterGlobalCode\n    );\n    invariant(additionalFunctionEffects);\n    if (func instanceof BoundFunctionValue) {\n      invariant(func.$BoundTargetFunction instanceof ECMAScriptSourceFunctionValue);\n      writeEffects.set(func.$BoundTargetFunction, additionalFunctionEffects);\n    } else {\n      writeEffects.set(func, additionalFunctionEffects);\n    }\n  }\n}\n\nexport function optimizeReactComponentTreeRoot(\n  realm: Realm,\n  componentRoot: ECMAScriptSourceFunctionValue | AbstractValue,\n  config: ReactComponentTreeConfig,\n  writeEffects: WriteEffects,\n  environmentRecordIdAfterGlobalCode: number,\n  logger: Logger,\n  statistics: ReactStatistics,\n  reactSerializerState: ReactSerializerState\n): void {\n  let reconciler = new Reconciler(realm, config, statistics, logger, reactSerializerState);\n  let componentType = getComponentTypeFromRootValue(realm, componentRoot);\n  if (componentType === null) {\n    return;\n  }\n  let evaluatedRootNode = createReactEvaluatedNode(\"ROOT\", getComponentName(realm, componentType));\n  statistics.evaluatedRootNodes.push(evaluatedRootNode);\n  if (reconciler.hasEvaluatedRootNode(componentType, evaluatedRootNode)) {\n    return;\n  }\n  if (realm.react.verbose) {\n    logger.logInformation(`  Evaluating ${evaluatedRootNode.name} (root)`);\n  }\n  let componentTreeEffects = reconciler.resolveReactComponentTree(componentType, null, null, evaluatedRootNode);\n  if (realm.react.verbose) {\n    logger.logInformation(`  ✔ ${evaluatedRootNode.name} (root)`);\n  }\n\n  applyWriteEffectsForOptimizedComponent(\n    realm,\n    componentType,\n    componentTreeEffects,\n    reconciler.componentTreeState,\n    evaluatedRootNode,\n    writeEffects,\n    environmentRecordIdAfterGlobalCode\n  );\n\n  let startingComponentTreeBranches = 0;\n  do {\n    startingComponentTreeBranches = reconciler.branchedComponentTrees.length;\n    optimizeReactComponentTreeBranches(realm, reconciler, writeEffects, environmentRecordIdAfterGlobalCode, logger);\n    optimizeReactNestedClosures(realm, reconciler, writeEffects, environmentRecordIdAfterGlobalCode, logger);\n  } while (startingComponentTreeBranches !== reconciler.branchedComponentTrees.length);\n}\n\nexport function applyOptimizedReactComponents(\n  realm: Realm,\n  writeEffects: WriteEffects,\n  environmentRecordIdAfterGlobalCode: number\n): void {\n  for (let { effects, func } of realm.react.optimizedNestedClosuresToWrite) {\n    let additionalFunctionEffects = createAdditionalEffects(\n      realm,\n      effects,\n      true,\n      \"ReactNestedAdditionalFunctionEffects\",\n      environmentRecordIdAfterGlobalCode\n    );\n    invariant(additionalFunctionEffects);\n    if (func instanceof BoundFunctionValue) {\n      invariant(func.$BoundTargetFunction instanceof ECMAScriptSourceFunctionValue);\n      writeEffects.set(func.$BoundTargetFunction, additionalFunctionEffects);\n    } else {\n      writeEffects.set(func, additionalFunctionEffects);\n    }\n  }\n}\n"]}