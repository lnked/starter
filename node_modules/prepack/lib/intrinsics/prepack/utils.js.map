{"version":3,"sources":["../../../src/intrinsics/prepack/utils.js"],"names":["parseTypeNameOrTemplate","createAbstract","throwTemplateSrc","throwTemplate","realm","typeNameOrTemplate","undefined","type","template","getTypeFromName","createErrorThrowCompletion","intrinsics","TypeError","typeNameString","ToStringPartial","hasFunctionResultType","startsWith","substring","functionResultType","name","additionalValues","useAbstractInterpretation","result","locString","loc","executionContext","contextStack","slice","reverse","caller","function","lexicalEnvironment","locVal","kind","makeKind","objectCount","toString","createFromTemplate","isNameStringUnique","error","handleError","saveNameString","intrinsicName","values","Set","makePartial","rebuildNestedProperties","length","createAbstractConcreteUnion"],"mappings":"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","file":"utils.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../../realm.js\";\nimport {\n  Value,\n  AbstractValue,\n  ConcreteValue,\n  FunctionValue,\n  StringValue,\n  ObjectValue,\n  UndefinedValue,\n} from \"../../values/index.js\";\nimport buildExpressionTemplate from \"../../utils/builder.js\";\nimport { ValuesDomain } from \"../../domains/index.js\";\nimport { describeLocation } from \"../ecma262/Error.js\";\nimport { To } from \"../../singletons.js\";\nimport AbstractObjectValue from \"../../values/AbstractObjectValue\";\nimport { CompilerDiagnostic, FatalError } from \"../../errors.js\";\nimport { Utils } from \"../../singletons\";\nimport invariant from \"../../invariant.js\";\n\nconst throwTemplateSrc = \"(function(){throw new global.Error('abstract value defined at ' + A);})()\";\nconst throwTemplate = buildExpressionTemplate(throwTemplateSrc);\n\nexport function parseTypeNameOrTemplate(\n  realm: Realm,\n  typeNameOrTemplate: void | Value | string\n): { type: typeof Value, template: void | ObjectValue, functionResultType?: typeof Value } {\n  if (typeNameOrTemplate === undefined || typeNameOrTemplate instanceof UndefinedValue) {\n    return { type: Value, template: undefined };\n  } else if (typeof typeNameOrTemplate === \"string\") {\n    let type = Utils.getTypeFromName(typeNameOrTemplate);\n    if (type === undefined) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"unknown typeNameOrTemplate\");\n    }\n    return { type, template: undefined };\n  } else if (typeNameOrTemplate instanceof StringValue) {\n    let typeNameString = To.ToStringPartial(realm, typeNameOrTemplate);\n    let hasFunctionResultType = typeNameString.startsWith(\":\");\n    if (hasFunctionResultType) typeNameString = typeNameString.substring(1);\n    let type = Utils.getTypeFromName(typeNameString);\n    if (type === undefined) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"unknown typeNameOrTemplate\");\n    }\n    return hasFunctionResultType\n      ? { type: FunctionValue, template: undefined, functionResultType: type }\n      : { type, template: undefined };\n  } else if (typeNameOrTemplate instanceof FunctionValue) {\n    return { type: FunctionValue, template: typeNameOrTemplate };\n  } else if (typeNameOrTemplate instanceof ObjectValue) {\n    return { type: ObjectValue, template: typeNameOrTemplate };\n  } else {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"typeNameOrTemplate has unsupported type\");\n  }\n}\n\nexport function createAbstract(\n  realm: Realm,\n  typeNameOrTemplate?: Value | string,\n  name?: string,\n  ...additionalValues: Array<ConcreteValue>\n): AbstractValue | AbstractObjectValue {\n  if (!realm.useAbstractInterpretation) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"realm is not partial\");\n  }\n\n  let { type, template, functionResultType } = parseTypeNameOrTemplate(realm, typeNameOrTemplate);\n\n  let result;\n  let locString,\n    loc = null;\n  for (let executionContext of realm.contextStack.slice().reverse()) {\n    let caller = executionContext.caller;\n    loc = executionContext.loc;\n    locString = describeLocation(\n      realm,\n      caller ? caller.function : undefined,\n      caller ? caller.lexicalEnvironment : undefined,\n      loc\n    );\n    if (locString !== undefined) break;\n  }\n  if (!name) {\n    let locVal = new StringValue(realm, locString || \"(unknown location)\");\n    let kind = AbstractValue.makeKind(\"abstractCounted\", (realm.objectCount++).toString()); // need not be an object, but must be unique\n    result = AbstractValue.createFromTemplate(realm, throwTemplate, type, [locVal], kind);\n  } else {\n    let kind = AbstractValue.makeKind(\"abstract\", name);\n    if (!realm.isNameStringUnique(name)) {\n      let error = new CompilerDiagnostic(\"An abstract value with the same name exists\", loc, \"PP0019\", \"FatalError\");\n      realm.handleError(error);\n      throw new FatalError();\n    } else {\n      realm.saveNameString(name);\n    }\n    result = AbstractValue.createFromTemplate(realm, buildExpressionTemplate(name), type, [], kind);\n    result.intrinsicName = name;\n  }\n\n  if (template) result.values = new ValuesDomain(new Set([template]));\n  if (template && !(template instanceof FunctionValue)) {\n    // why exclude functions?\n    template.makePartial();\n    if (name) realm.rebuildNestedProperties(result, name);\n  }\n  if (functionResultType) {\n    invariant(result instanceof AbstractObjectValue);\n    result.functionResultType = functionResultType;\n  }\n\n  if (additionalValues.length > 0)\n    result = AbstractValue.createAbstractConcreteUnion(realm, result, ...additionalValues);\n  return result;\n}\n"]}